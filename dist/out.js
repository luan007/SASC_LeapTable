/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 121);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function () {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype,
      ObjProto = Object.prototype,
      FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      concat = ArrayProto.concat,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeForEach = ArrayProto.forEach,
      nativeMap = ArrayProto.map,
      nativeReduce = ArrayProto.reduce,
      nativeReduceRight = ArrayProto.reduceRight,
      nativeFilter = ArrayProto.filter,
      nativeEvery = ArrayProto.every,
      nativeSome = ArrayProto.some,
      nativeIndexOf = ArrayProto.indexOf,
      nativeLastIndexOf = ArrayProto.lastIndexOf,
      nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeBind = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function (obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function (obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function (obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function (value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function (value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function (value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function (obj, iterator, context) {
    var result;
    any(obj, function (value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function (obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function (value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function (obj, iterator, context) {
    return _.filter(obj, function (value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function (obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function (value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function (obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function (value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function (obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function (value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function (obj, key) {
    return _.map(obj, function (value) {
      return value[key];
    });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function (obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function (value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function (obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = { computed: -Infinity, value: -Infinity };
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = { value: value, computed: computed });
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = { computed: Infinity, value: Infinity };
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = { value: value, computed: computed });
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function (obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function (value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function (value) {
    return _.isFunction(value) ? value : function (obj) {
      return obj[value];
    };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function (obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function (obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function (value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function (obj, value, context) {
    return group(obj, value, context, function (result, key, value) {
      (_.has(result, key) ? result[key] : result[key] = []).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function (obj, value, context) {
    return group(obj, value, context, function (result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function (array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0,
        high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function (obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function (obj) {
    if (obj == null) return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null) return void 0;
    return n != null && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function (array, n, guard) {
    if (array == null) return void 0;
    if (n != null && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function (input, shallow, output) {
    each(input, function (value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function (array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function (value, index) {
      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function () {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function (array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function (item) {
      return _.every(rest, function (other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function (array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function () {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function (list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function (array, item, isSorted) {
    if (array == null) return -1;
    var i = 0,
        l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function (array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = hasIndex ? from : array.length;
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function (start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while (idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function (func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function () {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function (func) {
    var args = slice.call(arguments, 1);
    return function () {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function (obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function (f) {
      obj[f] = _.bind(obj[f], obj);
    });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function (func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function () {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function (func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function (func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function () {
      previous = new Date();
      timeout = null;
      result = func.apply(context, args);
    };
    return function () {
      var now = new Date();
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function (func, wait, immediate) {
    var timeout, result;
    return function () {
      var context = this,
          args = arguments;
      var later = function () {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function (func) {
    var ran = false,
        memo;
    return function () {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function (func, wrapper) {
    return function () {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function () {
    var funcs = arguments;
    return function () {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function (times, func) {
    if (times <= 0) return func();
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function (obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function (obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function (obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function (obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function (key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

  // Return a copy of the object without the blacklisted properties.
  _.omit = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function (a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0,
        result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor,
          bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !size--) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function (a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function (obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function (obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (true) {
    _.isFunction = function (obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function (obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function (obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function (obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function (value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function (method) {
    _[method] = function (string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function (match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function (object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function (obj) {
    each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function (text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, function (match) {
        return '\\' + escapes[match];
      });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function (data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function (obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function (obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function () {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function () {
      return this._wrapped;
    }

  });
}).call(this);

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

(function (_global) {
    "use strict";

    var shim = {};
    if (false) {
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
            shim.exports = {};
            define(function () {
                return shim.exports;
            });
        } else {
            // gl-matrix lives in a browser, define its namespaces in global
            shim.exports = typeof window !== 'undefined' ? window : _global;
        }
    } else {
        // gl-matrix lives in commonjs, define its namespaces in exports
        shim.exports = exports;
    }

    (function (exports) {
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        * Redistributions of source code must retain the above copyright notice, this
        list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation 
        and/or other materials provided with the distribution.
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 0.000001;
        }

        if (!GLMAT_ARRAY_TYPE) {
            var GLMAT_ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
        }

        if (!GLMAT_RANDOM) {
            var GLMAT_RANDOM = Math.random;
        }

        /**
         * @class Common utilities
         * @name glMatrix
         */
        var glMatrix = {};

        /**
         * Sets the type of array used when creating new vectors and matricies
         *
         * @param {Type} type Array type, such as Float32Array or Array
         */
        glMatrix.setMatrixArrayType = function (type) {
            GLMAT_ARRAY_TYPE = type;
        };

        if (typeof exports !== 'undefined') {
            exports.glMatrix = glMatrix;
        }

        var degree = Math.PI / 180;

        /**
        * Convert Degree To Radian
        *
        * @param {Number} Angle in Degrees
        */
        glMatrix.toRadian = function (a) {
            return a * degree;
        };
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class 2 Dimensional Vector
         * @name vec2
         */

        var vec2 = {};

        /**
         * Creates a new, empty vec2
         *
         * @returns {vec2} a new 2D vector
         */
        vec2.create = function () {
            var out = new GLMAT_ARRAY_TYPE(2);
            out[0] = 0;
            out[1] = 0;
            return out;
        };

        /**
         * Creates a new vec2 initialized with values from an existing vector
         *
         * @param {vec2} a vector to clone
         * @returns {vec2} a new 2D vector
         */
        vec2.clone = function (a) {
            var out = new GLMAT_ARRAY_TYPE(2);
            out[0] = a[0];
            out[1] = a[1];
            return out;
        };

        /**
         * Creates a new vec2 initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @returns {vec2} a new 2D vector
         */
        vec2.fromValues = function (x, y) {
            var out = new GLMAT_ARRAY_TYPE(2);
            out[0] = x;
            out[1] = y;
            return out;
        };

        /**
         * Copy the values from one vec2 to another
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the source vector
         * @returns {vec2} out
         */
        vec2.copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            return out;
        };

        /**
         * Set the components of a vec2 to the given values
         *
         * @param {vec2} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @returns {vec2} out
         */
        vec2.set = function (out, x, y) {
            out[0] = x;
            out[1] = y;
            return out;
        };

        /**
         * Adds two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */
        vec2.add = function (out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            return out;
        };

        /**
         * Subtracts vector b from vector a
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */
        vec2.subtract = function (out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            return out;
        };

        /**
         * Alias for {@link vec2.subtract}
         * @function
         */
        vec2.sub = vec2.subtract;

        /**
         * Multiplies two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */
        vec2.multiply = function (out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            return out;
        };

        /**
         * Alias for {@link vec2.multiply}
         * @function
         */
        vec2.mul = vec2.multiply;

        /**
         * Divides two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */
        vec2.divide = function (out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            return out;
        };

        /**
         * Alias for {@link vec2.divide}
         * @function
         */
        vec2.div = vec2.divide;

        /**
         * Returns the minimum of two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */
        vec2.min = function (out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            return out;
        };

        /**
         * Returns the maximum of two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */
        vec2.max = function (out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            return out;
        };

        /**
         * Scales a vec2 by a scalar number
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {vec2} out
         */
        vec2.scale = function (out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            return out;
        };

        /**
         * Adds two vec2's after scaling the second operand by a scalar value
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @param {Number} scale the amount to scale b by before adding
         * @returns {vec2} out
         */
        vec2.scaleAndAdd = function (out, a, b, scale) {
            out[0] = a[0] + b[0] * scale;
            out[1] = a[1] + b[1] * scale;
            return out;
        };

        /**
         * Calculates the euclidian distance between two vec2's
         *
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {Number} distance between a and b
         */
        vec2.distance = function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1];
            return Math.sqrt(x * x + y * y);
        };

        /**
         * Alias for {@link vec2.distance}
         * @function
         */
        vec2.dist = vec2.distance;

        /**
         * Calculates the squared euclidian distance between two vec2's
         *
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {Number} squared distance between a and b
         */
        vec2.squaredDistance = function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1];
            return x * x + y * y;
        };

        /**
         * Alias for {@link vec2.squaredDistance}
         * @function
         */
        vec2.sqrDist = vec2.squaredDistance;

        /**
         * Calculates the length of a vec2
         *
         * @param {vec2} a vector to calculate length of
         * @returns {Number} length of a
         */
        vec2.length = function (a) {
            var x = a[0],
                y = a[1];
            return Math.sqrt(x * x + y * y);
        };

        /**
         * Alias for {@link vec2.length}
         * @function
         */
        vec2.len = vec2.length;

        /**
         * Calculates the squared length of a vec2
         *
         * @param {vec2} a vector to calculate squared length of
         * @returns {Number} squared length of a
         */
        vec2.squaredLength = function (a) {
            var x = a[0],
                y = a[1];
            return x * x + y * y;
        };

        /**
         * Alias for {@link vec2.squaredLength}
         * @function
         */
        vec2.sqrLen = vec2.squaredLength;

        /**
         * Negates the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to negate
         * @returns {vec2} out
         */
        vec2.negate = function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            return out;
        };

        /**
         * Normalize a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to normalize
         * @returns {vec2} out
         */
        vec2.normalize = function (out, a) {
            var x = a[0],
                y = a[1];
            var len = x * x + y * y;
            if (len > 0) {
                //TODO: evaluate use of glm_invsqrt here?
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
            }
            return out;
        };

        /**
         * Calculates the dot product of two vec2's
         *
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {Number} dot product of a and b
         */
        vec2.dot = function (a, b) {
            return a[0] * b[0] + a[1] * b[1];
        };

        /**
         * Computes the cross product of two vec2's
         * Note that the cross product must by definition produce a 3D vector
         *
         * @param {vec3} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec3} out
         */
        vec2.cross = function (out, a, b) {
            var z = a[0] * b[1] - a[1] * b[0];
            out[0] = out[1] = 0;
            out[2] = z;
            return out;
        };

        /**
         * Performs a linear interpolation between two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @returns {vec2} out
         */
        vec2.lerp = function (out, a, b, t) {
            var ax = a[0],
                ay = a[1];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            return out;
        };

        /**
         * Generates a random vector with the given scale
         *
         * @param {vec2} out the receiving vector
         * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns {vec2} out
         */
        vec2.random = function (out, scale) {
            scale = scale || 1.0;
            var r = GLMAT_RANDOM() * 2.0 * Math.PI;
            out[0] = Math.cos(r) * scale;
            out[1] = Math.sin(r) * scale;
            return out;
        };

        /**
         * Transforms the vec2 with a mat2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat2} m matrix to transform with
         * @returns {vec2} out
         */
        vec2.transformMat2 = function (out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[2] * y;
            out[1] = m[1] * x + m[3] * y;
            return out;
        };

        /**
         * Transforms the vec2 with a mat2d
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat2d} m matrix to transform with
         * @returns {vec2} out
         */
        vec2.transformMat2d = function (out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[2] * y + m[4];
            out[1] = m[1] * x + m[3] * y + m[5];
            return out;
        };

        /**
         * Transforms the vec2 with a mat3
         * 3rd vector component is implicitly '1'
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat3} m matrix to transform with
         * @returns {vec2} out
         */
        vec2.transformMat3 = function (out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[3] * y + m[6];
            out[1] = m[1] * x + m[4] * y + m[7];
            return out;
        };

        /**
         * Transforms the vec2 with a mat4
         * 3rd vector component is implicitly '0'
         * 4th vector component is implicitly '1'
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat4} m matrix to transform with
         * @returns {vec2} out
         */
        vec2.transformMat4 = function (out, a, m) {
            var x = a[0],
                y = a[1];
            out[0] = m[0] * x + m[4] * y + m[12];
            out[1] = m[1] * x + m[5] * y + m[13];
            return out;
        };

        /**
         * Perform some operation over an array of vec2s.
         *
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @returns {Array} a
         * @function
         */
        vec2.forEach = function () {
            var vec = vec2.create();

            return function (a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 2;
                }

                if (!offset) {
                    offset = 0;
                }

                if (count) {
                    l = Math.min(count * stride + offset, a.length);
                } else {
                    l = a.length;
                }

                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i];vec[1] = a[i + 1];
                    fn(vec, vec, arg);
                    a[i] = vec[0];a[i + 1] = vec[1];
                }

                return a;
            };
        }();

        /**
         * Returns a string representation of a vector
         *
         * @param {vec2} vec vector to represent as a string
         * @returns {String} string representation of the vector
         */
        vec2.str = function (a) {
            return 'vec2(' + a[0] + ', ' + a[1] + ')';
        };

        if (typeof exports !== 'undefined') {
            exports.vec2 = vec2;
        }
        ;
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class 3 Dimensional Vector
         * @name vec3
         */

        var vec3 = {};

        /**
         * Creates a new, empty vec3
         *
         * @returns {vec3} a new 3D vector
         */
        vec3.create = function () {
            var out = new GLMAT_ARRAY_TYPE(3);
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            return out;
        };

        /**
         * Creates a new vec3 initialized with values from an existing vector
         *
         * @param {vec3} a vector to clone
         * @returns {vec3} a new 3D vector
         */
        vec3.clone = function (a) {
            var out = new GLMAT_ARRAY_TYPE(3);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            return out;
        };

        /**
         * Creates a new vec3 initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @returns {vec3} a new 3D vector
         */
        vec3.fromValues = function (x, y, z) {
            var out = new GLMAT_ARRAY_TYPE(3);
            out[0] = x;
            out[1] = y;
            out[2] = z;
            return out;
        };

        /**
         * Copy the values from one vec3 to another
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the source vector
         * @returns {vec3} out
         */
        vec3.copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            return out;
        };

        /**
         * Set the components of a vec3 to the given values
         *
         * @param {vec3} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @returns {vec3} out
         */
        vec3.set = function (out, x, y, z) {
            out[0] = x;
            out[1] = y;
            out[2] = z;
            return out;
        };

        /**
         * Adds two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */
        vec3.add = function (out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            out[2] = a[2] + b[2];
            return out;
        };

        /**
         * Subtracts vector b from vector a
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */
        vec3.subtract = function (out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            out[2] = a[2] - b[2];
            return out;
        };

        /**
         * Alias for {@link vec3.subtract}
         * @function
         */
        vec3.sub = vec3.subtract;

        /**
         * Multiplies two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */
        vec3.multiply = function (out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            out[2] = a[2] * b[2];
            return out;
        };

        /**
         * Alias for {@link vec3.multiply}
         * @function
         */
        vec3.mul = vec3.multiply;

        /**
         * Divides two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */
        vec3.divide = function (out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            out[2] = a[2] / b[2];
            return out;
        };

        /**
         * Alias for {@link vec3.divide}
         * @function
         */
        vec3.div = vec3.divide;

        /**
         * Returns the minimum of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */
        vec3.min = function (out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            out[2] = Math.min(a[2], b[2]);
            return out;
        };

        /**
         * Returns the maximum of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */
        vec3.max = function (out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            out[2] = Math.max(a[2], b[2]);
            return out;
        };

        /**
         * Scales a vec3 by a scalar number
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {vec3} out
         */
        vec3.scale = function (out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            out[2] = a[2] * b;
            return out;
        };

        /**
         * Adds two vec3's after scaling the second operand by a scalar value
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @param {Number} scale the amount to scale b by before adding
         * @returns {vec3} out
         */
        vec3.scaleAndAdd = function (out, a, b, scale) {
            out[0] = a[0] + b[0] * scale;
            out[1] = a[1] + b[1] * scale;
            out[2] = a[2] + b[2] * scale;
            return out;
        };

        /**
         * Calculates the euclidian distance between two vec3's
         *
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {Number} distance between a and b
         */
        vec3.distance = function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2];
            return Math.sqrt(x * x + y * y + z * z);
        };

        /**
         * Alias for {@link vec3.distance}
         * @function
         */
        vec3.dist = vec3.distance;

        /**
         * Calculates the squared euclidian distance between two vec3's
         *
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {Number} squared distance between a and b
         */
        vec3.squaredDistance = function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2];
            return x * x + y * y + z * z;
        };

        /**
         * Alias for {@link vec3.squaredDistance}
         * @function
         */
        vec3.sqrDist = vec3.squaredDistance;

        /**
         * Calculates the length of a vec3
         *
         * @param {vec3} a vector to calculate length of
         * @returns {Number} length of a
         */
        vec3.length = function (a) {
            var x = a[0],
                y = a[1],
                z = a[2];
            return Math.sqrt(x * x + y * y + z * z);
        };

        /**
         * Alias for {@link vec3.length}
         * @function
         */
        vec3.len = vec3.length;

        /**
         * Calculates the squared length of a vec3
         *
         * @param {vec3} a vector to calculate squared length of
         * @returns {Number} squared length of a
         */
        vec3.squaredLength = function (a) {
            var x = a[0],
                y = a[1],
                z = a[2];
            return x * x + y * y + z * z;
        };

        /**
         * Alias for {@link vec3.squaredLength}
         * @function
         */
        vec3.sqrLen = vec3.squaredLength;

        /**
         * Negates the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to negate
         * @returns {vec3} out
         */
        vec3.negate = function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            return out;
        };

        /**
         * Normalize a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to normalize
         * @returns {vec3} out
         */
        vec3.normalize = function (out, a) {
            var x = a[0],
                y = a[1],
                z = a[2];
            var len = x * x + y * y + z * z;
            if (len > 0) {
                //TODO: evaluate use of glm_invsqrt here?
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
                out[2] = a[2] * len;
            }
            return out;
        };

        /**
         * Calculates the dot product of two vec3's
         *
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {Number} dot product of a and b
         */
        vec3.dot = function (a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        };

        /**
         * Computes the cross product of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */
        vec3.cross = function (out, a, b) {
            var ax = a[0],
                ay = a[1],
                az = a[2],
                bx = b[0],
                by = b[1],
                bz = b[2];

            out[0] = ay * bz - az * by;
            out[1] = az * bx - ax * bz;
            out[2] = ax * by - ay * bx;
            return out;
        };

        /**
         * Performs a linear interpolation between two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @returns {vec3} out
         */
        vec3.lerp = function (out, a, b, t) {
            var ax = a[0],
                ay = a[1],
                az = a[2];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            out[2] = az + t * (b[2] - az);
            return out;
        };

        /**
         * Generates a random vector with the given scale
         *
         * @param {vec3} out the receiving vector
         * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns {vec3} out
         */
        vec3.random = function (out, scale) {
            scale = scale || 1.0;

            var r = GLMAT_RANDOM() * 2.0 * Math.PI;
            var z = GLMAT_RANDOM() * 2.0 - 1.0;
            var zScale = Math.sqrt(1.0 - z * z) * scale;

            out[0] = Math.cos(r) * zScale;
            out[1] = Math.sin(r) * zScale;
            out[2] = z * scale;
            return out;
        };

        /**
         * Transforms the vec3 with a mat4.
         * 4th vector component is implicitly '1'
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to transform
         * @param {mat4} m matrix to transform with
         * @returns {vec3} out
         */
        vec3.transformMat4 = function (out, a, m) {
            var x = a[0],
                y = a[1],
                z = a[2];
            out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
            out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
            out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
            return out;
        };

        /**
         * Transforms the vec3 with a mat3.
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to transform
         * @param {mat4} m the 3x3 matrix to transform with
         * @returns {vec3} out
         */
        vec3.transformMat3 = function (out, a, m) {
            var x = a[0],
                y = a[1],
                z = a[2];
            out[0] = x * m[0] + y * m[3] + z * m[6];
            out[1] = x * m[1] + y * m[4] + z * m[7];
            out[2] = x * m[2] + y * m[5] + z * m[8];
            return out;
        };

        /**
         * Transforms the vec3 with a quat
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to transform
         * @param {quat} q quaternion to transform with
         * @returns {vec3} out
         */
        vec3.transformQuat = function (out, a, q) {
            // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

            var x = a[0],
                y = a[1],
                z = a[2],
                qx = q[0],
                qy = q[1],
                qz = q[2],
                qw = q[3],


            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
                iy = qw * y + qz * x - qx * z,
                iz = qw * z + qx * y - qy * x,
                iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat
            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return out;
        };

        /*
        * Rotate a 3D vector around the x-axis
        * @param {vec3} out The receiving vec3
        * @param {vec3} a The vec3 point to rotate
        * @param {vec3} b The origin of the rotation
        * @param {Number} c The angle of rotation
        * @returns {vec3} out
        */
        vec3.rotateX = function (out, a, b, c) {
            var p = [],
                r = [];
            //Translate point to the origin
            p[0] = a[0] - b[0];
            p[1] = a[1] - b[1];
            p[2] = a[2] - b[2];

            //perform rotation
            r[0] = p[0];
            r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
            r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

            //translate to correct position
            out[0] = r[0] + b[0];
            out[1] = r[1] + b[1];
            out[2] = r[2] + b[2];

            return out;
        };

        /*
        * Rotate a 3D vector around the y-axis
        * @param {vec3} out The receiving vec3
        * @param {vec3} a The vec3 point to rotate
        * @param {vec3} b The origin of the rotation
        * @param {Number} c The angle of rotation
        * @returns {vec3} out
        */
        vec3.rotateY = function (out, a, b, c) {
            var p = [],
                r = [];
            //Translate point to the origin
            p[0] = a[0] - b[0];
            p[1] = a[1] - b[1];
            p[2] = a[2] - b[2];

            //perform rotation
            r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
            r[1] = p[1];
            r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

            //translate to correct position
            out[0] = r[0] + b[0];
            out[1] = r[1] + b[1];
            out[2] = r[2] + b[2];

            return out;
        };

        /*
        * Rotate a 3D vector around the z-axis
        * @param {vec3} out The receiving vec3
        * @param {vec3} a The vec3 point to rotate
        * @param {vec3} b The origin of the rotation
        * @param {Number} c The angle of rotation
        * @returns {vec3} out
        */
        vec3.rotateZ = function (out, a, b, c) {
            var p = [],
                r = [];
            //Translate point to the origin
            p[0] = a[0] - b[0];
            p[1] = a[1] - b[1];
            p[2] = a[2] - b[2];

            //perform rotation
            r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
            r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
            r[2] = p[2];

            //translate to correct position
            out[0] = r[0] + b[0];
            out[1] = r[1] + b[1];
            out[2] = r[2] + b[2];

            return out;
        };

        /**
         * Perform some operation over an array of vec3s.
         *
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @returns {Array} a
         * @function
         */
        vec3.forEach = function () {
            var vec = vec3.create();

            return function (a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 3;
                }

                if (!offset) {
                    offset = 0;
                }

                if (count) {
                    l = Math.min(count * stride + offset, a.length);
                } else {
                    l = a.length;
                }

                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
                    fn(vec, vec, arg);
                    a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
                }

                return a;
            };
        }();

        /**
         * Returns a string representation of a vector
         *
         * @param {vec3} vec vector to represent as a string
         * @returns {String} string representation of the vector
         */
        vec3.str = function (a) {
            return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
        };

        if (typeof exports !== 'undefined') {
            exports.vec3 = vec3;
        }
        ;
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class 4 Dimensional Vector
         * @name vec4
         */

        var vec4 = {};

        /**
         * Creates a new, empty vec4
         *
         * @returns {vec4} a new 4D vector
         */
        vec4.create = function () {
            var out = new GLMAT_ARRAY_TYPE(4);
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            return out;
        };

        /**
         * Creates a new vec4 initialized with values from an existing vector
         *
         * @param {vec4} a vector to clone
         * @returns {vec4} a new 4D vector
         */
        vec4.clone = function (a) {
            var out = new GLMAT_ARRAY_TYPE(4);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };

        /**
         * Creates a new vec4 initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @returns {vec4} a new 4D vector
         */
        vec4.fromValues = function (x, y, z, w) {
            var out = new GLMAT_ARRAY_TYPE(4);
            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = w;
            return out;
        };

        /**
         * Copy the values from one vec4 to another
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the source vector
         * @returns {vec4} out
         */
        vec4.copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };

        /**
         * Set the components of a vec4 to the given values
         *
         * @param {vec4} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @returns {vec4} out
         */
        vec4.set = function (out, x, y, z, w) {
            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = w;
            return out;
        };

        /**
         * Adds two vec4's
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {vec4} out
         */
        vec4.add = function (out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            out[2] = a[2] + b[2];
            out[3] = a[3] + b[3];
            return out;
        };

        /**
         * Subtracts vector b from vector a
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {vec4} out
         */
        vec4.subtract = function (out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            out[2] = a[2] - b[2];
            out[3] = a[3] - b[3];
            return out;
        };

        /**
         * Alias for {@link vec4.subtract}
         * @function
         */
        vec4.sub = vec4.subtract;

        /**
         * Multiplies two vec4's
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {vec4} out
         */
        vec4.multiply = function (out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            out[2] = a[2] * b[2];
            out[3] = a[3] * b[3];
            return out;
        };

        /**
         * Alias for {@link vec4.multiply}
         * @function
         */
        vec4.mul = vec4.multiply;

        /**
         * Divides two vec4's
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {vec4} out
         */
        vec4.divide = function (out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            out[2] = a[2] / b[2];
            out[3] = a[3] / b[3];
            return out;
        };

        /**
         * Alias for {@link vec4.divide}
         * @function
         */
        vec4.div = vec4.divide;

        /**
         * Returns the minimum of two vec4's
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {vec4} out
         */
        vec4.min = function (out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            out[2] = Math.min(a[2], b[2]);
            out[3] = Math.min(a[3], b[3]);
            return out;
        };

        /**
         * Returns the maximum of two vec4's
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {vec4} out
         */
        vec4.max = function (out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            out[2] = Math.max(a[2], b[2]);
            out[3] = Math.max(a[3], b[3]);
            return out;
        };

        /**
         * Scales a vec4 by a scalar number
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {vec4} out
         */
        vec4.scale = function (out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            out[2] = a[2] * b;
            out[3] = a[3] * b;
            return out;
        };

        /**
         * Adds two vec4's after scaling the second operand by a scalar value
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @param {Number} scale the amount to scale b by before adding
         * @returns {vec4} out
         */
        vec4.scaleAndAdd = function (out, a, b, scale) {
            out[0] = a[0] + b[0] * scale;
            out[1] = a[1] + b[1] * scale;
            out[2] = a[2] + b[2] * scale;
            out[3] = a[3] + b[3] * scale;
            return out;
        };

        /**
         * Calculates the euclidian distance between two vec4's
         *
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {Number} distance between a and b
         */
        vec4.distance = function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2],
                w = b[3] - a[3];
            return Math.sqrt(x * x + y * y + z * z + w * w);
        };

        /**
         * Alias for {@link vec4.distance}
         * @function
         */
        vec4.dist = vec4.distance;

        /**
         * Calculates the squared euclidian distance between two vec4's
         *
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {Number} squared distance between a and b
         */
        vec4.squaredDistance = function (a, b) {
            var x = b[0] - a[0],
                y = b[1] - a[1],
                z = b[2] - a[2],
                w = b[3] - a[3];
            return x * x + y * y + z * z + w * w;
        };

        /**
         * Alias for {@link vec4.squaredDistance}
         * @function
         */
        vec4.sqrDist = vec4.squaredDistance;

        /**
         * Calculates the length of a vec4
         *
         * @param {vec4} a vector to calculate length of
         * @returns {Number} length of a
         */
        vec4.length = function (a) {
            var x = a[0],
                y = a[1],
                z = a[2],
                w = a[3];
            return Math.sqrt(x * x + y * y + z * z + w * w);
        };

        /**
         * Alias for {@link vec4.length}
         * @function
         */
        vec4.len = vec4.length;

        /**
         * Calculates the squared length of a vec4
         *
         * @param {vec4} a vector to calculate squared length of
         * @returns {Number} squared length of a
         */
        vec4.squaredLength = function (a) {
            var x = a[0],
                y = a[1],
                z = a[2],
                w = a[3];
            return x * x + y * y + z * z + w * w;
        };

        /**
         * Alias for {@link vec4.squaredLength}
         * @function
         */
        vec4.sqrLen = vec4.squaredLength;

        /**
         * Negates the components of a vec4
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a vector to negate
         * @returns {vec4} out
         */
        vec4.negate = function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = -a[3];
            return out;
        };

        /**
         * Normalize a vec4
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a vector to normalize
         * @returns {vec4} out
         */
        vec4.normalize = function (out, a) {
            var x = a[0],
                y = a[1],
                z = a[2],
                w = a[3];
            var len = x * x + y * y + z * z + w * w;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
                out[2] = a[2] * len;
                out[3] = a[3] * len;
            }
            return out;
        };

        /**
         * Calculates the dot product of two vec4's
         *
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @returns {Number} dot product of a and b
         */
        vec4.dot = function (a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        };

        /**
         * Performs a linear interpolation between two vec4's
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the first operand
         * @param {vec4} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @returns {vec4} out
         */
        vec4.lerp = function (out, a, b, t) {
            var ax = a[0],
                ay = a[1],
                az = a[2],
                aw = a[3];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            out[2] = az + t * (b[2] - az);
            out[3] = aw + t * (b[3] - aw);
            return out;
        };

        /**
         * Generates a random vector with the given scale
         *
         * @param {vec4} out the receiving vector
         * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns {vec4} out
         */
        vec4.random = function (out, scale) {
            scale = scale || 1.0;

            //TODO: This is a pretty awful way of doing this. Find something better.
            out[0] = GLMAT_RANDOM();
            out[1] = GLMAT_RANDOM();
            out[2] = GLMAT_RANDOM();
            out[3] = GLMAT_RANDOM();
            vec4.normalize(out, out);
            vec4.scale(out, out, scale);
            return out;
        };

        /**
         * Transforms the vec4 with a mat4.
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the vector to transform
         * @param {mat4} m matrix to transform with
         * @returns {vec4} out
         */
        vec4.transformMat4 = function (out, a, m) {
            var x = a[0],
                y = a[1],
                z = a[2],
                w = a[3];
            out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
            out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
            out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
            out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
            return out;
        };

        /**
         * Transforms the vec4 with a quat
         *
         * @param {vec4} out the receiving vector
         * @param {vec4} a the vector to transform
         * @param {quat} q quaternion to transform with
         * @returns {vec4} out
         */
        vec4.transformQuat = function (out, a, q) {
            var x = a[0],
                y = a[1],
                z = a[2],
                qx = q[0],
                qy = q[1],
                qz = q[2],
                qw = q[3],


            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
                iy = qw * y + qz * x - qx * z,
                iz = qw * z + qx * y - qy * x,
                iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat
            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return out;
        };

        /**
         * Perform some operation over an array of vec4s.
         *
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @returns {Array} a
         * @function
         */
        vec4.forEach = function () {
            var vec = vec4.create();

            return function (a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 4;
                }

                if (!offset) {
                    offset = 0;
                }

                if (count) {
                    l = Math.min(count * stride + offset, a.length);
                } else {
                    l = a.length;
                }

                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];
                    fn(vec, vec, arg);
                    a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];
                }

                return a;
            };
        }();

        /**
         * Returns a string representation of a vector
         *
         * @param {vec4} vec vector to represent as a string
         * @returns {String} string representation of the vector
         */
        vec4.str = function (a) {
            return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
        };

        if (typeof exports !== 'undefined') {
            exports.vec4 = vec4;
        }
        ;
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class 2x2 Matrix
         * @name mat2
         */

        var mat2 = {};

        /**
         * Creates a new identity mat2
         *
         * @returns {mat2} a new 2x2 matrix
         */
        mat2.create = function () {
            var out = new GLMAT_ARRAY_TYPE(4);
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        };

        /**
         * Creates a new mat2 initialized with values from an existing matrix
         *
         * @param {mat2} a matrix to clone
         * @returns {mat2} a new 2x2 matrix
         */
        mat2.clone = function (a) {
            var out = new GLMAT_ARRAY_TYPE(4);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };

        /**
         * Copy the values from one mat2 to another
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */
        mat2.copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };

        /**
         * Set a mat2 to the identity matrix
         *
         * @param {mat2} out the receiving matrix
         * @returns {mat2} out
         */
        mat2.identity = function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        };

        /**
         * Transpose the values of a mat2
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */
        mat2.transpose = function (out, a) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            if (out === a) {
                var a1 = a[1];
                out[1] = a[2];
                out[2] = a1;
            } else {
                out[0] = a[0];
                out[1] = a[2];
                out[2] = a[1];
                out[3] = a[3];
            }

            return out;
        };

        /**
         * Inverts a mat2
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */
        mat2.invert = function (out, a) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],


            // Calculate the determinant
            det = a0 * a3 - a2 * a1;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = a3 * det;
            out[1] = -a1 * det;
            out[2] = -a2 * det;
            out[3] = a0 * det;

            return out;
        };

        /**
         * Calculates the adjugate of a mat2
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */
        mat2.adjoint = function (out, a) {
            // Caching this value is nessecary if out == a
            var a0 = a[0];
            out[0] = a[3];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = a0;

            return out;
        };

        /**
         * Calculates the determinant of a mat2
         *
         * @param {mat2} a the source matrix
         * @returns {Number} determinant of a
         */
        mat2.determinant = function (a) {
            return a[0] * a[3] - a[2] * a[1];
        };

        /**
         * Multiplies two mat2's
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the first operand
         * @param {mat2} b the second operand
         * @returns {mat2} out
         */
        mat2.multiply = function (out, a, b) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3];
            var b0 = b[0],
                b1 = b[1],
                b2 = b[2],
                b3 = b[3];
            out[0] = a0 * b0 + a2 * b1;
            out[1] = a1 * b0 + a3 * b1;
            out[2] = a0 * b2 + a2 * b3;
            out[3] = a1 * b2 + a3 * b3;
            return out;
        };

        /**
         * Alias for {@link mat2.multiply}
         * @function
         */
        mat2.mul = mat2.multiply;

        /**
         * Rotates a mat2 by the given angle
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat2} out
         */
        mat2.rotate = function (out, a, rad) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],
                s = Math.sin(rad),
                c = Math.cos(rad);
            out[0] = a0 * c + a2 * s;
            out[1] = a1 * c + a3 * s;
            out[2] = a0 * -s + a2 * c;
            out[3] = a1 * -s + a3 * c;
            return out;
        };

        /**
         * Scales the mat2 by the dimensions in the given vec2
         *
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the matrix to rotate
         * @param {vec2} v the vec2 to scale the matrix by
         * @returns {mat2} out
         **/
        mat2.scale = function (out, a, v) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],
                v0 = v[0],
                v1 = v[1];
            out[0] = a0 * v0;
            out[1] = a1 * v0;
            out[2] = a2 * v1;
            out[3] = a3 * v1;
            return out;
        };

        /**
         * Returns a string representation of a mat2
         *
         * @param {mat2} mat matrix to represent as a string
         * @returns {String} string representation of the matrix
         */
        mat2.str = function (a) {
            return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
        };

        /**
         * Returns Frobenius norm of a mat2
         *
         * @param {mat2} a the matrix to calculate Frobenius norm of
         * @returns {Number} Frobenius norm
         */
        mat2.frob = function (a) {
            return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
        };

        /**
         * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
         * @param {mat2} L the lower triangular matrix 
         * @param {mat2} D the diagonal matrix 
         * @param {mat2} U the upper triangular matrix 
         * @param {mat2} a the input matrix to factorize
         */

        mat2.LDU = function (L, D, U, a) {
            L[2] = a[2] / a[0];
            U[0] = a[0];
            U[1] = a[1];
            U[3] = a[3] - L[2] * U[1];
            return [L, D, U];
        };

        if (typeof exports !== 'undefined') {
            exports.mat2 = mat2;
        }
        ;
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class 2x3 Matrix
         * @name mat2d
         * 
         * @description 
         * A mat2d contains six elements defined as:
         * <pre>
         * [a, c, tx,
         *  b, d, ty]
         * </pre>
         * This is a short form for the 3x3 matrix:
         * <pre>
         * [a, c, tx,
         *  b, d, ty,
         *  0, 0, 1]
         * </pre>
         * The last row is ignored so the array is shorter and operations are faster.
         */

        var mat2d = {};

        /**
         * Creates a new identity mat2d
         *
         * @returns {mat2d} a new 2x3 matrix
         */
        mat2d.create = function () {
            var out = new GLMAT_ARRAY_TYPE(6);
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            out[4] = 0;
            out[5] = 0;
            return out;
        };

        /**
         * Creates a new mat2d initialized with values from an existing matrix
         *
         * @param {mat2d} a matrix to clone
         * @returns {mat2d} a new 2x3 matrix
         */
        mat2d.clone = function (a) {
            var out = new GLMAT_ARRAY_TYPE(6);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            return out;
        };

        /**
         * Copy the values from one mat2d to another
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the source matrix
         * @returns {mat2d} out
         */
        mat2d.copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            return out;
        };

        /**
         * Set a mat2d to the identity matrix
         *
         * @param {mat2d} out the receiving matrix
         * @returns {mat2d} out
         */
        mat2d.identity = function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            out[4] = 0;
            out[5] = 0;
            return out;
        };

        /**
         * Inverts a mat2d
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the source matrix
         * @returns {mat2d} out
         */
        mat2d.invert = function (out, a) {
            var aa = a[0],
                ab = a[1],
                ac = a[2],
                ad = a[3],
                atx = a[4],
                aty = a[5];

            var det = aa * ad - ab * ac;
            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = ad * det;
            out[1] = -ab * det;
            out[2] = -ac * det;
            out[3] = aa * det;
            out[4] = (ac * aty - ad * atx) * det;
            out[5] = (ab * atx - aa * aty) * det;
            return out;
        };

        /**
         * Calculates the determinant of a mat2d
         *
         * @param {mat2d} a the source matrix
         * @returns {Number} determinant of a
         */
        mat2d.determinant = function (a) {
            return a[0] * a[3] - a[1] * a[2];
        };

        /**
         * Multiplies two mat2d's
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the first operand
         * @param {mat2d} b the second operand
         * @returns {mat2d} out
         */
        mat2d.multiply = function (out, a, b) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],
                a4 = a[4],
                a5 = a[5],
                b0 = b[0],
                b1 = b[1],
                b2 = b[2],
                b3 = b[3],
                b4 = b[4],
                b5 = b[5];
            out[0] = a0 * b0 + a2 * b1;
            out[1] = a1 * b0 + a3 * b1;
            out[2] = a0 * b2 + a2 * b3;
            out[3] = a1 * b2 + a3 * b3;
            out[4] = a0 * b4 + a2 * b5 + a4;
            out[5] = a1 * b4 + a3 * b5 + a5;
            return out;
        };

        /**
         * Alias for {@link mat2d.multiply}
         * @function
         */
        mat2d.mul = mat2d.multiply;

        /**
         * Rotates a mat2d by the given angle
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat2d} out
         */
        mat2d.rotate = function (out, a, rad) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],
                a4 = a[4],
                a5 = a[5],
                s = Math.sin(rad),
                c = Math.cos(rad);
            out[0] = a0 * c + a2 * s;
            out[1] = a1 * c + a3 * s;
            out[2] = a0 * -s + a2 * c;
            out[3] = a1 * -s + a3 * c;
            out[4] = a4;
            out[5] = a5;
            return out;
        };

        /**
         * Scales the mat2d by the dimensions in the given vec2
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the matrix to translate
         * @param {vec2} v the vec2 to scale the matrix by
         * @returns {mat2d} out
         **/
        mat2d.scale = function (out, a, v) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],
                a4 = a[4],
                a5 = a[5],
                v0 = v[0],
                v1 = v[1];
            out[0] = a0 * v0;
            out[1] = a1 * v0;
            out[2] = a2 * v1;
            out[3] = a3 * v1;
            out[4] = a4;
            out[5] = a5;
            return out;
        };

        /**
         * Translates the mat2d by the dimensions in the given vec2
         *
         * @param {mat2d} out the receiving matrix
         * @param {mat2d} a the matrix to translate
         * @param {vec2} v the vec2 to translate the matrix by
         * @returns {mat2d} out
         **/
        mat2d.translate = function (out, a, v) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],
                a4 = a[4],
                a5 = a[5],
                v0 = v[0],
                v1 = v[1];
            out[0] = a0;
            out[1] = a1;
            out[2] = a2;
            out[3] = a3;
            out[4] = a0 * v0 + a2 * v1 + a4;
            out[5] = a1 * v0 + a3 * v1 + a5;
            return out;
        };

        /**
         * Returns a string representation of a mat2d
         *
         * @param {mat2d} a matrix to represent as a string
         * @returns {String} string representation of the matrix
         */
        mat2d.str = function (a) {
            return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
        };

        /**
         * Returns Frobenius norm of a mat2d
         *
         * @param {mat2d} a the matrix to calculate Frobenius norm of
         * @returns {Number} Frobenius norm
         */
        mat2d.frob = function (a) {
            return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
        };

        if (typeof exports !== 'undefined') {
            exports.mat2d = mat2d;
        }
        ;
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class 3x3 Matrix
         * @name mat3
         */

        var mat3 = {};

        /**
         * Creates a new identity mat3
         *
         * @returns {mat3} a new 3x3 matrix
         */
        mat3.create = function () {
            var out = new GLMAT_ARRAY_TYPE(9);
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 1;
            out[5] = 0;
            out[6] = 0;
            out[7] = 0;
            out[8] = 1;
            return out;
        };

        /**
         * Copies the upper-left 3x3 values into the given mat3.
         *
         * @param {mat3} out the receiving 3x3 matrix
         * @param {mat4} a   the source 4x4 matrix
         * @returns {mat3} out
         */
        mat3.fromMat4 = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[4];
            out[4] = a[5];
            out[5] = a[6];
            out[6] = a[8];
            out[7] = a[9];
            out[8] = a[10];
            return out;
        };

        /**
         * Creates a new mat3 initialized with values from an existing matrix
         *
         * @param {mat3} a matrix to clone
         * @returns {mat3} a new 3x3 matrix
         */
        mat3.clone = function (a) {
            var out = new GLMAT_ARRAY_TYPE(9);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        };

        /**
         * Copy the values from one mat3 to another
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the source matrix
         * @returns {mat3} out
         */
        mat3.copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        };

        /**
         * Set a mat3 to the identity matrix
         *
         * @param {mat3} out the receiving matrix
         * @returns {mat3} out
         */
        mat3.identity = function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 1;
            out[5] = 0;
            out[6] = 0;
            out[7] = 0;
            out[8] = 1;
            return out;
        };

        /**
         * Transpose the values of a mat3
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the source matrix
         * @returns {mat3} out
         */
        mat3.transpose = function (out, a) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            if (out === a) {
                var a01 = a[1],
                    a02 = a[2],
                    a12 = a[5];
                out[1] = a[3];
                out[2] = a[6];
                out[3] = a01;
                out[5] = a[7];
                out[6] = a02;
                out[7] = a12;
            } else {
                out[0] = a[0];
                out[1] = a[3];
                out[2] = a[6];
                out[3] = a[1];
                out[4] = a[4];
                out[5] = a[7];
                out[6] = a[2];
                out[7] = a[5];
                out[8] = a[8];
            }

            return out;
        };

        /**
         * Inverts a mat3
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the source matrix
         * @returns {mat3} out
         */
        mat3.invert = function (out, a) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a10 = a[3],
                a11 = a[4],
                a12 = a[5],
                a20 = a[6],
                a21 = a[7],
                a22 = a[8],
                b01 = a22 * a11 - a12 * a21,
                b11 = -a22 * a10 + a12 * a20,
                b21 = a21 * a10 - a11 * a20,


            // Calculate the determinant
            det = a00 * b01 + a01 * b11 + a02 * b21;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = b01 * det;
            out[1] = (-a22 * a01 + a02 * a21) * det;
            out[2] = (a12 * a01 - a02 * a11) * det;
            out[3] = b11 * det;
            out[4] = (a22 * a00 - a02 * a20) * det;
            out[5] = (-a12 * a00 + a02 * a10) * det;
            out[6] = b21 * det;
            out[7] = (-a21 * a00 + a01 * a20) * det;
            out[8] = (a11 * a00 - a01 * a10) * det;
            return out;
        };

        /**
         * Calculates the adjugate of a mat3
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the source matrix
         * @returns {mat3} out
         */
        mat3.adjoint = function (out, a) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a10 = a[3],
                a11 = a[4],
                a12 = a[5],
                a20 = a[6],
                a21 = a[7],
                a22 = a[8];

            out[0] = a11 * a22 - a12 * a21;
            out[1] = a02 * a21 - a01 * a22;
            out[2] = a01 * a12 - a02 * a11;
            out[3] = a12 * a20 - a10 * a22;
            out[4] = a00 * a22 - a02 * a20;
            out[5] = a02 * a10 - a00 * a12;
            out[6] = a10 * a21 - a11 * a20;
            out[7] = a01 * a20 - a00 * a21;
            out[8] = a00 * a11 - a01 * a10;
            return out;
        };

        /**
         * Calculates the determinant of a mat3
         *
         * @param {mat3} a the source matrix
         * @returns {Number} determinant of a
         */
        mat3.determinant = function (a) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a10 = a[3],
                a11 = a[4],
                a12 = a[5],
                a20 = a[6],
                a21 = a[7],
                a22 = a[8];

            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        };

        /**
         * Multiplies two mat3's
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the first operand
         * @param {mat3} b the second operand
         * @returns {mat3} out
         */
        mat3.multiply = function (out, a, b) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a10 = a[3],
                a11 = a[4],
                a12 = a[5],
                a20 = a[6],
                a21 = a[7],
                a22 = a[8],
                b00 = b[0],
                b01 = b[1],
                b02 = b[2],
                b10 = b[3],
                b11 = b[4],
                b12 = b[5],
                b20 = b[6],
                b21 = b[7],
                b22 = b[8];

            out[0] = b00 * a00 + b01 * a10 + b02 * a20;
            out[1] = b00 * a01 + b01 * a11 + b02 * a21;
            out[2] = b00 * a02 + b01 * a12 + b02 * a22;

            out[3] = b10 * a00 + b11 * a10 + b12 * a20;
            out[4] = b10 * a01 + b11 * a11 + b12 * a21;
            out[5] = b10 * a02 + b11 * a12 + b12 * a22;

            out[6] = b20 * a00 + b21 * a10 + b22 * a20;
            out[7] = b20 * a01 + b21 * a11 + b22 * a21;
            out[8] = b20 * a02 + b21 * a12 + b22 * a22;
            return out;
        };

        /**
         * Alias for {@link mat3.multiply}
         * @function
         */
        mat3.mul = mat3.multiply;

        /**
         * Translate a mat3 by the given vector
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the matrix to translate
         * @param {vec2} v vector to translate by
         * @returns {mat3} out
         */
        mat3.translate = function (out, a, v) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a10 = a[3],
                a11 = a[4],
                a12 = a[5],
                a20 = a[6],
                a21 = a[7],
                a22 = a[8],
                x = v[0],
                y = v[1];

            out[0] = a00;
            out[1] = a01;
            out[2] = a02;

            out[3] = a10;
            out[4] = a11;
            out[5] = a12;

            out[6] = x * a00 + y * a10 + a20;
            out[7] = x * a01 + y * a11 + a21;
            out[8] = x * a02 + y * a12 + a22;
            return out;
        };

        /**
         * Rotates a mat3 by the given angle
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat3} out
         */
        mat3.rotate = function (out, a, rad) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a10 = a[3],
                a11 = a[4],
                a12 = a[5],
                a20 = a[6],
                a21 = a[7],
                a22 = a[8],
                s = Math.sin(rad),
                c = Math.cos(rad);

            out[0] = c * a00 + s * a10;
            out[1] = c * a01 + s * a11;
            out[2] = c * a02 + s * a12;

            out[3] = c * a10 - s * a00;
            out[4] = c * a11 - s * a01;
            out[5] = c * a12 - s * a02;

            out[6] = a20;
            out[7] = a21;
            out[8] = a22;
            return out;
        };

        /**
         * Scales the mat3 by the dimensions in the given vec2
         *
         * @param {mat3} out the receiving matrix
         * @param {mat3} a the matrix to rotate
         * @param {vec2} v the vec2 to scale the matrix by
         * @returns {mat3} out
         **/
        mat3.scale = function (out, a, v) {
            var x = v[0],
                y = v[1];

            out[0] = x * a[0];
            out[1] = x * a[1];
            out[2] = x * a[2];

            out[3] = y * a[3];
            out[4] = y * a[4];
            out[5] = y * a[5];

            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        };

        /**
         * Copies the values from a mat2d into a mat3
         *
         * @param {mat3} out the receiving matrix
         * @param {mat2d} a the matrix to copy
         * @returns {mat3} out
         **/
        mat3.fromMat2d = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = 0;

            out[3] = a[2];
            out[4] = a[3];
            out[5] = 0;

            out[6] = a[4];
            out[7] = a[5];
            out[8] = 1;
            return out;
        };

        /**
        * Calculates a 3x3 matrix from the given quaternion
        *
        * @param {mat3} out mat3 receiving operation result
        * @param {quat} q Quaternion to create matrix from
        *
        * @returns {mat3} out
        */
        mat3.fromQuat = function (out, q) {
            var x = q[0],
                y = q[1],
                z = q[2],
                w = q[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,
                xx = x * x2,
                yx = y * x2,
                yy = y * y2,
                zx = z * x2,
                zy = z * y2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - yy - zz;
            out[3] = yx - wz;
            out[6] = zx + wy;

            out[1] = yx + wz;
            out[4] = 1 - xx - zz;
            out[7] = zy - wx;

            out[2] = zx - wy;
            out[5] = zy + wx;
            out[8] = 1 - xx - yy;

            return out;
        };

        /**
        * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
        *
        * @param {mat3} out mat3 receiving operation result
        * @param {mat4} a Mat4 to derive the normal matrix from
        *
        * @returns {mat3} out
        */
        mat3.normalFromMat4 = function (out, a) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11],
                a30 = a[12],
                a31 = a[13],
                a32 = a[14],
                a33 = a[15],
                b00 = a00 * a11 - a01 * a10,
                b01 = a00 * a12 - a02 * a10,
                b02 = a00 * a13 - a03 * a10,
                b03 = a01 * a12 - a02 * a11,
                b04 = a01 * a13 - a03 * a11,
                b05 = a02 * a13 - a03 * a12,
                b06 = a20 * a31 - a21 * a30,
                b07 = a20 * a32 - a22 * a30,
                b08 = a20 * a33 - a23 * a30,
                b09 = a21 * a32 - a22 * a31,
                b10 = a21 * a33 - a23 * a31,
                b11 = a22 * a33 - a23 * a32,


            // Calculate the determinant
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

            out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

            out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

            return out;
        };

        /**
         * Returns a string representation of a mat3
         *
         * @param {mat3} mat matrix to represent as a string
         * @returns {String} string representation of the matrix
         */
        mat3.str = function (a) {
            return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
        };

        /**
         * Returns Frobenius norm of a mat3
         *
         * @param {mat3} a the matrix to calculate Frobenius norm of
         * @returns {Number} Frobenius norm
         */
        mat3.frob = function (a) {
            return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
        };

        if (typeof exports !== 'undefined') {
            exports.mat3 = mat3;
        }
        ;
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class 4x4 Matrix
         * @name mat4
         */

        var mat4 = {};

        /**
         * Creates a new identity mat4
         *
         * @returns {mat4} a new 4x4 matrix
         */
        mat4.create = function () {
            var out = new GLMAT_ARRAY_TYPE(16);
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;
            return out;
        };

        /**
         * Creates a new mat4 initialized with values from an existing matrix
         *
         * @param {mat4} a matrix to clone
         * @returns {mat4} a new 4x4 matrix
         */
        mat4.clone = function (a) {
            var out = new GLMAT_ARRAY_TYPE(16);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        };

        /**
         * Copy the values from one mat4 to another
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the source matrix
         * @returns {mat4} out
         */
        mat4.copy = function (out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        };

        /**
         * Set a mat4 to the identity matrix
         *
         * @param {mat4} out the receiving matrix
         * @returns {mat4} out
         */
        mat4.identity = function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;
            return out;
        };

        /**
         * Transpose the values of a mat4
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the source matrix
         * @returns {mat4} out
         */
        mat4.transpose = function (out, a) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            if (out === a) {
                var a01 = a[1],
                    a02 = a[2],
                    a03 = a[3],
                    a12 = a[6],
                    a13 = a[7],
                    a23 = a[11];

                out[1] = a[4];
                out[2] = a[8];
                out[3] = a[12];
                out[4] = a01;
                out[6] = a[9];
                out[7] = a[13];
                out[8] = a02;
                out[9] = a12;
                out[11] = a[14];
                out[12] = a03;
                out[13] = a13;
                out[14] = a23;
            } else {
                out[0] = a[0];
                out[1] = a[4];
                out[2] = a[8];
                out[3] = a[12];
                out[4] = a[1];
                out[5] = a[5];
                out[6] = a[9];
                out[7] = a[13];
                out[8] = a[2];
                out[9] = a[6];
                out[10] = a[10];
                out[11] = a[14];
                out[12] = a[3];
                out[13] = a[7];
                out[14] = a[11];
                out[15] = a[15];
            }

            return out;
        };

        /**
         * Inverts a mat4
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the source matrix
         * @returns {mat4} out
         */
        mat4.invert = function (out, a) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11],
                a30 = a[12],
                a31 = a[13],
                a32 = a[14],
                a33 = a[15],
                b00 = a00 * a11 - a01 * a10,
                b01 = a00 * a12 - a02 * a10,
                b02 = a00 * a13 - a03 * a10,
                b03 = a01 * a12 - a02 * a11,
                b04 = a01 * a13 - a03 * a11,
                b05 = a02 * a13 - a03 * a12,
                b06 = a20 * a31 - a21 * a30,
                b07 = a20 * a32 - a22 * a30,
                b08 = a20 * a33 - a23 * a30,
                b09 = a21 * a32 - a22 * a31,
                b10 = a21 * a33 - a23 * a31,
                b11 = a22 * a33 - a23 * a32,


            // Calculate the determinant
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

            return out;
        };

        /**
         * Calculates the adjugate of a mat4
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the source matrix
         * @returns {mat4} out
         */
        mat4.adjoint = function (out, a) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11],
                a30 = a[12],
                a31 = a[13],
                a32 = a[14],
                a33 = a[15];

            out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
            out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
            out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
            out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
            out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
            out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
            out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
            out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
            out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
            out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
            out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
            out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
            out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
            out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
            out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
            out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
            return out;
        };

        /**
         * Calculates the determinant of a mat4
         *
         * @param {mat4} a the source matrix
         * @returns {Number} determinant of a
         */
        mat4.determinant = function (a) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11],
                a30 = a[12],
                a31 = a[13],
                a32 = a[14],
                a33 = a[15],
                b00 = a00 * a11 - a01 * a10,
                b01 = a00 * a12 - a02 * a10,
                b02 = a00 * a13 - a03 * a10,
                b03 = a01 * a12 - a02 * a11,
                b04 = a01 * a13 - a03 * a11,
                b05 = a02 * a13 - a03 * a12,
                b06 = a20 * a31 - a21 * a30,
                b07 = a20 * a32 - a22 * a30,
                b08 = a20 * a33 - a23 * a30,
                b09 = a21 * a32 - a22 * a31,
                b10 = a21 * a33 - a23 * a31,
                b11 = a22 * a33 - a23 * a32;

            // Calculate the determinant
            return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        };

        /**
         * Multiplies two mat4's
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the first operand
         * @param {mat4} b the second operand
         * @returns {mat4} out
         */
        mat4.multiply = function (out, a, b) {
            var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11],
                a30 = a[12],
                a31 = a[13],
                a32 = a[14],
                a33 = a[15];

            // Cache only the current line of the second matrix
            var b0 = b[0],
                b1 = b[1],
                b2 = b[2],
                b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        };

        /**
         * Alias for {@link mat4.multiply}
         * @function
         */
        mat4.mul = mat4.multiply;

        /**
         * Translate a mat4 by the given vector
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the matrix to translate
         * @param {vec3} v vector to translate by
         * @returns {mat4} out
         */
        mat4.translate = function (out, a, v) {
            var x = v[0],
                y = v[1],
                z = v[2],
                a00,
                a01,
                a02,
                a03,
                a10,
                a11,
                a12,
                a13,
                a20,
                a21,
                a22,
                a23;

            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
                a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
                a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

                out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
                out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
                out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

                out[12] = a00 * x + a10 * y + a20 * z + a[12];
                out[13] = a01 * x + a11 * y + a21 * z + a[13];
                out[14] = a02 * x + a12 * y + a22 * z + a[14];
                out[15] = a03 * x + a13 * y + a23 * z + a[15];
            }

            return out;
        };

        /**
         * Scales the mat4 by the dimensions in the given vec3
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the matrix to scale
         * @param {vec3} v the vec3 to scale the matrix by
         * @returns {mat4} out
         **/
        mat4.scale = function (out, a, v) {
            var x = v[0],
                y = v[1],
                z = v[2];

            out[0] = a[0] * x;
            out[1] = a[1] * x;
            out[2] = a[2] * x;
            out[3] = a[3] * x;
            out[4] = a[4] * y;
            out[5] = a[5] * y;
            out[6] = a[6] * y;
            out[7] = a[7] * y;
            out[8] = a[8] * z;
            out[9] = a[9] * z;
            out[10] = a[10] * z;
            out[11] = a[11] * z;
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        };

        /**
         * Rotates a mat4 by the given angle
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @param {vec3} axis the axis to rotate around
         * @returns {mat4} out
         */
        mat4.rotate = function (out, a, rad, axis) {
            var x = axis[0],
                y = axis[1],
                z = axis[2],
                len = Math.sqrt(x * x + y * y + z * z),
                s,
                c,
                t,
                a00,
                a01,
                a02,
                a03,
                a10,
                a11,
                a12,
                a13,
                a20,
                a21,
                a22,
                a23,
                b00,
                b01,
                b02,
                b10,
                b11,
                b12,
                b20,
                b21,
                b22;

            if (Math.abs(len) < GLMAT_EPSILON) {
                return null;
            }

            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;

            s = Math.sin(rad);
            c = Math.cos(rad);
            t = 1 - c;

            a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
            a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
            a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

            // Construct the elements of the rotation matrix
            b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;
            b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;
            b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;

            // Perform rotation-specific matrix multiplication
            out[0] = a00 * b00 + a10 * b01 + a20 * b02;
            out[1] = a01 * b00 + a11 * b01 + a21 * b02;
            out[2] = a02 * b00 + a12 * b01 + a22 * b02;
            out[3] = a03 * b00 + a13 * b01 + a23 * b02;
            out[4] = a00 * b10 + a10 * b11 + a20 * b12;
            out[5] = a01 * b10 + a11 * b11 + a21 * b12;
            out[6] = a02 * b10 + a12 * b11 + a22 * b12;
            out[7] = a03 * b10 + a13 * b11 + a23 * b12;
            out[8] = a00 * b20 + a10 * b21 + a20 * b22;
            out[9] = a01 * b20 + a11 * b21 + a21 * b22;
            out[10] = a02 * b20 + a12 * b21 + a22 * b22;
            out[11] = a03 * b20 + a13 * b21 + a23 * b22;

            if (a !== out) {
                // If the source and destination differ, copy the unchanged last row
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }
            return out;
        };

        /**
         * Rotates a matrix by the given angle around the X axis
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat4} out
         */
        mat4.rotateX = function (out, a, rad) {
            var s = Math.sin(rad),
                c = Math.cos(rad),
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11];

            if (a !== out) {
                // If the source and destination differ, copy the unchanged rows
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            // Perform axis-specific matrix multiplication
            out[4] = a10 * c + a20 * s;
            out[5] = a11 * c + a21 * s;
            out[6] = a12 * c + a22 * s;
            out[7] = a13 * c + a23 * s;
            out[8] = a20 * c - a10 * s;
            out[9] = a21 * c - a11 * s;
            out[10] = a22 * c - a12 * s;
            out[11] = a23 * c - a13 * s;
            return out;
        };

        /**
         * Rotates a matrix by the given angle around the Y axis
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat4} out
         */
        mat4.rotateY = function (out, a, rad) {
            var s = Math.sin(rad),
                c = Math.cos(rad),
                a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11];

            if (a !== out) {
                // If the source and destination differ, copy the unchanged rows
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            // Perform axis-specific matrix multiplication
            out[0] = a00 * c - a20 * s;
            out[1] = a01 * c - a21 * s;
            out[2] = a02 * c - a22 * s;
            out[3] = a03 * c - a23 * s;
            out[8] = a00 * s + a20 * c;
            out[9] = a01 * s + a21 * c;
            out[10] = a02 * s + a22 * c;
            out[11] = a03 * s + a23 * c;
            return out;
        };

        /**
         * Rotates a matrix by the given angle around the Z axis
         *
         * @param {mat4} out the receiving matrix
         * @param {mat4} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat4} out
         */
        mat4.rotateZ = function (out, a, rad) {
            var s = Math.sin(rad),
                c = Math.cos(rad),
                a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7];

            if (a !== out) {
                // If the source and destination differ, copy the unchanged last row
                out[8] = a[8];
                out[9] = a[9];
                out[10] = a[10];
                out[11] = a[11];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }

            // Perform axis-specific matrix multiplication
            out[0] = a00 * c + a10 * s;
            out[1] = a01 * c + a11 * s;
            out[2] = a02 * c + a12 * s;
            out[3] = a03 * c + a13 * s;
            out[4] = a10 * c - a00 * s;
            out[5] = a11 * c - a01 * s;
            out[6] = a12 * c - a02 * s;
            out[7] = a13 * c - a03 * s;
            return out;
        };

        /**
         * Creates a matrix from a quaternion rotation and vector translation
         * This is equivalent to (but much faster than):
         *
         *     mat4.identity(dest);
         *     mat4.translate(dest, vec);
         *     var quatMat = mat4.create();
         *     quat4.toMat4(quat, quatMat);
         *     mat4.multiply(dest, quatMat);
         *
         * @param {mat4} out mat4 receiving operation result
         * @param {quat4} q Rotation quaternion
         * @param {vec3} v Translation vector
         * @returns {mat4} out
         */
        mat4.fromRotationTranslation = function (out, q, v) {
            // Quaternion math
            var x = q[0],
                y = q[1],
                z = q[2],
                w = q[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,
                xx = x * x2,
                xy = x * y2,
                xz = x * z2,
                yy = y * y2,
                yz = y * z2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;
            out[3] = 0;
            out[4] = xy - wz;
            out[5] = 1 - (xx + zz);
            out[6] = yz + wx;
            out[7] = 0;
            out[8] = xz + wy;
            out[9] = yz - wx;
            out[10] = 1 - (xx + yy);
            out[11] = 0;
            out[12] = v[0];
            out[13] = v[1];
            out[14] = v[2];
            out[15] = 1;

            return out;
        };

        mat4.fromQuat = function (out, q) {
            var x = q[0],
                y = q[1],
                z = q[2],
                w = q[3],
                x2 = x + x,
                y2 = y + y,
                z2 = z + z,
                xx = x * x2,
                yx = y * x2,
                yy = y * y2,
                zx = z * x2,
                zy = z * y2,
                zz = z * z2,
                wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            out[0] = 1 - yy - zz;
            out[1] = yx + wz;
            out[2] = zx - wy;
            out[3] = 0;

            out[4] = yx - wz;
            out[5] = 1 - xx - zz;
            out[6] = zy + wx;
            out[7] = 0;

            out[8] = zx + wy;
            out[9] = zy - wx;
            out[10] = 1 - xx - yy;
            out[11] = 0;

            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;

            return out;
        };

        /**
         * Generates a frustum matrix with the given bounds
         *
         * @param {mat4} out mat4 frustum matrix will be written into
         * @param {Number} left Left bound of the frustum
         * @param {Number} right Right bound of the frustum
         * @param {Number} bottom Bottom bound of the frustum
         * @param {Number} top Top bound of the frustum
         * @param {Number} near Near bound of the frustum
         * @param {Number} far Far bound of the frustum
         * @returns {mat4} out
         */
        mat4.frustum = function (out, left, right, bottom, top, near, far) {
            var rl = 1 / (right - left),
                tb = 1 / (top - bottom),
                nf = 1 / (near - far);
            out[0] = near * 2 * rl;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = near * 2 * tb;
            out[6] = 0;
            out[7] = 0;
            out[8] = (right + left) * rl;
            out[9] = (top + bottom) * tb;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = far * near * 2 * nf;
            out[15] = 0;
            return out;
        };

        /**
         * Generates a perspective projection matrix with the given bounds
         *
         * @param {mat4} out mat4 frustum matrix will be written into
         * @param {number} fovy Vertical field of view in radians
         * @param {number} aspect Aspect ratio. typically viewport width/height
         * @param {number} near Near bound of the frustum
         * @param {number} far Far bound of the frustum
         * @returns {mat4} out
         */
        mat4.perspective = function (out, fovy, aspect, near, far) {
            var f = 1.0 / Math.tan(fovy / 2),
                nf = 1 / (near - far);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = 2 * far * near * nf;
            out[15] = 0;
            return out;
        };

        /**
         * Generates a orthogonal projection matrix with the given bounds
         *
         * @param {mat4} out mat4 frustum matrix will be written into
         * @param {number} left Left bound of the frustum
         * @param {number} right Right bound of the frustum
         * @param {number} bottom Bottom bound of the frustum
         * @param {number} top Top bound of the frustum
         * @param {number} near Near bound of the frustum
         * @param {number} far Far bound of the frustum
         * @returns {mat4} out
         */
        mat4.ortho = function (out, left, right, bottom, top, near, far) {
            var lr = 1 / (left - right),
                bt = 1 / (bottom - top),
                nf = 1 / (near - far);
            out[0] = -2 * lr;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = -2 * bt;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 2 * nf;
            out[11] = 0;
            out[12] = (left + right) * lr;
            out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf;
            out[15] = 1;
            return out;
        };

        /**
         * Generates a look-at matrix with the given eye position, focal point, and up axis
         *
         * @param {mat4} out mat4 frustum matrix will be written into
         * @param {vec3} eye Position of the viewer
         * @param {vec3} center Point the viewer is looking at
         * @param {vec3} up vec3 pointing up
         * @returns {mat4} out
         */
        mat4.lookAt = function (out, eye, center, up) {
            var x0,
                x1,
                x2,
                y0,
                y1,
                y2,
                z0,
                z1,
                z2,
                len,
                eyex = eye[0],
                eyey = eye[1],
                eyez = eye[2],
                upx = up[0],
                upy = up[1],
                upz = up[2],
                centerx = center[0],
                centery = center[1],
                centerz = center[2];

            if (Math.abs(eyex - centerx) < GLMAT_EPSILON && Math.abs(eyey - centery) < GLMAT_EPSILON && Math.abs(eyez - centerz) < GLMAT_EPSILON) {
                return mat4.identity(out);
            }

            z0 = eyex - centerx;
            z1 = eyey - centery;
            z2 = eyez - centerz;

            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len;
            z1 *= len;
            z2 *= len;

            x0 = upy * z2 - upz * z1;
            x1 = upz * z0 - upx * z2;
            x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
            } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
            }

            y0 = z1 * x2 - z2 * x1;
            y1 = z2 * x0 - z0 * x2;
            y2 = z0 * x1 - z1 * x0;

            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
            } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
            }

            out[0] = x0;
            out[1] = y0;
            out[2] = z0;
            out[3] = 0;
            out[4] = x1;
            out[5] = y1;
            out[6] = z1;
            out[7] = 0;
            out[8] = x2;
            out[9] = y2;
            out[10] = z2;
            out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;

            return out;
        };

        /**
         * Returns a string representation of a mat4
         *
         * @param {mat4} mat matrix to represent as a string
         * @returns {String} string representation of the matrix
         */
        mat4.str = function (a) {
            return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
        };

        /**
         * Returns Frobenius norm of a mat4
         *
         * @param {mat4} a the matrix to calculate Frobenius norm of
         * @returns {Number} Frobenius norm
         */
        mat4.frob = function (a) {
            return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
        };

        if (typeof exports !== 'undefined') {
            exports.mat4 = mat4;
        }
        ;
        /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
        
        Redistribution and use in source and binary forms, with or without modification,
        are permitted provided that the following conditions are met:
        
          * Redistributions of source code must retain the above copyright notice, this
            list of conditions and the following disclaimer.
          * Redistributions in binary form must reproduce the above copyright notice,
            this list of conditions and the following disclaimer in the documentation 
            and/or other materials provided with the distribution.
        
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

        /**
         * @class Quaternion
         * @name quat
         */

        var quat = {};

        /**
         * Creates a new identity quat
         *
         * @returns {quat} a new quaternion
         */
        quat.create = function () {
            var out = new GLMAT_ARRAY_TYPE(4);
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        };

        /**
         * Sets a quaternion to represent the shortest rotation from one
         * vector to another.
         *
         * Both vectors are assumed to be unit length.
         *
         * @param {quat} out the receiving quaternion.
         * @param {vec3} a the initial vector
         * @param {vec3} b the destination vector
         * @returns {quat} out
         */
        quat.rotationTo = function () {
            var tmpvec3 = vec3.create();
            var xUnitVec3 = vec3.fromValues(1, 0, 0);
            var yUnitVec3 = vec3.fromValues(0, 1, 0);

            return function (out, a, b) {
                var dot = vec3.dot(a, b);
                if (dot < -0.999999) {
                    vec3.cross(tmpvec3, xUnitVec3, a);
                    if (vec3.length(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
                    vec3.normalize(tmpvec3, tmpvec3);
                    quat.setAxisAngle(out, tmpvec3, Math.PI);
                    return out;
                } else if (dot > 0.999999) {
                    out[0] = 0;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 1;
                    return out;
                } else {
                    vec3.cross(tmpvec3, a, b);
                    out[0] = tmpvec3[0];
                    out[1] = tmpvec3[1];
                    out[2] = tmpvec3[2];
                    out[3] = 1 + dot;
                    return quat.normalize(out, out);
                }
            };
        }();

        /**
         * Sets the specified quaternion with values corresponding to the given
         * axes. Each axis is a vec3 and is expected to be unit length and
         * perpendicular to all other specified axes.
         *
         * @param {vec3} view  the vector representing the viewing direction
         * @param {vec3} right the vector representing the local "right" direction
         * @param {vec3} up    the vector representing the local "up" direction
         * @returns {quat} out
         */
        quat.setAxes = function () {
            var matr = mat3.create();

            return function (out, view, right, up) {
                matr[0] = right[0];
                matr[3] = right[1];
                matr[6] = right[2];

                matr[1] = up[0];
                matr[4] = up[1];
                matr[7] = up[2];

                matr[2] = -view[0];
                matr[5] = -view[1];
                matr[8] = -view[2];

                return quat.normalize(out, quat.fromMat3(out, matr));
            };
        }();

        /**
         * Creates a new quat initialized with values from an existing quaternion
         *
         * @param {quat} a quaternion to clone
         * @returns {quat} a new quaternion
         * @function
         */
        quat.clone = vec4.clone;

        /**
         * Creates a new quat initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @returns {quat} a new quaternion
         * @function
         */
        quat.fromValues = vec4.fromValues;

        /**
         * Copy the values from one quat to another
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a the source quaternion
         * @returns {quat} out
         * @function
         */
        quat.copy = vec4.copy;

        /**
         * Set the components of a quat to the given values
         *
         * @param {quat} out the receiving quaternion
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @param {Number} w W component
         * @returns {quat} out
         * @function
         */
        quat.set = vec4.set;

        /**
         * Set a quat to the identity quaternion
         *
         * @param {quat} out the receiving quaternion
         * @returns {quat} out
         */
        quat.identity = function (out) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        };

        /**
         * Sets a quat from the given angle and rotation axis,
         * then returns it.
         *
         * @param {quat} out the receiving quaternion
         * @param {vec3} axis the axis around which to rotate
         * @param {Number} rad the angle in radians
         * @returns {quat} out
         **/
        quat.setAxisAngle = function (out, axis, rad) {
            rad = rad * 0.5;
            var s = Math.sin(rad);
            out[0] = s * axis[0];
            out[1] = s * axis[1];
            out[2] = s * axis[2];
            out[3] = Math.cos(rad);
            return out;
        };

        /**
         * Adds two quat's
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a the first operand
         * @param {quat} b the second operand
         * @returns {quat} out
         * @function
         */
        quat.add = vec4.add;

        /**
         * Multiplies two quat's
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a the first operand
         * @param {quat} b the second operand
         * @returns {quat} out
         */
        quat.multiply = function (out, a, b) {
            var ax = a[0],
                ay = a[1],
                az = a[2],
                aw = a[3],
                bx = b[0],
                by = b[1],
                bz = b[2],
                bw = b[3];

            out[0] = ax * bw + aw * bx + ay * bz - az * by;
            out[1] = ay * bw + aw * by + az * bx - ax * bz;
            out[2] = az * bw + aw * bz + ax * by - ay * bx;
            out[3] = aw * bw - ax * bx - ay * by - az * bz;
            return out;
        };

        /**
         * Alias for {@link quat.multiply}
         * @function
         */
        quat.mul = quat.multiply;

        /**
         * Scales a quat by a scalar number
         *
         * @param {quat} out the receiving vector
         * @param {quat} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {quat} out
         * @function
         */
        quat.scale = vec4.scale;

        /**
         * Rotates a quaternion by the given angle about the X axis
         *
         * @param {quat} out quat receiving operation result
         * @param {quat} a quat to rotate
         * @param {number} rad angle (in radians) to rotate
         * @returns {quat} out
         */
        quat.rotateX = function (out, a, rad) {
            rad *= 0.5;

            var ax = a[0],
                ay = a[1],
                az = a[2],
                aw = a[3],
                bx = Math.sin(rad),
                bw = Math.cos(rad);

            out[0] = ax * bw + aw * bx;
            out[1] = ay * bw + az * bx;
            out[2] = az * bw - ay * bx;
            out[3] = aw * bw - ax * bx;
            return out;
        };

        /**
         * Rotates a quaternion by the given angle about the Y axis
         *
         * @param {quat} out quat receiving operation result
         * @param {quat} a quat to rotate
         * @param {number} rad angle (in radians) to rotate
         * @returns {quat} out
         */
        quat.rotateY = function (out, a, rad) {
            rad *= 0.5;

            var ax = a[0],
                ay = a[1],
                az = a[2],
                aw = a[3],
                by = Math.sin(rad),
                bw = Math.cos(rad);

            out[0] = ax * bw - az * by;
            out[1] = ay * bw + aw * by;
            out[2] = az * bw + ax * by;
            out[3] = aw * bw - ay * by;
            return out;
        };

        /**
         * Rotates a quaternion by the given angle about the Z axis
         *
         * @param {quat} out quat receiving operation result
         * @param {quat} a quat to rotate
         * @param {number} rad angle (in radians) to rotate
         * @returns {quat} out
         */
        quat.rotateZ = function (out, a, rad) {
            rad *= 0.5;

            var ax = a[0],
                ay = a[1],
                az = a[2],
                aw = a[3],
                bz = Math.sin(rad),
                bw = Math.cos(rad);

            out[0] = ax * bw + ay * bz;
            out[1] = ay * bw - ax * bz;
            out[2] = az * bw + aw * bz;
            out[3] = aw * bw - az * bz;
            return out;
        };

        /**
         * Calculates the W component of a quat from the X, Y, and Z components.
         * Assumes that quaternion is 1 unit in length.
         * Any existing W component will be ignored.
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a quat to calculate W component of
         * @returns {quat} out
         */
        quat.calculateW = function (out, a) {
            var x = a[0],
                y = a[1],
                z = a[2];

            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return out;
        };

        /**
         * Calculates the dot product of two quat's
         *
         * @param {quat} a the first operand
         * @param {quat} b the second operand
         * @returns {Number} dot product of a and b
         * @function
         */
        quat.dot = vec4.dot;

        /**
         * Performs a linear interpolation between two quat's
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a the first operand
         * @param {quat} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @returns {quat} out
         * @function
         */
        quat.lerp = vec4.lerp;

        /**
         * Performs a spherical linear interpolation between two quat
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a the first operand
         * @param {quat} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @returns {quat} out
         */
        quat.slerp = function (out, a, b, t) {
            // benchmarks:
            //    http://jsperf.com/quaternion-slerp-implementations

            var ax = a[0],
                ay = a[1],
                az = a[2],
                aw = a[3],
                bx = b[0],
                by = b[1],
                bz = b[2],
                bw = b[3];

            var omega, cosom, sinom, scale0, scale1;

            // calc cosine
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            // adjust signs (if necessary)
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            // calculate coefficients
            if (1.0 - cosom > 0.000001) {
                // standard case (slerp)
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            } else {
                // "from" and "to" quaternions are very close 
                //  ... so we can do a linear interpolation
                scale0 = 1.0 - t;
                scale1 = t;
            }
            // calculate final values
            out[0] = scale0 * ax + scale1 * bx;
            out[1] = scale0 * ay + scale1 * by;
            out[2] = scale0 * az + scale1 * bz;
            out[3] = scale0 * aw + scale1 * bw;

            return out;
        };

        /**
         * Calculates the inverse of a quat
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a quat to calculate inverse of
         * @returns {quat} out
         */
        quat.invert = function (out, a) {
            var a0 = a[0],
                a1 = a[1],
                a2 = a[2],
                a3 = a[3],
                dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
                invDot = dot ? 1.0 / dot : 0;

            // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

            out[0] = -a0 * invDot;
            out[1] = -a1 * invDot;
            out[2] = -a2 * invDot;
            out[3] = a3 * invDot;
            return out;
        };

        /**
         * Calculates the conjugate of a quat
         * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a quat to calculate conjugate of
         * @returns {quat} out
         */
        quat.conjugate = function (out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = a[3];
            return out;
        };

        /**
         * Calculates the length of a quat
         *
         * @param {quat} a vector to calculate length of
         * @returns {Number} length of a
         * @function
         */
        quat.length = vec4.length;

        /**
         * Alias for {@link quat.length}
         * @function
         */
        quat.len = quat.length;

        /**
         * Calculates the squared length of a quat
         *
         * @param {quat} a vector to calculate squared length of
         * @returns {Number} squared length of a
         * @function
         */
        quat.squaredLength = vec4.squaredLength;

        /**
         * Alias for {@link quat.squaredLength}
         * @function
         */
        quat.sqrLen = quat.squaredLength;

        /**
         * Normalize a quat
         *
         * @param {quat} out the receiving quaternion
         * @param {quat} a quaternion to normalize
         * @returns {quat} out
         * @function
         */
        quat.normalize = vec4.normalize;

        /**
         * Creates a quaternion from the given 3x3 rotation matrix.
         *
         * NOTE: The resultant quaternion is not normalized, so you should be sure
         * to renormalize the quaternion yourself where necessary.
         *
         * @param {quat} out the receiving quaternion
         * @param {mat3} m rotation matrix
         * @returns {quat} out
         * @function
         */
        quat.fromMat3 = function (out, m) {
            // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
            // article "Quaternion Calculus and Fast Animation".
            var fTrace = m[0] + m[4] + m[8];
            var fRoot;

            if (fTrace > 0.0) {
                // |w| > 1/2, may as well choose w > 1/2
                fRoot = Math.sqrt(fTrace + 1.0); // 2w
                out[3] = 0.5 * fRoot;
                fRoot = 0.5 / fRoot; // 1/(4w)
                out[0] = (m[7] - m[5]) * fRoot;
                out[1] = (m[2] - m[6]) * fRoot;
                out[2] = (m[3] - m[1]) * fRoot;
            } else {
                // |w| <= 1/2
                var i = 0;
                if (m[4] > m[0]) i = 1;
                if (m[8] > m[i * 3 + i]) i = 2;
                var j = (i + 1) % 3;
                var k = (i + 2) % 3;

                fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
                out[i] = 0.5 * fRoot;
                fRoot = 0.5 / fRoot;
                out[3] = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;
                out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
                out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
            }

            return out;
        };

        /**
         * Returns a string representation of a quatenion
         *
         * @param {quat} vec vector to represent as a string
         * @returns {String} string representation of the vector
         */
        quat.str = function (a) {
            return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
        };

        if (typeof exports !== 'undefined') {
            exports.quat = quat;
        }
        ;
    })(shim.exports);
})(this);

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;

  if (!this._events) this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++) listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events || !this._events[type]) return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;

  if (!this._events) return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var glMatrix = __webpack_require__(2),
    vec3 = glMatrix.vec3;

/**
 * Constructs a Pointable object.
 *
 * An uninitialized pointable is considered invalid.
 * Get valid Pointable objects from a Frame or a Hand object.
 *
 * @class Pointable
 * @memberof Leap
 * @classdesc
 * The Pointable class reports the physical characteristics of a detected
 * finger or tool.
 *
 * Both fingers and tools are classified as Pointable objects. Use the
 * Pointable.tool property to determine whether a Pointable object represents a
 * tool or finger. The Leap classifies a detected entity as a tool when it is
 * thinner, straighter, and longer than a typical finger.
 *
 * Note that Pointable objects can be invalid, which means that they do not
 * contain valid tracking data and do not correspond to a physical entity.
 * Invalid Pointable objects can be the result of asking for a Pointable object
 * using an ID from an earlier frame when no Pointable objects with that ID
 * exist in the current frame. A Pointable object created from the Pointable
 * constructor is also invalid. Test for validity with the Pointable.valid
 * property.
 */
var Pointable = module.exports = function (data) {
  /**
   * Indicates whether this is a valid Pointable object.
   *
   * @member valid
   * @type {Boolean}
   * @memberof Leap.Pointable.prototype
   */
  this.valid = true;
  /**
   * A unique ID assigned to this Pointable object, whose value remains the
   * same across consecutive frames while the tracked finger or tool remains
   * visible. If tracking is lost (for example, when a finger is occluded by
   * another finger or when it is withdrawn from the Leap field of view), the
   * Leap may assign a new ID when it detects the entity in a future frame.
   *
   * Use the ID value with the pointable() functions defined for the
   * {@link Frame} and {@link Frame.Hand} classes to find this
   * Pointable object in future frames.
   *
   * @member id
   * @type {String}
   * @memberof Leap.Pointable.prototype
   */
  this.id = data.id;
  this.handId = data.handId;
  /**
   * The estimated length of the finger or tool in millimeters.
   *
   * The reported length is the visible length of the finger or tool from the
   * hand to tip. If the length isn't known, then a value of 0 is returned.
   *
   * @member length
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.length = data.length;
  /**
   * Whether or not the Pointable is believed to be a tool.
   * Tools are generally longer, thinner, and straighter than fingers.
   *
   * If tool is false, then this Pointable must be a finger.
   *
   * @member tool
   * @type {Boolean}
   * @memberof Leap.Pointable.prototype
   */
  this.tool = data.tool;
  /**
   * The estimated width of the tool in millimeters.
   *
   * The reported width is the average width of the visible portion of the
   * tool from the hand to the tip. If the width isn't known,
   * then a value of 0 is returned.
   *
   * Pointable objects representing fingers do not have a width property.
   *
   * @member width
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.width = data.width;
  /**
   * The direction in which this finger or tool is pointing.
   *
   * The direction is expressed as a unit vector pointing in the same
   * direction as the tip.
   *
   * ![Finger](images/Leap_Finger_Model.png)
   * @member direction
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.direction = data.direction;
  /**
   * The tip position in millimeters from the Leap origin.
   * Stabilized
   *
   * @member stabilizedTipPosition
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.stabilizedTipPosition = data.stabilizedTipPosition;
  /**
   * The tip position in millimeters from the Leap origin.
   *
   * @member tipPosition
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.tipPosition = data.tipPosition;
  /**
   * The rate of change of the tip position in millimeters/second.
   *
   * @member tipVelocity
   * @type {number[]}
   * @memberof Leap.Pointable.prototype
   */
  this.tipVelocity = data.tipVelocity;
  /**
   * The current touch zone of this Pointable object.
   *
   * The Leap Motion software computes the touch zone based on a floating touch
   * plane that adapts to the user's finger movement and hand posture. The Leap
   * Motion software interprets purposeful movements toward this plane as potential touch
   * points. When a Pointable moves close to the adaptive touch plane, it enters the
   * "hovering" zone. When a Pointable reaches or passes through the plane, it enters
   * the "touching" zone.
   *
   * The possible states include:
   *
   * * "none" -- The Pointable is outside the hovering zone.
   * * "hovering" -- The Pointable is close to, but not touching the touch plane.
   * * "touching" -- The Pointable has penetrated the touch plane.
   *
   * The touchDistance value provides a normalized indication of the distance to
   * the touch plane when the Pointable is in the hovering or touching zones.
   *
   * @member touchZone
   * @type {String}
   * @memberof Leap.Pointable.prototype
   */
  this.touchZone = data.touchZone;
  /**
   * A value proportional to the distance between this Pointable object and the
   * adaptive touch plane.
   *
   * ![Touch Distance](images/Leap_Touch_Plane.png)
   *
   * The touch distance is a value in the range [-1, 1]. The value 1.0 indicates the
   * Pointable is at the far edge of the hovering zone. The value 0 indicates the
   * Pointable is just entering the touching zone. A value of -1.0 indicates the
   * Pointable is firmly within the touching zone. Values in between are
   * proportional to the distance from the plane. Thus, the touchDistance of 0.5
   * indicates that the Pointable is halfway into the hovering zone.
   *
   * You can use the touchDistance value to modulate visual feedback given to the
   * user as their fingers close in on a touch target, such as a button.
   *
   * @member touchDistance
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.touchDistance = data.touchDistance;

  /**
   * How long the pointable has been visible in seconds.
   *
   * @member timeVisible
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.timeVisible = data.timeVisible;
};

/**
 * A string containing a brief, human readable description of the Pointable
 * object.
 *
 * @method toString
 * @memberof Leap.Pointable.prototype
 * @returns {String} A description of the Pointable object as a string.
 */
Pointable.prototype.toString = function () {
  return "Pointable [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + ' ]';
};

/**
 * Returns the hand which the pointable is attached to.
 */
Pointable.prototype.hand = function () {
  return this.frame.hand(this.handId);
};

/**
 * An invalid Pointable object.
 *
 * You can use this Pointable instance in comparisons testing
 * whether a given Pointable instance is valid or invalid. (You can also use the
 * Pointable.valid property.)

 * @static
 * @type {Leap.Pointable}
 * @name Invalid
 * @memberof Leap.Pointable
 */
Pointable.Invalid = { valid: false };

/***/ }),
/* 5 */,
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export canvas2d */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ctx2d; });
/* harmony export (immutable) */ __webpack_exports__["a"] = update;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__input_js__ = __webpack_require__(8);
/* harmony namespace reexport (by used) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__input_js__["c"]; });


var canvas2d = document.createElement("canvas");
var ctx2d = canvas2d.getContext('2d');

global.t = 0;
global.sinT = 0;
global.cosT = 0;

function update() {
    t += 0.001;
    sinT = Math.sin(t);
    cosT = Math.cos(t);
}

global.pushMatrix = function (ctx, job) {
    ctx.save();
    job();
    ctx.restore();
};

canvas2d.height = 1080;
canvas2d.width = 1080;
canvas2d.id = "canvas2d";

global.hsl = function (h, s, l) {
    var r, g, b;
    if (s == 0) {
        r = g = b = l; // achromatic
    } else {
        var hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}`;
};

global.hsl_raw = function (h, s, l) {
    var r, g, b;
    if (s == 0) {
        r = g = b = l; // achromatic
    } else {
        var hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r, g, b];
};

global.distsq = function (a, b, c, d) {
    return (a - c) * (a - c) + (b - d) * (b - d);
};

global.dist = function (a, b, c, d) {
    return Math.sqrt(distsq(a, b, c, d));
};

global.ease = function (obj, a, b, ratio = 0.1, threshold = 0.01) {
    if (Math.abs(obj[a] - obj[b]) > threshold) {
        obj[b] += (obj[a] - obj[b]) * ratio;
    } else if (obj[a] !== obj[b]) {
        obj[b] = obj[a];
    }
};

canvas2d.style.zIndex = 998988;
document.body.appendChild(canvas2d);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(12)))

/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return mouse; });
/* harmony export (immutable) */ __webpack_exports__["a"] = updateInputEase;
/* harmony export (immutable) */ __webpack_exports__["b"] = render_debug;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__global_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_leapjs__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_leapjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_leapjs__);



const EASE_THRESHOLD = 0.1;
const EASE_RATIO = 0.2;

global.hoveringElement = undefined;

var mouse = {
    x: 0,
    y: 0,
    z: 2080,
    ex: 0,
    ey: 0,
    ez: 0,
    px: 0,
    py: 0,
    pz: 0,
    dx: 0,
    dy: 0,
    dz: 0,
    grab: 0,
    pick: false,
    flying: false,
    highlock: false
};

function map(val, a, b, c, d) {
    return (val - a) / (b - a) * (d - c) + c;
}

global.NOLEAP = false;

__WEBPACK_IMPORTED_MODULE_1_leapjs__["loop"](function (frame) {
    if (!global.NOLEAP) {
        if (frame.hands.length > 0) {
            var h = frame.hands[0].palmPosition;
            //   console.log(frame.hands[0]);
            mouse.x = map(h[0], -150, 150, 0, 1080);
            mouse.y = map(h[2], -150, 150, 0, 1080);
            mouse.z = Math.max(Math.min(2000, map(h[1], 120, 500, 50, 2080)), 150);

            mouse.grab = frame.hands[0].grabStrength;
            mouse.pick = frame.hands[0].indexFinger.extended && mouse.grab > 0.8;
            mouse.flying = mouse.grab < 0.4 && frame.hands[0].middleFinger.extended && frame.hands[0].indexFinger.extended && frame.hands[0].pinchStrength < 0.2;
            mouse.highlock = mouse.ez > 1000;
        } else {
            mouse.flying = false;
        }
    }
});

document.addEventListener("mousedown", function (e) {
    mouse.flying = true;
});

document.addEventListener("mouseup", function (e) {
    mouse.flying = false;
});

document.addEventListener("mousemove", function (e) {
    mouse.x = e.pageX;
    mouse.y = e.pageY;
    mouse.z = 2080;
    if (mouse.flying) {
        mouse.z = 1000;
    }
});

function updateInputEase() {
    ease(mouse, 'x', 'ex', EASE_RATIO, EASE_THRESHOLD);
    ease(mouse, 'y', 'ey', EASE_RATIO, EASE_THRESHOLD);
    ease(mouse, 'z', 'ez', EASE_RATIO, EASE_THRESHOLD);

    mouse.dx = mouse.ex - mouse.px;
    mouse.dy = mouse.ey - mouse.py;
    mouse.dz = mouse.ez - mouse.pz;
    mouse.px = mouse.ex;
    mouse.py = mouse.ey;
    mouse.pz = mouse.ez;
    // console.log(mouse.z);

    global.hoveringElement = document.elementFromPoint(mouse.ex, mouse.ey);
}

function render_debug() {
    if (mouse.flying) {
        pushMatrix(__WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */], () => {
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].translate(mouse.ex, mouse.ey);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].scale(mouse.ez / 1080 * 3 + 1, mouse.ez / 1080 * 3 + 1);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].fillStyle = "#fff";
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].beginPath();
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].arc(0, 0, 5, 0, Math.PI * 2);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].fill();
        });
    } else {
        pushMatrix(__WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */], () => {
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].translate(mouse.ex, mouse.ey);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].scale(mouse.ez / 1080 * 2 + 1, mouse.ez / 1080 * 2 + 1);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].strokeStyle = "#fff";
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].lineCap = "round";
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].lineJoin = "round";
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].lineWidth = 1;
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].beginPath();
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].moveTo(-5, 0);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].lineTo(5, 0);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].moveTo(0, -5);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].lineTo(0, 5);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].stroke();
        });
    }
}

global.mouse = mouse;
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(12)))

/***/ }),
/* 9 */,
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var Pointable = __webpack_require__(4),
    Bone = __webpack_require__(50),
    Dialog = __webpack_require__(53),
    _ = __webpack_require__(0);

/**
* Constructs a Finger object.
*
* An uninitialized finger is considered invalid.
* Get valid Finger objects from a Frame or a Hand object.
*
* @class Finger
* @memberof Leap
* @classdesc
* The Finger class reports the physical characteristics of a finger.
*
* Both fingers and tools are classified as Pointable objects. Use the
* Pointable.tool property to determine whether a Pointable object represents a
* tool or finger. The Leap classifies a detected entity as a tool when it is
* thinner, straighter, and longer than a typical finger.
*
* Note that Finger objects can be invalid, which means that they do not
* contain valid tracking data and do not correspond to a physical entity.
* Invalid Finger objects can be the result of asking for a Finger object
* using an ID from an earlier frame when no Finger objects with that ID
* exist in the current frame. A Finger object created from the Finger
* constructor is also invalid. Test for validity with the Pointable.valid
* property.
*/
var Finger = module.exports = function (data) {
  Pointable.call(this, data); // use pointable as super-constructor

  /**
  * The position of the distal interphalangeal joint of the finger.
  * This joint is closest to the tip.
  * 
  * The distal interphalangeal joint is located between the most extreme segment
  * of the finger (the distal phalanx) and the middle segment (the medial
  * phalanx).
  *
  * @member dipPosition
  * @type {number[]}
  * @memberof Leap.Finger.prototype
  */
  this.dipPosition = data.dipPosition;

  /**
  * The position of the proximal interphalangeal joint of the finger. This joint is the middle
  * joint of a finger.
  *
  * The proximal interphalangeal joint is located between the two finger segments
  * closest to the hand (the proximal and the medial phalanges). On a thumb,
  * which lacks an medial phalanx, this joint index identifies the knuckle joint
  * between the proximal phalanx and the metacarpal bone.
  *
  * @member pipPosition
  * @type {number[]}
  * @memberof Leap.Finger.prototype
  */
  this.pipPosition = data.pipPosition;

  /**
  * The position of the metacarpopophalangeal joint, or knuckle, of the finger.
  *
  * The metacarpopophalangeal joint is located at the base of a finger between
  * the metacarpal bone and the first phalanx. The common name for this joint is
  * the knuckle.
  *
  * On a thumb, which has one less phalanx than a finger, this joint index
  * identifies the thumb joint near the base of the hand, between the carpal
  * and metacarpal bones.
  *
  * @member mcpPosition
  * @type {number[]}
  * @memberof Leap.Finger.prototype
  */
  this.mcpPosition = data.mcpPosition;

  /**
   * The position of the Carpometacarpal joint
   *
   * This is at the distal end of the wrist, and has no common name.
   *
   */
  this.carpPosition = data.carpPosition;

  /**
  * Whether or not this finger is in an extended posture.
  *
  * A finger is considered extended if it is extended straight from the hand as if
  * pointing. A finger is not extended when it is bent down and curled towards the 
  * palm.
  * @member extended
  * @type {Boolean}
  * @memberof Leap.Finger.prototype
  */
  this.extended = data.extended;

  /**
  * An integer code for the name of this finger.
  * 
  * * 0 -- thumb
  * * 1 -- index finger
  * * 2 -- middle finger
  * * 3 -- ring finger
  * * 4 -- pinky
  *
  * @member type
  * @type {number}
  * @memberof Leap.Finger.prototype
  */
  this.type = data.type;

  this.finger = true;

  /**
  * The joint positions of this finger as an array in the order base to tip.
  *
  * @member positions
  * @type {array[]}
  * @memberof Leap.Finger.prototype
  */
  this.positions = [this.carpPosition, this.mcpPosition, this.pipPosition, this.dipPosition, this.tipPosition];

  if (data.bases) {
    this.addBones(data);
  } else {
    Dialog.warnBones();
  }
};

_.extend(Finger.prototype, Pointable.prototype);

Finger.prototype.addBones = function (data) {
  /**
  * Four bones per finger, from wrist outwards:
  * metacarpal, proximal, medial, and distal.
  *
  * See http://en.wikipedia.org/wiki/Interphalangeal_articulations_of_hand
  */
  this.metacarpal = new Bone(this, {
    type: 0,
    width: this.width,
    prevJoint: this.carpPosition,
    nextJoint: this.mcpPosition,
    basis: data.bases[0]
  });

  this.proximal = new Bone(this, {
    type: 1,
    width: this.width,
    prevJoint: this.mcpPosition,
    nextJoint: this.pipPosition,
    basis: data.bases[1]
  });

  this.medial = new Bone(this, {
    type: 2,
    width: this.width,
    prevJoint: this.pipPosition,
    nextJoint: this.dipPosition,
    basis: data.bases[2]
  });

  /**
   * Note that the `distal.nextJoint` position is slightly different from the `finger.tipPosition`.
   * The former is at the very end of the bone, where the latter is the center of a sphere positioned at
   * the tip of the finger.  The btipPosition "bone tip position" is a few mm closer to the wrist than
   * the tipPosition.
   * @type {Bone}
   */
  this.distal = new Bone(this, {
    type: 3,
    width: this.width,
    prevJoint: this.dipPosition,
    nextJoint: data.btipPosition,
    basis: data.bases[3]
  });

  this.bones = [this.metacarpal, this.proximal, this.medial, this.distal];
};

Finger.prototype.toString = function () {
  return "Finger [ id:" + this.id + " " + this.length + "mmx | width:" + this.width + "mm | direction:" + this.direction + ' ]';
};

Finger.Invalid = { valid: false };

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var Pointable = __webpack_require__(4),
    Bone = __webpack_require__(50),
    glMatrix = __webpack_require__(2),
    mat3 = glMatrix.mat3,
    vec3 = glMatrix.vec3,
    _ = __webpack_require__(0);

/**
 * Constructs a Hand object.
 *
 * An uninitialized hand is considered invalid.
 * Get valid Hand objects from a Frame object.
 * @class Hand
 * @memberof Leap
 * @classdesc
 * The Hand class reports the physical characteristics of a detected hand.
 *
 * Hand tracking data includes a palm position and velocity; vectors for
 * the palm normal and direction to the fingers; properties of a sphere fit
 * to the hand; and lists of the attached fingers and tools.
 *
 * Note that Hand objects can be invalid, which means that they do not contain
 * valid tracking data and do not correspond to a physical entity. Invalid Hand
 * objects can be the result of asking for a Hand object using an ID from an
 * earlier frame when no Hand objects with that ID exist in the current frame.
 * A Hand object created from the Hand constructor is also invalid.
 * Test for validity with the [Hand.valid]{@link Leap.Hand#valid} property.
 */
var Hand = module.exports = function (data) {
  /**
   * A unique ID assigned to this Hand object, whose value remains the same
   * across consecutive frames while the tracked hand remains visible. If
   * tracking is lost (for example, when a hand is occluded by another hand
   * or when it is withdrawn from or reaches the edge of the Leap field of view),
   * the Leap may assign a new ID when it detects the hand in a future frame.
   *
   * Use the ID value with the {@link Frame.hand}() function to find this
   * Hand object in future frames.
   *
   * @member id
   * @memberof Leap.Hand.prototype
   * @type {String}
   */
  this.id = data.id;
  /**
   * The center position of the palm in millimeters from the Leap origin.
   * @member palmPosition
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.palmPosition = data.palmPosition;
  /**
   * The direction from the palm position toward the fingers.
   *
   * The direction is expressed as a unit vector pointing in the same
   * direction as the directed line from the palm position to the fingers.
   *
   * @member direction
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.direction = data.direction;
  /**
   * The rate of change of the palm position in millimeters/second.
   *
   * @member palmVeclocity
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.palmVelocity = data.palmVelocity;
  /**
   * The normal vector to the palm. If your hand is flat, this vector will
   * point downward, or "out" of the front surface of your palm.
   *
   * ![Palm Vectors](images/Leap_Palm_Vectors.png)
   *
   * The direction is expressed as a unit vector pointing in the same
   * direction as the palm normal (that is, a vector orthogonal to the palm).
   * @member palmNormal
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.palmNormal = data.palmNormal;
  /**
   * The center of a sphere fit to the curvature of this hand.
   *
   * This sphere is placed roughly as if the hand were holding a ball.
   *
   * ![Hand Ball](images/Leap_Hand_Ball.png)
   * @member sphereCenter
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.sphereCenter = data.sphereCenter;
  /**
   * The radius of a sphere fit to the curvature of this hand, in millimeters.
   *
   * This sphere is placed roughly as if the hand were holding a ball. Thus the
   * size of the sphere decreases as the fingers are curled into a fist.
   *
   * @member sphereRadius
   * @memberof Leap.Hand.prototype
   * @type {number}
   */
  this.sphereRadius = data.sphereRadius;
  /**
   * Reports whether this is a valid Hand object.
   *
   * @member valid
   * @memberof Leap.Hand.prototype
   * @type {boolean}
   */
  this.valid = true;
  /**
   * The list of Pointable objects (fingers and tools) detected in this frame
   * that are associated with this hand, given in arbitrary order. The list
   * can be empty if no fingers or tools associated with this hand are detected.
   *
   * Use the {@link Pointable} tool property to determine
   * whether or not an item in the list represents a tool or finger.
   * You can also get only the tools using the Hand.tools[] list or
   * only the fingers using the Hand.fingers[] list.
   *
   * @member pointables[]
   * @memberof Leap.Hand.prototype
   * @type {Leap.Pointable[]}
   */
  this.pointables = [];
  /**
   * The list of fingers detected in this frame that are attached to
   * this hand, given in arbitrary order.
   *
   * The list can be empty if no fingers attached to this hand are detected.
   *
   * @member fingers[]
   * @memberof Leap.Hand.prototype
   * @type {Leap.Pointable[]}
   */
  this.fingers = [];

  if (data.armBasis) {
    this.arm = new Bone(this, {
      type: 4,
      width: data.armWidth,
      prevJoint: data.elbow,
      nextJoint: data.wrist,
      basis: data.armBasis
    });
  } else {
    this.arm = null;
  }

  /**
   * The list of tools detected in this frame that are held by this
   * hand, given in arbitrary order.
   *
   * The list can be empty if no tools held by this hand are detected.
   *
   * @member tools[]
   * @memberof Leap.Hand.prototype
   * @type {Leap.Pointable[]}
   */
  this.tools = [];
  this._translation = data.t;
  this._rotation = _.flatten(data.r);
  this._scaleFactor = data.s;

  /**
   * Time the hand has been visible in seconds.
   *
   * @member timeVisible
   * @memberof Leap.Hand.prototype
   * @type {number}
   */
  this.timeVisible = data.timeVisible;

  /**
   * The palm position with stabalization
   * @member stabilizedPalmPosition
   * @memberof Leap.Hand.prototype
   * @type {number[]}
   */
  this.stabilizedPalmPosition = data.stabilizedPalmPosition;

  /**
  * Reports whether this is a left or a right hand.
  *
  * @member type
  * @type {String}
  * @memberof Leap.Hand.prototype
  */
  this.type = data.type;
  this.grabStrength = data.grabStrength;
  this.pinchStrength = data.pinchStrength;
  this.confidence = data.confidence;
};

/**
 * The finger with the specified ID attached to this hand.
 *
 * Use this function to retrieve a Pointable object representing a finger
 * attached to this hand using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no finger
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that the ID values assigned to fingers persist across frames, but only
 * until tracking of a particular finger is lost. If tracking of a finger is
 * lost and subsequently regained, the new Finger object representing that
 * finger may have a different ID than that representing the finger in an
 * earlier frame.
 *
 * @method finger
 * @memberof Leap.Hand.prototype
 * @param {String} id The ID value of a finger from a previous frame.
 * @returns {Leap.Pointable} The Finger object with
 * the matching ID if one exists for this hand in this frame; otherwise, an
 * invalid Finger object is returned.
 */
Hand.prototype.finger = function (id) {
  var finger = this.frame.finger(id);
  return finger && finger.handId == this.id ? finger : Pointable.Invalid;
};

/**
 * The angle of rotation around the rotation axis derived from the change in
 * orientation of this hand, and any associated fingers and tools, between the
 * current frame and the specified frame.
 *
 * The returned angle is expressed in radians measured clockwise around the
 * rotation axis (using the right-hand rule) between the start and end frames.
 * The value is always between 0 and pi radians (0 and 180 degrees).
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either
 * this frame or sinceFrame are invalid Frame objects, then the angle of rotation is zero.
 *
 * @method rotationAngle
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @param {numnber[]} [axis] The axis to measure rotation around.
 * @returns {number} A positive value representing the heuristically determined
 * rotational change of the hand between the current frame and that specified in
 * the sinceFrame parameter.
 */
Hand.prototype.rotationAngle = function (sinceFrame, axis) {
  if (!this.valid || !sinceFrame.valid) return 0.0;
  var sinceHand = sinceFrame.hand(this.id);
  if (!sinceHand.valid) return 0.0;
  var rot = this.rotationMatrix(sinceFrame);
  var cs = (rot[0] + rot[4] + rot[8] - 1.0) * 0.5;
  var angle = Math.acos(cs);
  angle = isNaN(angle) ? 0.0 : angle;
  if (axis !== undefined) {
    var rotAxis = this.rotationAxis(sinceFrame);
    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));
  }
  return angle;
};

/**
 * The axis of rotation derived from the change in orientation of this hand, and
 * any associated fingers and tools, between the current frame and the specified frame.
 *
 * The returned direction vector is normalized.
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either
 * this frame or sinceFrame are invalid Frame objects, then this method returns a zero vector.
 *
 * @method rotationAxis
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A normalized direction Vector representing the axis of the heuristically determined
 * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.rotationAxis = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  var sinceHand = sinceFrame.hand(this.id);
  if (!sinceHand.valid) return vec3.create();
  return vec3.normalize(vec3.create(), [this._rotation[7] - sinceHand._rotation[5], this._rotation[2] - sinceHand._rotation[6], this._rotation[3] - sinceHand._rotation[1]]);
};

/**
 * The transform matrix expressing the rotation derived from the change in
 * orientation of this hand, and any associated fingers and tools, between
 * the current frame and the specified frame.
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either
 * this frame or sinceFrame are invalid Frame objects, then this method returns
 * an identity matrix.
 *
 * @method rotationMatrix
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A transformation Matrix containing the heuristically determined
 * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.rotationMatrix = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return mat3.create();
  var sinceHand = sinceFrame.hand(this.id);
  if (!sinceHand.valid) return mat3.create();
  var transpose = mat3.transpose(mat3.create(), this._rotation);
  var m = mat3.multiply(mat3.create(), sinceHand._rotation, transpose);
  return m;
};

/**
 * The scale factor derived from the hand's motion between the current frame and the specified frame.
 *
 * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
 * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
 *
 * The Leap derives scaling from the relative inward or outward motion of a hand
 * and its associated fingers and tools (independent of translation and rotation).
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either this frame or sinceFrame
 * are invalid Frame objects, then this method returns 1.0.
 *
 * @method scaleFactor
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.
 * @returns {number} A positive value representing the heuristically determined
 * scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.scaleFactor = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return 1.0;
  var sinceHand = sinceFrame.hand(this.id);
  if (!sinceHand.valid) return 1.0;

  return Math.exp(this._scaleFactor - sinceHand._scaleFactor);
};

/**
 * The change of position of this hand between the current frame and the specified frame
 *
 * The returned translation vector provides the magnitude and direction of the
 * movement in millimeters.
 *
 * If a corresponding Hand object is not found in sinceFrame, or if either this frame or
 * sinceFrame are invalid Frame objects, then this method returns a zero vector.
 *
 * @method translation
 * @memberof Leap.Hand.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.
 * @returns {number[]} A Vector representing the heuristically determined change in hand
 * position between the current frame and that specified in the sinceFrame parameter.
 */
Hand.prototype.translation = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  var sinceHand = sinceFrame.hand(this.id);
  if (!sinceHand.valid) return vec3.create();
  return [this._translation[0] - sinceHand._translation[0], this._translation[1] - sinceHand._translation[1], this._translation[2] - sinceHand._translation[2]];
};

/**
 * A string containing a brief, human readable description of the Hand object.
 * @method toString
 * @memberof Leap.Hand.prototype
 * @returns {String} A description of the Hand as a string.
 */
Hand.prototype.toString = function () {
  return "Hand (" + this.type + ") [ id: " + this.id + " | palm velocity:" + this.palmVelocity + " | sphere center:" + this.sphereCenter + " ] ";
};

/**
 * The pitch angle in radians.
 *
 * Pitch is the angle between the negative z-axis and the projection of
 * the vector onto the y-z plane. In other words, pitch represents rotation
 * around the x-axis.
 * If the vector points upward, the returned angle is between 0 and pi radians
 * (180 degrees); if it points downward, the angle is between 0 and -pi radians.
 *
 * @method pitch
 * @memberof Leap.Hand.prototype
 * @returns {number} The angle of this vector above or below the horizon (x-z plane).
 *
 */
Hand.prototype.pitch = function () {
  return Math.atan2(this.direction[1], -this.direction[2]);
};

/**
 *  The yaw angle in radians.
 *
 * Yaw is the angle between the negative z-axis and the projection of
 * the vector onto the x-z plane. In other words, yaw represents rotation
 * around the y-axis. If the vector points to the right of the negative z-axis,
 * then the returned angle is between 0 and pi radians (180 degrees);
 * if it points to the left, the angle is between 0 and -pi radians.
 *
 * @method yaw
 * @memberof Leap.Hand.prototype
 * @returns {number} The angle of this vector to the right or left of the y-axis.
 *
 */
Hand.prototype.yaw = function () {
  return Math.atan2(this.direction[0], -this.direction[2]);
};

/**
 *  The roll angle in radians.
 *
 * Roll is the angle between the y-axis and the projection of
 * the vector onto the x-y plane. In other words, roll represents rotation
 * around the z-axis. If the vector points to the left of the y-axis,
 * then the returned angle is between 0 and pi radians (180 degrees);
 * if it points to the right, the angle is between 0 and -pi radians.
 *
 * @method roll
 * @memberof Leap.Hand.prototype
 * @returns {number} The angle of this vector to the right or left of the y-axis.
 *
 */
Hand.prototype.roll = function () {
  return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);
};

/**
 * An invalid Hand object.
 *
 * You can use an invalid Hand object in comparisons testing
 * whether a given Hand instance is valid or invalid. (You can also use the
 * Hand valid property.)
 *
 * @static
 * @type {Leap.Hand}
 * @name Invalid
 * @memberof Leap.Hand
 */
Hand.Invalid = {
  valid: false,
  fingers: [],
  tools: [],
  pointables: [],
  left: false,
  pointable: function () {
    return Pointable.Invalid;
  },
  finger: function () {
    return Pointable.Invalid;
  },
  toString: function () {
    return "invalid frame";
  },
  dump: function () {
    return this.toString();
  },
  rotationAngle: function () {
    return 0.0;
  },
  rotationMatrix: function () {
    return mat3.create();
  },
  rotationAxis: function () {
    return vec3.create();
  },
  scaleFactor: function () {
    return 1.0;
  },
  translation: function () {
    return vec3.create();
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org Version 4.9.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
   true ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.d3 = global.d3 || {});
})(this, function (exports) {
  'use strict';

  var version = "4.9.1";

  var ascending = function (a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  };

  var bisector = function (compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function (a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
        }
        return lo;
      },
      right: function (a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
        }
        return lo;
      }
    };
  };

  function ascendingComparator(f) {
    return function (d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  var pairs = function (array, f) {
    if (f == null) f = pair;
    var i = 0,
        n = array.length - 1,
        p = array[0],
        pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = f(p, p = array[++i]);
    return pairs;
  };

  function pair(a, b) {
    return [a, b];
  }

  var cross = function (values0, values1, reduce) {
    var n0 = values0.length,
        n1 = values1.length,
        values = new Array(n0 * n1),
        i0,
        i1,
        i,
        value0;

    if (reduce == null) reduce = pair;

    for (i0 = i = 0; i0 < n0; ++i0) {
      for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
        values[i] = reduce(value0, values1[i1]);
      }
    }

    return values;
  };

  var descending = function (a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };

  var number = function (x) {
    return x === null ? NaN : +x;
  };

  var variance = function (values, valueof) {
    var n = values.length,
        m = 0,
        i = -1,
        mean = 0,
        value,
        delta,
        sum = 0;

    if (valueof == null) {
      while (++i < n) {
        if (!isNaN(value = number(values[i]))) {
          delta = value - mean;
          mean += delta / ++m;
          sum += delta * (value - mean);
        }
      }
    } else {
      while (++i < n) {
        if (!isNaN(value = number(valueof(values[i], i, values)))) {
          delta = value - mean;
          mean += delta / ++m;
          sum += delta * (value - mean);
        }
      }
    }

    if (m > 1) return sum / (m - 1);
  };

  var deviation = function (array, f) {
    var v = variance(array, f);
    return v ? Math.sqrt(v) : v;
  };

  var extent = function (values, valueof) {
    var n = values.length,
        i = -1,
        value,
        min,
        max;

    if (valueof == null) {
      while (++i < n) {
        // Find the first comparable value.
        if ((value = values[i]) != null && value >= value) {
          min = max = value;
          while (++i < n) {
            // Compare the remaining values.
            if ((value = values[i]) != null) {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
    } else {
      while (++i < n) {
        // Find the first comparable value.
        if ((value = valueof(values[i], i, values)) != null && value >= value) {
          min = max = value;
          while (++i < n) {
            // Compare the remaining values.
            if ((value = valueof(values[i], i, values)) != null) {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
    }

    return [min, max];
  };

  var array = Array.prototype;

  var slice = array.slice;
  var map = array.map;

  var constant = function (x) {
    return function () {
      return x;
    };
  };

  var identity = function (x) {
    return x;
  };

  var sequence = function (start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

    var i = -1,
        n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
        range = new Array(n);

    while (++i < n) {
      range[i] = start + i * step;
    }

    return range;
  };

  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);

  var ticks = function (start, stop, count) {
    var reverse = stop < start,
        i = -1,
        n,
        ticks,
        step;

    if (reverse) n = start, start = stop, stop = n;

    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
      start = Math.ceil(start / step);
      stop = Math.floor(stop / step);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      while (++i < n) ticks[i] = (start + i) * step;
    } else {
      start = Math.floor(start * step);
      stop = Math.ceil(stop * step);
      ticks = new Array(n = Math.ceil(start - stop + 1));
      while (++i < n) ticks[i] = (start - i) / step;
    }

    if (reverse) ticks.reverse();

    return ticks;
  };

  function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }

  function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
  }

  var sturges = function (values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
  };

  var histogram = function () {
    var value = identity,
        domain = extent,
        threshold = sturges;

    function histogram(data) {
      var i,
          n = data.length,
          x,
          values = new Array(n);

      for (i = 0; i < n; ++i) {
        values[i] = value(data[i], i, data);
      }

      var xz = domain(values),
          x0 = xz[0],
          x1 = xz[1],
          tz = threshold(values, x0, x1);

      // Convert number of thresholds into uniform thresholds.
      if (!Array.isArray(tz)) {
        tz = tickStep(x0, x1, tz);
        tz = sequence(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
      }

      // Remove any thresholds outside the domain.
      var m = tz.length;
      while (tz[0] <= x0) tz.shift(), --m;
      while (tz[m - 1] > x1) tz.pop(), --m;

      var bins = new Array(m + 1),
          bin;

      // Initialize bins.
      for (i = 0; i <= m; ++i) {
        bin = bins[i] = [];
        bin.x0 = i > 0 ? tz[i - 1] : x0;
        bin.x1 = i < m ? tz[i] : x1;
      }

      // Assign data to bins by value, ignoring any outside the domain.
      for (i = 0; i < n; ++i) {
        x = values[i];
        if (x0 <= x && x <= x1) {
          bins[bisectRight(tz, x, 0, m)].push(data[i]);
        }
      }

      return bins;
    }

    histogram.value = function (_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
    };

    histogram.domain = function (_) {
      return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
    };

    histogram.thresholds = function (_) {
      return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
    };

    return histogram;
  };

  var threshold = function (values, p, valueof) {
    if (valueof == null) valueof = number;
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n,
        i = (n - 1) * p,
        i0 = Math.floor(i),
        value0 = +valueof(values[i0], i0, values),
        value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  };

  var freedmanDiaconis = function (values, min, max) {
    values = map.call(values, number).sort(ascending);
    return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));
  };

  var scott = function (values, min, max) {
    return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
  };

  var max = function (values, valueof) {
    var n = values.length,
        i = -1,
        value,
        max;

    if (valueof == null) {
      while (++i < n) {
        // Find the first comparable value.
        if ((value = values[i]) != null && value >= value) {
          max = value;
          while (++i < n) {
            // Compare the remaining values.
            if ((value = values[i]) != null && value > max) {
              max = value;
            }
          }
        }
      }
    } else {
      while (++i < n) {
        // Find the first comparable value.
        if ((value = valueof(values[i], i, values)) != null && value >= value) {
          max = value;
          while (++i < n) {
            // Compare the remaining values.
            if ((value = valueof(values[i], i, values)) != null && value > max) {
              max = value;
            }
          }
        }
      }
    }

    return max;
  };

  var mean = function (values, valueof) {
    var n = values.length,
        m = n,
        i = -1,
        value,
        sum = 0;

    if (valueof == null) {
      while (++i < n) {
        if (!isNaN(value = number(values[i]))) sum += value;else --m;
      }
    } else {
      while (++i < n) {
        if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;else --m;
      }
    }

    if (m) return sum / m;
  };

  var median = function (values, valueof) {
    var n = values.length,
        i = -1,
        value,
        numbers = [];

    if (valueof == null) {
      while (++i < n) {
        if (!isNaN(value = number(values[i]))) {
          numbers.push(value);
        }
      }
    } else {
      while (++i < n) {
        if (!isNaN(value = number(valueof(values[i], i, values)))) {
          numbers.push(value);
        }
      }
    }

    return threshold(numbers.sort(ascending), 0.5);
  };

  var merge = function (arrays) {
    var n = arrays.length,
        m,
        i = -1,
        j = 0,
        merged,
        array;

    while (++i < n) j += arrays[i].length;
    merged = new Array(j);

    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }

    return merged;
  };

  var min = function (values, valueof) {
    var n = values.length,
        i = -1,
        value,
        min;

    if (valueof == null) {
      while (++i < n) {
        // Find the first comparable value.
        if ((value = values[i]) != null && value >= value) {
          min = value;
          while (++i < n) {
            // Compare the remaining values.
            if ((value = values[i]) != null && min > value) {
              min = value;
            }
          }
        }
      }
    } else {
      while (++i < n) {
        // Find the first comparable value.
        if ((value = valueof(values[i], i, values)) != null && value >= value) {
          min = value;
          while (++i < n) {
            // Compare the remaining values.
            if ((value = valueof(values[i], i, values)) != null && min > value) {
              min = value;
            }
          }
        }
      }
    }

    return min;
  };

  var permute = function (array, indexes) {
    var i = indexes.length,
        permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };

  var scan = function (values, compare) {
    if (!(n = values.length)) return;
    var n,
        i = 0,
        j = 0,
        xi,
        xj = values[j];

    if (compare == null) compare = ascending;

    while (++i < n) {
      if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
        xj = xi, j = i;
      }
    }

    if (compare(xj, xj) === 0) return j;
  };

  var shuffle = function (array, i0, i1) {
    var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
        t,
        i;

    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }

    return array;
  };

  var sum = function (values, valueof) {
    var n = values.length,
        i = -1,
        value,
        sum = 0;

    if (valueof == null) {
      while (++i < n) {
        if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
      }
    } else {
      while (++i < n) {
        if (value = +valueof(values[i], i, values)) sum += value;
      }
    }

    return sum;
  };

  var transpose = function (matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };

  function length(d) {
    return d.length;
  }

  var zip = function () {
    return transpose(arguments);
  };

  var slice$1 = Array.prototype.slice;

  var identity$1 = function (x) {
    return x;
  };

  var top = 1;
  var right = 2;
  var bottom = 3;
  var left = 4;
  var epsilon = 1e-6;

  function translateX(x) {
    return "translate(" + (x + 0.5) + ",0)";
  }

  function translateY(y) {
    return "translate(0," + (y + 0.5) + ")";
  }

  function center(scale) {
    var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
    if (scale.round()) offset = Math.round(offset);
    return function (d) {
      return scale(d) + offset;
    };
  }

  function entering() {
    return !this.__axis;
  }

  function axis(orient, scale) {
    var tickArguments = [],
        tickValues = null,
        tickFormat = null,
        tickSizeInner = 6,
        tickSizeOuter = 6,
        tickPadding = 3,
        k = orient === top || orient === left ? -1 : 1,
        x = orient === left || orient === right ? "x" : "y",
        transform = orient === top || orient === bottom ? translateX : translateY;

    function axis(context) {
      var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
          format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1 : tickFormat,
          spacing = Math.max(tickSizeInner, 0) + tickPadding,
          range = scale.range(),
          range0 = range[0] + 0.5,
          range1 = range[range.length - 1] + 0.5,
          position = (scale.bandwidth ? center : identity$1)(scale.copy()),
          selection = context.selection ? context.selection() : context,
          path = selection.selectAll(".domain").data([null]),
          tick = selection.selectAll(".tick").data(values, scale).order(),
          tickExit = tick.exit(),
          tickEnter = tick.enter().append("g").attr("class", "tick"),
          line = tick.select("line"),
          text = tick.select("text");

      path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "#000"));

      tick = tick.merge(tickEnter);

      line = line.merge(tickEnter.append("line").attr("stroke", "#000").attr(x + "2", k * tickSizeInner));

      text = text.merge(tickEnter.append("text").attr("fill", "#000").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

      if (context !== selection) {
        path = path.transition(context);
        tick = tick.transition(context);
        line = line.transition(context);
        text = text.transition(context);

        tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function (d) {
          return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform");
        });

        tickEnter.attr("opacity", epsilon).attr("transform", function (d) {
          var p = this.parentNode.__axis;return transform(p && isFinite(p = p(d)) ? p : position(d));
        });
      }

      tickExit.remove();

      path.attr("d", orient === left || orient == right ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

      tick.attr("opacity", 1).attr("transform", function (d) {
        return transform(position(d));
      });

      line.attr(x + "2", k * tickSizeInner);

      text.attr(x, k * spacing).text(format);

      selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

      selection.each(function () {
        this.__axis = position;
      });
    }

    axis.scale = function (_) {
      return arguments.length ? (scale = _, axis) : scale;
    };

    axis.ticks = function () {
      return tickArguments = slice$1.call(arguments), axis;
    };

    axis.tickArguments = function (_) {
      return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
    };

    axis.tickValues = function (_) {
      return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();
    };

    axis.tickFormat = function (_) {
      return arguments.length ? (tickFormat = _, axis) : tickFormat;
    };

    axis.tickSize = function (_) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
    };

    axis.tickSizeInner = function (_) {
      return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
    };

    axis.tickSizeOuter = function (_) {
      return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
    };

    axis.tickPadding = function (_) {
      return arguments.length ? (tickPadding = +_, axis) : tickPadding;
    };

    return axis;
  }

  function axisTop(scale) {
    return axis(top, scale);
  }

  function axisRight(scale) {
    return axis(right, scale);
  }

  function axisBottom(scale) {
    return axis(bottom, scale);
  }

  function axisLeft(scale) {
    return axis(left, scale);
  }

  var noop = { value: function () {} };

  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch(_);
  }

  function Dispatch(_) {
    this._ = _;
  }

  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function (t) {
      var name = "",
          i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return { type: t, name: name };
    });
  }

  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function (typename, callback) {
      var _ = this._,
          T = parseTypenames(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
      }

      return this;
    },
    copy: function () {
      var copy = {},
          _ = this._;
      for (var t in _) copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call: function (type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function (type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };

  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({ name: name, value: callback });
    return type;
  }

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  var namespace = function (name) {
    var prefix = name += "",
        i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
  };

  function creatorInherit(name) {
    return function () {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function () {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  var creator = function (name) {
    var fullname = namespace(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  };

  var nextId = 0;

  function local$1() {
    return new Local();
  }

  function Local() {
    this._ = "@" + (++nextId).toString(36);
  }

  Local.prototype = local$1.prototype = {
    constructor: Local,
    get: function (node) {
      var id = this._;
      while (!(id in node)) if (!(node = node.parentNode)) return;
      return node[id];
    },
    set: function (node, value) {
      return node[this._] = value;
    },
    remove: function (node) {
      return this._ in node && delete node[this._];
    },
    toString: function () {
      return this._;
    }
  };

  var matcher = function (selector) {
    return function () {
      return this.matches(selector);
    };
  };

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!element.matches) {
      var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;
      matcher = function (selector) {
        return function () {
          return vendorMatches.call(this, selector);
        };
      };
    }
  }

  var matcher$1 = matcher;

  var filterEvents = {};

  exports.event = null;

  if (typeof document !== "undefined") {
    var element$1 = document.documentElement;
    if (!("onmouseenter" in element$1)) {
      filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function (event) {
      var related = event.relatedTarget;
      if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function (event1) {
      var event0 = exports.event; // Events can be reentrant (e.g., focus).
      exports.event = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        exports.event = event0;
      }
    };
  }

  function parseTypenames$1(typenames) {
    return typenames.trim().split(/^|\s+/).map(function (t) {
      var name = "",
          i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      return { type: t, name: name };
    });
  }

  function onRemove(typename) {
    return function () {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) on.length = i;else delete this.__on;
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function (d, i, group) {
      var on = this.__on,
          o,
          listener = wrap(value, i, group);
      if (on) for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, capture);
      o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
      if (!on) this.__on = [o];else on.push(o);
    };
  }

  var selection_on = function (typename, value, capture) {
    var typenames = parseTypenames$1(typename + ""),
        i,
        n = typenames.length,
        t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) capture = false;
    for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
    return this;
  };

  function customEvent(event1, listener, that, args) {
    var event0 = exports.event;
    event1.sourceEvent = exports.event;
    exports.event = event1;
    try {
      return listener.apply(that, args);
    } finally {
      exports.event = event0;
    }
  }

  var sourceEvent = function () {
    var current = exports.event,
        source;
    while (source = current.sourceEvent) current = source;
    return current;
  };

  var point = function (node, event) {
    var svg = node.ownerSVGElement || node;

    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }

    var rect = node.getBoundingClientRect();
    return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
  };

  var mouse = function (node) {
    var event = sourceEvent();
    if (event.changedTouches) event = event.changedTouches[0];
    return point(node, event);
  };

  function none() {}

  var selector = function (selector) {
    return selector == null ? none : function () {
      return this.querySelector(selector);
    };
  };

  var selection_select = function (select) {
    if (typeof select !== "function") select = selector(select);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  };

  function empty$1() {
    return [];
  }

  var selectorAll = function (selector) {
    return selector == null ? empty$1 : function () {
      return this.querySelectorAll(selector);
    };
  };

  var selection_selectAll = function (select) {
    if (typeof select !== "function") select = selectorAll(select);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  };

  var selection_filter = function (match) {
    if (typeof match !== "function") match = matcher$1(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  };

  var sparse = function (update) {
    return new Array(update.length);
  };

  var selection_enter = function () {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  };

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function (child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function (child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function (selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function (selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  var constant$1 = function (x) {
    return function () {
      return x;
    };
  };

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
        exit[i] = node;
      }
    }
  }

  var selection_data = function (value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function (d) {
        data[++j] = d;
      });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") value = constant$1(value);

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength);
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  };

  var selection_exit = function () {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  };

  var selection_merge = function (selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  };

  var selection_order = function () {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }

    return this;
  };

  var selection_sort = function (compare) {
    if (!compare) compare = ascending$1;

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  };

  function ascending$1(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  var selection_call = function () {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  };

  var selection_nodes = function () {
    var nodes = new Array(this.size()),
        i = -1;
    this.each(function () {
      nodes[++i] = this;
    });
    return nodes;
  };

  var selection_node = function () {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) return node;
      }
    }

    return null;
  };

  var selection_size = function () {
    var size = 0;
    this.each(function () {
      ++size;
    });
    return size;
  };

  var selection_empty = function () {
    return !this.node();
  };

  var selection_each = function (callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) callback.call(node, node.__data__, i, group);
      }
    }

    return this;
  };

  function attrRemove(name) {
    return function () {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function () {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function () {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function () {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function () {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
    };
  }

  function attrFunctionNS(fullname, value) {
    return function () {
      var v = value.apply(this, arguments);
      if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }

  var selection_attr = function (name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }

    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  };

  var defaultView = function (node) {
    return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node
    node.document && node // node is a Window
    || node.defaultView; // node is a Document
  };

  function styleRemove(name) {
    return function () {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function () {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function () {
      var v = value.apply(this, arguments);
      if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
    };
  }

  var selection_style = function (name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  };

  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function () {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function () {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function () {
      var v = value.apply(this, arguments);
      if (v == null) delete this[name];else this[name] = v;
    };
  }

  var selection_property = function (name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  };

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function (name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function (name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function (name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node),
        i = -1,
        n = names.length;
    while (++i < n) list.add(names[i]);
  }

  function classedRemove(node, names) {
    var list = classList(node),
        i = -1,
        n = names.length;
    while (++i < n) list.remove(names[i]);
  }

  function classedTrue(names) {
    return function () {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function () {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function () {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  var selection_classed = function (name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()),
          i = -1,
          n = names.length;
      while (++i < n) if (!list.contains(names[i])) return false;
      return true;
    }

    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  };

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function () {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function () {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  var selection_text = function (value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  };

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function () {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function () {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  var selection_html = function (value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  };

  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }

  var selection_raise = function () {
    return this.each(raise);
  };

  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }

  var selection_lower = function () {
    return this.each(lower);
  };

  var selection_append = function (name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function () {
      return this.appendChild(create.apply(this, arguments));
    });
  };

  function constantNull() {
    return null;
  }

  var selection_insert = function (name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function () {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  };

  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }

  var selection_remove = function () {
    return this.each(remove);
  };

  var selection_datum = function (value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  };

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function () {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function () {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  var selection_dispatch = function (type, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
  };

  var root = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  var select = function (selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  };

  var selectAll = function (selector) {
    return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([selector == null ? [] : selector], root);
  };

  var touch = function (node, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

    for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return point(node, touch);
      }
    }

    return null;
  };

  var touches = function (node, touches) {
    if (touches == null) touches = sourceEvent().touches;

    for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
      points[i] = point(node, touches[i]);
    }

    return points;
  };

  function nopropagation() {
    exports.event.stopImmediatePropagation();
  }

  var noevent = function () {
    exports.event.preventDefault();
    exports.event.stopImmediatePropagation();
  };

  var dragDisable = function (view) {
    var root = view.document.documentElement,
        selection$$1 = select(view).on("dragstart.drag", noevent, true);
    if ("onselectstart" in root) {
      selection$$1.on("selectstart.drag", noevent, true);
    } else {
      root.__noselect = root.style.MozUserSelect;
      root.style.MozUserSelect = "none";
    }
  };

  function yesdrag(view, noclick) {
    var root = view.document.documentElement,
        selection$$1 = select(view).on("dragstart.drag", null);
    if (noclick) {
      selection$$1.on("click.drag", noevent, true);
      setTimeout(function () {
        selection$$1.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root) {
      selection$$1.on("selectstart.drag", null);
    } else {
      root.style.MozUserSelect = root.__noselect;
      delete root.__noselect;
    }
  }

  var constant$2 = function (x) {
    return function () {
      return x;
    };
  };

  function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
    this.target = target;
    this.type = type;
    this.subject = subject;
    this.identifier = id;
    this.active = active;
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this._ = dispatch;
  }

  DragEvent.prototype.on = function () {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };

  // Ignore right-click, since that should open the context menu.
  function defaultFilter$1() {
    return !exports.event.button;
  }

  function defaultContainer() {
    return this.parentNode;
  }

  function defaultSubject(d) {
    return d == null ? { x: exports.event.x, y: exports.event.y } : d;
  }

  var drag = function () {
    var filter = defaultFilter$1,
        container = defaultContainer,
        subject = defaultSubject,
        gestures = {},
        listeners = dispatch("start", "drag", "end"),
        active = 0,
        mousedownx,
        mousedowny,
        mousemoving,
        touchending,
        clickDistance2 = 0;

    function drag(selection$$1) {
      selection$$1.on("mousedown.drag", mousedowned).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }

    function mousedowned() {
      if (touchending || !filter.apply(this, arguments)) return;
      var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
      if (!gesture) return;
      select(exports.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
      dragDisable(exports.event.view);
      nopropagation();
      mousemoving = false;
      mousedownx = exports.event.clientX;
      mousedowny = exports.event.clientY;
      gesture("start");
    }

    function mousemoved() {
      noevent();
      if (!mousemoving) {
        var dx = exports.event.clientX - mousedownx,
            dy = exports.event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag");
    }

    function mouseupped() {
      select(exports.event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(exports.event.view, mousemoving);
      noevent();
      gestures.mouse("end");
    }

    function touchstarted() {
      if (!filter.apply(this, arguments)) return;
      var touches$$1 = exports.event.changedTouches,
          c = container.apply(this, arguments),
          n = touches$$1.length,
          i,
          gesture;

      for (i = 0; i < n; ++i) {
        if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {
          nopropagation();
          gesture("start");
        }
      }
    }

    function touchmoved() {
      var touches$$1 = exports.event.changedTouches,
          n = touches$$1.length,
          i,
          gesture;

      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches$$1[i].identifier]) {
          noevent();
          gesture("drag");
        }
      }
    }

    function touchended() {
      var touches$$1 = exports.event.changedTouches,
          n = touches$$1.length,
          i,
          gesture;

      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function () {
        touchending = null;
      }, 500); // Ghost clicks are delayed!
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches$$1[i].identifier]) {
          nopropagation();
          gesture("end");
        }
      }
    }

    function beforestart(id, container, point, that, args) {
      var p = point(container, id),
          s,
          dx,
          dy,
          sublisteners = listeners.copy();

      if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
        if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;
        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;
        return true;
      })) return;

      return function gesture(type) {
        var p0 = p,
            n;
        switch (type) {
          case "start":
            gestures[id] = gesture, n = active++;break;
          case "end":
            delete gestures[id], --active; // nobreak
          case "drag":
            p = point(container, id), n = active;break;
        }
        customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
      };
    }

    drag.filter = function (_) {
      return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
    };

    drag.container = function (_) {
      return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
    };

    drag.subject = function (_) {
      return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
    };

    drag.on = function () {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag : value;
    };

    drag.clickDistance = function (_) {
      return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
    };

    return drag;
  };

  var define = function (constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  };

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex3 = /^#([0-9a-f]{3})$/;
  var reHex6 = /^#([0-9a-f]{6})$/;
  var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
  var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
  var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
  var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
  var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
  var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    displayable: function () {
      return this.rgb().displayable();
    },
    toString: function () {
      return this.rgb() + "";
    }
  });

  function color(format) {
    var m;
    format = (format + "").trim().toLowerCase();
    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
    ) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
    : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
    : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
    : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
    : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
    : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
    : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
    : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb, extend(Color, {
    brighter: function (k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function (k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function () {
      return this;
    },
    displayable: function () {
      return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
    },
    toString: function () {
      var a = this.opacity;a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function (k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function (k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function () {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    displayable: function () {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  var deg2rad = Math.PI / 180;
  var rad2deg = 180 / Math.PI;

  var Kn = 18;
  var Xn = 0.950470;
  var Yn = 1;
  var Zn = 1.088830;
  var t0 = 4 / 29;
  var t1 = 6 / 29;
  var t2 = 3 * t1 * t1;
  var t3 = t1 * t1 * t1;

  function labConvert(o) {
    if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl) {
      var h = o.h * deg2rad;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var b = rgb2xyz(o.r),
        a = rgb2xyz(o.g),
        l = rgb2xyz(o.b),
        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
        z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
  }

  function lab(l, a, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
  }

  function Lab(l, a, b, opacity) {
    this.l = +l;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Lab, lab, extend(Color, {
    brighter: function (k) {
      return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker: function (k) {
      return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb: function () {
      var y = (this.l + 16) / 116,
          x = isNaN(this.a) ? y : y + this.a / 500,
          z = isNaN(this.b) ? y : y - this.b / 200;
      y = Yn * lab2xyz(y);
      x = Xn * lab2xyz(x);
      z = Zn * lab2xyz(z);
      return new Rgb(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
    }
  }));

  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
  }

  function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
  }

  function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }

  function rgb2xyz(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }

  function hclConvert(o) {
    if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab)) o = labConvert(o);
    var h = Math.atan2(o.b, o.a) * rad2deg;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }

  function hcl(h, c, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
  }

  function Hcl(h, c, l, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hcl, hcl, extend(Color, {
    brighter: function (k) {
      return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
    },
    darker: function (k) {
      return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
    },
    rgb: function () {
      return labConvert(this).rgb();
    }
  }));

  var A = -0.14861;
  var B = +1.78277;
  var C = -0.29227;
  var D = -0.90649;
  var E = +1.97294;
  var ED = E * D;
  var EB = E * B;
  var BC_DA = B * C - D * A;

  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
        bl = b - l,
        k = (E * (g - l) - C * bl) / D,
        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
        // NaN if l=0 or l=1
    h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
  }

  function cubehelix(h, s, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
  }

  function Cubehelix(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Cubehelix, cubehelix, extend(Color, {
    brighter: function (k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function (k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function () {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
          l = +this.l,
          a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
          cosh = Math.cos(h),
          sinh = Math.sin(h);
      return new Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
    }
  }));

  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1,
        t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }

  var basis$1 = function (values) {
    var n = values.length - 1;
    return function (t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
          v1 = values[i],
          v2 = values[i + 1],
          v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
          v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  };

  var basisClosed = function (values) {
    var n = values.length;
    return function (t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
          v0 = values[(i + n - 1) % n],
          v1 = values[i % n],
          v2 = values[(i + 1) % n],
          v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  };

  var constant$3 = function (x) {
    return function () {
      return x;
    };
  };

  function linear(a, d) {
    return function (t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
      return Math.pow(a + t * b, y);
    };
  }

  function hue(a, b) {
    var d = b - a;
    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function (a, b) {
      return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);
  }

  var interpolateRgb = function rgbGamma(y) {
    var color$$1 = gamma(y);

    function rgb$$1(start, end) {
      var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
          g = color$$1(start.g, end.g),
          b = color$$1(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function (t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb$$1.gamma = rgbGamma;

    return rgb$$1;
  }(1);

  function rgbSpline(spline) {
    return function (colors) {
      var n = colors.length,
          r = new Array(n),
          g = new Array(n),
          b = new Array(n),
          i,
          color$$1;
      for (i = 0; i < n; ++i) {
        color$$1 = rgb(colors[i]);
        r[i] = color$$1.r || 0;
        g[i] = color$$1.g || 0;
        b[i] = color$$1.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color$$1.opacity = 1;
      return function (t) {
        color$$1.r = r(t);
        color$$1.g = g(t);
        color$$1.b = b(t);
        return color$$1 + "";
      };
    };
  }

  var rgbBasis = rgbSpline(basis$1);
  var rgbBasisClosed = rgbSpline(basisClosed);

  var array$1 = function (a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(nb),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function (t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  };

  var date = function (a, b) {
    var d = new Date();
    return a = +a, b -= a, function (t) {
      return d.setTime(a + b * t), d;
    };
  };

  var reinterpolate = function (a, b) {
    return a = +a, b -= a, function (t) {
      return a + b * t;
    };
  };

  var object = function (a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolateValue(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function (t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  };

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");

  function zero(b) {
    return function () {
      return b;
    };
  }

  function one(b) {
    return function (t) {
      return b(t) + "";
    };
  }

  var interpolateString = function (a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0,
        // scan index for next number in b
    am,
        // current match in a
    bm,
        // current match in b
    bs,
        // string preceding current number in b, if any
    i = -1,
        // index in s
    s = [],
        // string constants and placeholders
    q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else {
        // interpolate non-matching numbers
        s[++i] = null;
        q.push({ i: i, x: reinterpolate(am, bm) });
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  };

  var interpolateValue = function (a, b) {
    var t = typeof b,
        c;
    return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? reinterpolate : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date : Array.isArray(b) ? array$1 : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : reinterpolate)(a, b);
  };

  var interpolateRound = function (a, b) {
    return a = +a, b -= a, function (t) {
      return Math.round(a + b * t);
    };
  };

  var degrees = 180 / Math.PI;

  var identity$2 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };

  var decompose = function (a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX: scaleX,
      scaleY: scaleY
    };
  };

  var cssNode;
  var cssRoot;
  var cssView;
  var svgNode;

  function parseCss(value) {
    if (value === "none") return identity$2;
    if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
    cssNode.style.transform = value;
    value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
    cssRoot.removeChild(cssNode);
    value = value.slice(7, -1).split(",");
    return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
  }

  function parseSvg(value) {
    if (value == null) return identity$2;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  function interpolateTransform(parse, pxComma, pxParen, degParen) {

    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }

    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i - 4, x: reinterpolate(xa, xb) }, { i: i - 2, x: reinterpolate(ya, yb) });
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }

    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path
        q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: reinterpolate(a, b) });
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }

    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: reinterpolate(a, b) });
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }

    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({ i: i - 4, x: reinterpolate(xa, xb) }, { i: i - 2, x: reinterpolate(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }

    return function (a, b) {
      var s = [],
          // string constants and placeholders
      q = []; // number interpolators
      a = parse(a), b = parse(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null; // gc
      return function (t) {
        var i = -1,
            n = q.length,
            o;
        while (++i < n) s[(o = q[i]).i] = o.x(t);
        return s.join("");
      };
    };
  }

  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  var rho = Math.SQRT2;
  var rho2 = 2;
  var rho4 = 4;
  var epsilon2 = 1e-12;

  function cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }

  function sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }

  function tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  var interpolateZoom = function (p0, p1) {
    var ux0 = p0[0],
        uy0 = p0[1],
        w0 = p0[2],
        ux1 = p1[0],
        uy1 = p1[1],
        w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function (t) {
        return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
      };
    }

    // General case.
    else {
        var d1 = Math.sqrt(d2),
            b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
            b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
            r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
            r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S = (r1 - r0) / rho;
        i = function (t) {
          var s = t * S,
              coshr0 = cosh(r0),
              u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
          return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
        };
      }

    i.duration = S * 1000;

    return i;
  };

  function hsl$1(hue$$1) {
    return function (start, end) {
      var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    };
  }

  var hsl$2 = hsl$1(hue);
  var hslLong = hsl$1(nogamma);

  function lab$1(start, end) {
    var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
        a = nogamma(start.a, end.a),
        b = nogamma(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function (t) {
      start.l = l(t);
      start.a = a(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  function hcl$1(hue$$1) {
    return function (start, end) {
      var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),
          c = nogamma(start.c, end.c),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.c = c(t);
        start.l = l(t);
        start.opacity = opacity(t);
        return start + "";
      };
    };
  }

  var hcl$2 = hcl$1(hue);
  var hclLong = hcl$1(nogamma);

  function cubehelix$1(hue$$1) {
    return function cubehelixGamma(y) {
      y = +y;

      function cubehelix$$1(start, end) {
        var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(Math.pow(t, y));
          start.opacity = opacity(t);
          return start + "";
        };
      }

      cubehelix$$1.gamma = cubehelixGamma;

      return cubehelix$$1;
    }(1);
  }

  var cubehelix$2 = cubehelix$1(hue);
  var cubehelixLong = cubehelix$1(nogamma);

  var quantize = function (interpolator, n) {
    var samples = new Array(n);
    for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
    return samples;
  };

  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1000;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof requestAnimationFrame === "function" ? requestAnimationFrame : function (f) {
    setTimeout(f, 17);
  };

  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }

  function clearNow() {
    clockNow = 0;
  }

  function Timer() {
    this._call = this._time = this._next = null;
  }

  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function (callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function () {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };

  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }

  function timerFlush() {
    now(); // Get the current time, if not already set.
    ++frame; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead,
        e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
      t = t._next;
    }
    --frame;
  }

  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }

  function poke() {
    var now = clock.now(),
        delay = now - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
  }

  function nap() {
    var t0,
        t1 = taskHead,
        t2,
        time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }

  function sleep(time) {
    if (frame) return; // Soonest alarm already set, or will be.
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, delay);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clockNow, interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  var timeout$1 = function (callback, delay, time) {
    var t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart(function (elapsed) {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  };

  var interval$1 = function (callback, delay, time) {
    var t = new Timer(),
        total = delay;
    if (delay == null) return t.restart(callback, delay, time), t;
    delay = +delay, time = time == null ? now() : +time;
    t.restart(function tick(elapsed) {
      elapsed += total;
      t.restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
    return t;
  };

  var emptyOn = dispatch("start", "end", "interrupt");
  var emptyTween = [];

  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;

  var schedule = function (node, name, id, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};else if (id in schedules) return;
    create(node, id, {
      name: name,
      index: index, // For context during callback.
      group: group, // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  };

  function init(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error("too late");
    return schedule;
  }

  function set$1(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error("too late");
    return schedule;
  }

  function get$1(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id])) throw new Error("too late");
    return schedule;
  }

  function create(node, id, self) {
    var schedules = node.__transition,
        tween;

    // Initialize the self timer when the transition is created.
    // Note the actual delay is not known until the first callback!
    schedules[id] = self;
    self.timer = timer(schedule, 0, self.time);

    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start, self.delay, self.time);

      // If the elapsed delay is less than our first sleep, start immediately.
      if (self.delay <= elapsed) start(elapsed - self.delay);
    }

    function start(elapsed) {
      var i, j, n, o;

      // If the state is not SCHEDULED, then we previously errored on start.
      if (self.state !== SCHEDULED) return stop();

      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self.name) continue;

        // While this element already has a starting transition during this frame,
        // defer starting an interrupting transition until that transition has a
        // chance to tick (and possibly end); see d3/d3-transition#54!
        if (o.state === STARTED) return timeout$1(start);

        // Interrupt the active transition, if any.
        // Dispatch the interrupt event.
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }

        // Cancel any pre-empted transitions. No interrupt event is dispatched
        // because the cancelled transitions never started. Note that this also
        // removes this transition from the pending list!
        else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            delete schedules[i];
          }
      }

      // Defer the first tick to end of the current frame; see d3/d3#1576.
      // Note the transition may be canceled after start and before the first tick!
      // Note this must be scheduled before the start event; see d3/d3-transition#16!
      // Assuming this is successful, subsequent callbacks go straight to tick.
      timeout$1(function () {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });

      // Dispatch the start event.
      // Note this must be done before the tween are initialized.
      self.state = STARTING;
      self.on.call("start", node, node.__data__, self.index, self.group);
      if (self.state !== STARTING) return; // interrupted
      self.state = STARTED;

      // Initialize the tween, deleting null tween.
      tween = new Array(n = self.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }

    function tick(elapsed) {
      var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
          i = -1,
          n = tween.length;

      while (++i < n) {
        tween[i].call(null, t);
      }

      // Dispatch the end event.
      if (self.state === ENDING) {
        self.on.call("end", node, node.__data__, self.index, self.group);
        stop();
      }
    }

    function stop() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id];
      for (var i in schedules) return; // eslint-disable-line no-unused-vars
      delete node.__transition;
    }
  }

  var interrupt = function (node, name) {
    var schedules = node.__transition,
        schedule,
        active,
        empty = true,
        i;

    if (!schedules) return;

    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name) {
        empty = false;continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }

    if (empty) delete node.__transition;
  };

  var selection_interrupt = function (name) {
    return this.each(function () {
      interrupt(this, name);
    });
  };

  function tweenRemove(id, name) {
    var tween0, tween1;
    return function () {
      var schedule = set$1(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }

      schedule.tween = tween1;
    };
  }

  function tweenFunction(id, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error();
    return function () {
      var schedule = set$1(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = { name: name, value: value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n) tween1.push(t);
      }

      schedule.tween = tween1;
    };
  }

  var transition_tween = function (name, value) {
    var id = this._id;

    name += "";

    if (arguments.length < 2) {
      var tween = get$1(this.node(), id).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name) {
          return t.value;
        }
      }
      return null;
    }

    return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
  };

  function tweenValue(transition, name, value) {
    var id = transition._id;

    transition.each(function () {
      var schedule = set$1(this, id);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });

    return function (node) {
      return get$1(node, id).value[name];
    };
  }

  var interpolate$$1 = function (a, b) {
    var c;
    return (typeof b === "number" ? reinterpolate : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
  };

  function attrRemove$1(name) {
    return function () {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS$1(fullname) {
    return function () {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant$1(name, interpolate$$1, value1) {
    var value00, interpolate0;
    return function () {
      var value0 = this.getAttribute(name);
      return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value1);
    };
  }

  function attrConstantNS$1(fullname, interpolate$$1, value1) {
    var value00, interpolate0;
    return function () {
      var value0 = this.getAttributeNS(fullname.space, fullname.local);
      return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value1);
    };
  }

  function attrFunction$1(name, interpolate$$1, value) {
    var value00, value10, interpolate0;
    return function () {
      var value0,
          value1 = value(this);
      if (value1 == null) return void this.removeAttribute(name);
      value0 = this.getAttribute(name);
      return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
    };
  }

  function attrFunctionNS$1(fullname, interpolate$$1, value) {
    var value00, value10, interpolate0;
    return function () {
      var value0,
          value1 = value(this);
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      value0 = this.getAttributeNS(fullname.space, fullname.local);
      return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
    };
  }

  var transition_attr = function (name, value) {
    var fullname = namespace(name),
        i = fullname === "transform" ? interpolateTransformSvg : interpolate$$1;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname) : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + ""));
  };

  function attrTweenNS(fullname, value) {
    function tween() {
      var node = this,
          i = value.apply(node, arguments);
      return i && function (t) {
        node.setAttributeNS(fullname.space, fullname.local, i(t));
      };
    }
    tween._value = value;
    return tween;
  }

  function attrTween(name, value) {
    function tween() {
      var node = this,
          i = value.apply(node, arguments);
      return i && function (t) {
        node.setAttribute(name, i(t));
      };
    }
    tween._value = value;
    return tween;
  }

  var transition_attrTween = function (name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    var fullname = namespace(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  };

  function delayFunction(id, value) {
    return function () {
      init(this, id).delay = +value.apply(this, arguments);
    };
  }

  function delayConstant(id, value) {
    return value = +value, function () {
      init(this, id).delay = value;
    };
  }

  var transition_delay = function (value) {
    var id = this._id;

    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : get$1(this.node(), id).delay;
  };

  function durationFunction(id, value) {
    return function () {
      set$1(this, id).duration = +value.apply(this, arguments);
    };
  }

  function durationConstant(id, value) {
    return value = +value, function () {
      set$1(this, id).duration = value;
    };
  }

  var transition_duration = function (value) {
    var id = this._id;

    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : get$1(this.node(), id).duration;
  };

  function easeConstant(id, value) {
    if (typeof value !== "function") throw new Error();
    return function () {
      set$1(this, id).ease = value;
    };
  }

  var transition_ease = function (value) {
    var id = this._id;

    return arguments.length ? this.each(easeConstant(id, value)) : get$1(this.node(), id).ease;
  };

  var transition_filter = function (match) {
    if (typeof match !== "function") match = matcher$1(match);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Transition(subgroups, this._parents, this._name, this._id);
  };

  var transition_merge = function (transition) {
    if (transition._id !== this._id) throw new Error();

    for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Transition(merges, this._parents, this._name, this._id);
  };

  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function (t) {
      var i = t.indexOf(".");
      if (i >= 0) t = t.slice(0, i);
      return !t || t === "start";
    });
  }

  function onFunction(id, name, listener) {
    var on0,
        on1,
        sit = start(name) ? init : set$1;
    return function () {
      var schedule = sit(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

      schedule.on = on1;
    };
  }

  var transition_on = function (name, listener) {
    var id = this._id;

    return arguments.length < 2 ? get$1(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
  };

  function removeFunction(id) {
    return function () {
      var parent = this.parentNode;
      for (var i in this.__transition) if (+i !== id) return;
      if (parent) parent.removeChild(this);
    };
  }

  var transition_remove = function () {
    return this.on("end.remove", removeFunction(this._id));
  };

  var transition_select = function (select$$1) {
    var name = this._name,
        id = this._id;

    if (typeof select$$1 !== "function") select$$1 = selector(select$$1);

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
        }
      }
    }

    return new Transition(subgroups, this._parents, name, id);
  };

  var transition_selectAll = function (select$$1) {
    var name = this._name,
        id = this._id;

    if (typeof select$$1 !== "function") select$$1 = selectorAll(select$$1);

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
            if (child = children[k]) {
              schedule(child, name, id, k, children, inherit);
            }
          }
          subgroups.push(children);
          parents.push(node);
        }
      }
    }

    return new Transition(subgroups, parents, name, id);
  };

  var Selection$1 = selection.prototype.constructor;

  var transition_selection = function () {
    return new Selection$1(this._groups, this._parents);
  };

  function styleRemove$1(name, interpolate$$2) {
    var value00, value10, interpolate0;
    return function () {
      var value0 = styleValue(this, name),
          value1 = (this.style.removeProperty(name), styleValue(this, name));
      return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$2(value00 = value0, value10 = value1);
    };
  }

  function styleRemoveEnd(name) {
    return function () {
      this.style.removeProperty(name);
    };
  }

  function styleConstant$1(name, interpolate$$2, value1) {
    var value00, interpolate0;
    return function () {
      var value0 = styleValue(this, name);
      return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate$$2(value00 = value0, value1);
    };
  }

  function styleFunction$1(name, interpolate$$2, value) {
    var value00, value10, interpolate0;
    return function () {
      var value0 = styleValue(this, name),
          value1 = value(this);
      if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
      return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$2(value00 = value0, value10 = value1);
    };
  }

  var transition_style = function (name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$$1;
    return value == null ? this.styleTween(name, styleRemove$1(name, i)).on("end.style." + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === "function" ? styleFunction$1(name, i, tweenValue(this, "style." + name, value)) : styleConstant$1(name, i, value + ""), priority);
  };

  function styleTween(name, value, priority) {
    function tween() {
      var node = this,
          i = value.apply(node, arguments);
      return i && function (t) {
        node.style.setProperty(name, i(t), priority);
      };
    }
    tween._value = value;
    return tween;
  }

  var transition_styleTween = function (name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  };

  function textConstant$1(value) {
    return function () {
      this.textContent = value;
    };
  }

  function textFunction$1(value) {
    return function () {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }

  var transition_text = function (value) {
    return this.tween("text", typeof value === "function" ? textFunction$1(tweenValue(this, "text", value)) : textConstant$1(value == null ? "" : value + ""));
  };

  var transition_transition = function () {
    var name = this._name,
        id0 = this._id,
        id1 = newId();

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          var inherit = get$1(node, id0);
          schedule(node, name, id1, i, group, {
            time: inherit.time + inherit.delay + inherit.duration,
            delay: 0,
            duration: inherit.duration,
            ease: inherit.ease
          });
        }
      }
    }

    return new Transition(groups, this._parents, name, id1);
  };

  var id = 0;

  function Transition(groups, parents, name, id) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id;
  }

  function transition(name) {
    return selection().transition(name);
  }

  function newId() {
    return ++id;
  }

  var selection_prototype = selection.prototype;

  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease
  };

  function linear$1(t) {
    return +t;
  }

  function quadIn(t) {
    return t * t;
  }

  function quadOut(t) {
    return t * (2 - t);
  }

  function quadInOut(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
  }

  function cubicIn(t) {
    return t * t * t;
  }

  function cubicOut(t) {
    return --t * t * t + 1;
  }

  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  var exponent = 3;

  var polyIn = function custom(e) {
    e = +e;

    function polyIn(t) {
      return Math.pow(t, e);
    }

    polyIn.exponent = custom;

    return polyIn;
  }(exponent);

  var polyOut = function custom(e) {
    e = +e;

    function polyOut(t) {
      return 1 - Math.pow(1 - t, e);
    }

    polyOut.exponent = custom;

    return polyOut;
  }(exponent);

  var polyInOut = function custom(e) {
    e = +e;

    function polyInOut(t) {
      return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
    }

    polyInOut.exponent = custom;

    return polyInOut;
  }(exponent);

  var pi = Math.PI;
  var halfPi = pi / 2;

  function sinIn(t) {
    return 1 - Math.cos(t * halfPi);
  }

  function sinOut(t) {
    return Math.sin(t * halfPi);
  }

  function sinInOut(t) {
    return (1 - Math.cos(pi * t)) / 2;
  }

  function expIn(t) {
    return Math.pow(2, 10 * t - 10);
  }

  function expOut(t) {
    return 1 - Math.pow(2, -10 * t);
  }

  function expInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
  }

  function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
  }

  function circleOut(t) {
    return Math.sqrt(1 - --t * t);
  }

  function circleInOut(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
  }

  var b1 = 4 / 11;
  var b2 = 6 / 11;
  var b3 = 8 / 11;
  var b4 = 3 / 4;
  var b5 = 9 / 11;
  var b6 = 10 / 11;
  var b7 = 15 / 16;
  var b8 = 21 / 22;
  var b9 = 63 / 64;
  var b0 = 1 / b1 / b1;

  function bounceIn(t) {
    return 1 - bounceOut(1 - t);
  }

  function bounceOut(t) {
    return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
  }

  function bounceInOut(t) {
    return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
  }

  var overshoot = 1.70158;

  var backIn = function custom(s) {
    s = +s;

    function backIn(t) {
      return t * t * ((s + 1) * t - s);
    }

    backIn.overshoot = custom;

    return backIn;
  }(overshoot);

  var backOut = function custom(s) {
    s = +s;

    function backOut(t) {
      return --t * t * ((s + 1) * t + s) + 1;
    }

    backOut.overshoot = custom;

    return backOut;
  }(overshoot);

  var backInOut = function custom(s) {
    s = +s;

    function backInOut(t) {
      return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
    }

    backInOut.overshoot = custom;

    return backInOut;
  }(overshoot);

  var tau = 2 * Math.PI;
  var amplitude = 1;
  var period = 0.3;

  var elasticIn = function custom(a, p) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

    function elasticIn(t) {
      return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
    }

    elasticIn.amplitude = function (a) {
      return custom(a, p * tau);
    };
    elasticIn.period = function (p) {
      return custom(a, p);
    };

    return elasticIn;
  }(amplitude, period);

  var elasticOut = function custom(a, p) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

    function elasticOut(t) {
      return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
    }

    elasticOut.amplitude = function (a) {
      return custom(a, p * tau);
    };
    elasticOut.period = function (p) {
      return custom(a, p);
    };

    return elasticOut;
  }(amplitude, period);

  var elasticInOut = function custom(a, p) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

    function elasticInOut(t) {
      return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
    }

    elasticInOut.amplitude = function (a) {
      return custom(a, p * tau);
    };
    elasticInOut.period = function (p) {
      return custom(a, p);
    };

    return elasticInOut;
  }(amplitude, period);

  var defaultTiming = {
    time: null, // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };

  function inherit(node, id) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id])) {
      if (!(node = node.parentNode)) {
        return defaultTiming.time = now(), defaultTiming;
      }
    }
    return timing;
  }

  var selection_transition = function (name) {
    var id, timing;

    if (name instanceof Transition) {
      id = name._id, name = name._name;
    } else {
      id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          schedule(node, name, id, i, group, timing || inherit(node, id));
        }
      }
    }

    return new Transition(groups, this._parents, name, id);
  };

  selection.prototype.interrupt = selection_interrupt;
  selection.prototype.transition = selection_transition;

  var root$1 = [null];

  var active = function (node, name) {
    var schedules = node.__transition,
        schedule,
        i;

    if (schedules) {
      name = name == null ? null : name + "";
      for (i in schedules) {
        if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
          return new Transition([[node]], root$1, name, +i);
        }
      }
    }

    return null;
  };

  var constant$4 = function (x) {
    return function () {
      return x;
    };
  };

  var BrushEvent = function (target, type, selection) {
    this.target = target;
    this.type = type;
    this.selection = selection;
  };

  function nopropagation$1() {
    exports.event.stopImmediatePropagation();
  }

  var noevent$1 = function () {
    exports.event.preventDefault();
    exports.event.stopImmediatePropagation();
  };

  var MODE_DRAG = { name: "drag" };
  var MODE_SPACE = { name: "space" };
  var MODE_HANDLE = { name: "handle" };
  var MODE_CENTER = { name: "center" };

  var X = {
    name: "x",
    handles: ["e", "w"].map(type),
    input: function (x, e) {
      return x && [[x[0], e[0][1]], [x[1], e[1][1]]];
    },
    output: function (xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };

  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function (y, e) {
      return y && [[e[0][0], y[0]], [e[1][0], y[1]]];
    },
    output: function (xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };

  var XY = {
    name: "xy",
    handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
    input: function (xy) {
      return xy;
    },
    output: function (xy) {
      return xy;
    }
  };

  var cursors = {
    overlay: "crosshair",
    selection: "move",
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };

  var flipX = {
    e: "w",
    w: "e",
    nw: "ne",
    ne: "nw",
    se: "sw",
    sw: "se"
  };

  var flipY = {
    n: "s",
    s: "n",
    nw: "sw",
    ne: "se",
    se: "ne",
    sw: "nw"
  };

  var signsX = {
    overlay: +1,
    selection: +1,
    n: null,
    e: +1,
    s: null,
    w: -1,
    nw: -1,
    ne: +1,
    se: +1,
    sw: -1
  };

  var signsY = {
    overlay: +1,
    selection: +1,
    n: -1,
    e: null,
    s: +1,
    w: null,
    nw: -1,
    ne: -1,
    se: +1,
    sw: +1
  };

  function type(t) {
    return { type: t };
  }

  // Ignore right-click, since that should open the context menu.
  function defaultFilter() {
    return !exports.event.button;
  }

  function defaultExtent() {
    var svg = this.ownerSVGElement || this;
    return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
  }

  // Like d3.local, but with the name “__brush” rather than auto-generated.
  function local$$1(node) {
    while (!node.__brush) if (!(node = node.parentNode)) return;
    return node.__brush;
  }

  function empty(extent) {
    return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
  }

  function brushSelection(node) {
    var state = node.__brush;
    return state ? state.dim.output(state.selection) : null;
  }

  function brushX() {
    return brush$1(X);
  }

  function brushY() {
    return brush$1(Y);
  }

  var brush = function () {
    return brush$1(XY);
  };

  function brush$1(dim) {
    var extent = defaultExtent,
        filter = defaultFilter,
        listeners = dispatch(brush, "start", "brush", "end"),
        handleSize = 6,
        touchending;

    function brush(group) {
      var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);

      overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function () {
        var extent = local$$1(this).extent;
        select(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
      });

      group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");

      var handle = group.selectAll(".handle").data(dim.handles, function (d) {
        return d.type;
      });

      handle.exit().remove();

      handle.enter().append("rect").attr("class", function (d) {
        return "handle handle--" + d.type;
      }).attr("cursor", function (d) {
        return cursors[d.type];
      });

      group.each(redraw).attr("fill", "none").attr("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush touchstart.brush", started);
    }

    brush.move = function (group, selection$$1) {
      if (group.selection) {
        group.on("start.brush", function () {
          emitter(this, arguments).beforestart().start();
        }).on("interrupt.brush end.brush", function () {
          emitter(this, arguments).end();
        }).tween("brush", function () {
          var that = this,
              state = that.__brush,
              emit = emitter(that, arguments),
              selection0 = state.selection,
              selection1 = dim.input(typeof selection$$1 === "function" ? selection$$1.apply(this, arguments) : selection$$1, state.extent),
              i = interpolateValue(selection0, selection1);

          function tween(t) {
            state.selection = t === 1 && empty(selection1) ? null : i(t);
            redraw.call(that);
            emit.brush();
          }

          return selection0 && selection1 ? tween : tween(1);
        });
      } else {
        group.each(function () {
          var that = this,
              args = arguments,
              state = that.__brush,
              selection1 = dim.input(typeof selection$$1 === "function" ? selection$$1.apply(that, args) : selection$$1, state.extent),
              emit = emitter(that, args).beforestart();

          interrupt(that);
          state.selection = selection1 == null || empty(selection1) ? null : selection1;
          redraw.call(that);
          emit.start().brush().end();
        });
      }
    };

    function redraw() {
      var group = select(this),
          selection$$1 = local$$1(this).selection;

      if (selection$$1) {
        group.selectAll(".selection").style("display", null).attr("x", selection$$1[0][0]).attr("y", selection$$1[0][1]).attr("width", selection$$1[1][0] - selection$$1[0][0]).attr("height", selection$$1[1][1] - selection$$1[0][1]);

        group.selectAll(".handle").style("display", null).attr("x", function (d) {
          return d.type[d.type.length - 1] === "e" ? selection$$1[1][0] - handleSize / 2 : selection$$1[0][0] - handleSize / 2;
        }).attr("y", function (d) {
          return d.type[0] === "s" ? selection$$1[1][1] - handleSize / 2 : selection$$1[0][1] - handleSize / 2;
        }).attr("width", function (d) {
          return d.type === "n" || d.type === "s" ? selection$$1[1][0] - selection$$1[0][0] + handleSize : handleSize;
        }).attr("height", function (d) {
          return d.type === "e" || d.type === "w" ? selection$$1[1][1] - selection$$1[0][1] + handleSize : handleSize;
        });
      } else {
        group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
      }
    }

    function emitter(that, args) {
      return that.__brush.emitter || new Emitter(that, args);
    }

    function Emitter(that, args) {
      this.that = that;
      this.args = args;
      this.state = that.__brush;
      this.active = 0;
    }

    Emitter.prototype = {
      beforestart: function () {
        if (++this.active === 1) this.state.emitter = this, this.starting = true;
        return this;
      },
      start: function () {
        if (this.starting) this.starting = false, this.emit("start");
        return this;
      },
      brush: function () {
        this.emit("brush");
        return this;
      },
      end: function () {
        if (--this.active === 0) delete this.state.emitter, this.emit("end");
        return this;
      },
      emit: function (type) {
        customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
      }
    };

    function started() {
      if (exports.event.touches) {
        if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$1();
      } else if (touchending) return;
      if (!filter.apply(this, arguments)) return;

      var that = this,
          type = exports.event.target.__data__.type,
          mode = (exports.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : exports.event.altKey ? MODE_CENTER : MODE_HANDLE,
          signX = dim === Y ? null : signsX[type],
          signY = dim === X ? null : signsY[type],
          state = local$$1(that),
          extent = state.extent,
          selection$$1 = state.selection,
          W = extent[0][0],
          w0,
          w1,
          N = extent[0][1],
          n0,
          n1,
          E = extent[1][0],
          e0,
          e1,
          S = extent[1][1],
          s0,
          s1,
          dx,
          dy,
          moving,
          shifting = signX && signY && exports.event.shiftKey,
          lockX,
          lockY,
          point0 = mouse(that),
          point = point0,
          emit = emitter(that, arguments).beforestart();

      if (type === "overlay") {
        state.selection = selection$$1 = [[w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]], [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]];
      } else {
        w0 = selection$$1[0][0];
        n0 = selection$$1[0][1];
        e0 = selection$$1[1][0];
        s0 = selection$$1[1][1];
      }

      w1 = w0;
      n1 = n0;
      e1 = e0;
      s1 = s0;

      var group = select(that).attr("pointer-events", "none");

      var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);

      if (exports.event.touches) {
        group.on("touchmove.brush", moved, true).on("touchend.brush touchcancel.brush", ended, true);
      } else {
        var view = select(exports.event.view).on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);

        dragDisable(exports.event.view);
      }

      nopropagation$1();
      interrupt(that);
      redraw.call(that);
      emit.start();

      function moved() {
        var point1 = mouse(that);
        if (shifting && !lockX && !lockY) {
          if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;else lockX = true;
        }
        point = point1;
        moving = true;
        noevent$1();
        move();
      }

      function move() {
        var t;

        dx = point[0] - point0[0];
        dy = point[1] - point0[1];

        switch (mode) {
          case MODE_SPACE:
          case MODE_DRAG:
            {
              if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
          case MODE_HANDLE:
            {
              if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
              if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              break;
            }
          case MODE_CENTER:
            {
              if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
              if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
              break;
            }
        }

        if (e1 < w1) {
          signX *= -1;
          t = w0, w0 = e0, e0 = t;
          t = w1, w1 = e1, e1 = t;
          if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
        }

        if (s1 < n1) {
          signY *= -1;
          t = n0, n0 = s0, s0 = t;
          t = n1, n1 = s1, s1 = t;
          if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
        }

        if (state.selection) selection$$1 = state.selection; // May be set by brush.move!
        if (lockX) w1 = selection$$1[0][0], e1 = selection$$1[1][0];
        if (lockY) n1 = selection$$1[0][1], s1 = selection$$1[1][1];

        if (selection$$1[0][0] !== w1 || selection$$1[0][1] !== n1 || selection$$1[1][0] !== e1 || selection$$1[1][1] !== s1) {
          state.selection = [[w1, n1], [e1, s1]];
          redraw.call(that);
          emit.brush();
        }
      }

      function ended() {
        nopropagation$1();
        if (exports.event.touches) {
          if (exports.event.touches.length) return;
          if (touchending) clearTimeout(touchending);
          touchending = setTimeout(function () {
            touchending = null;
          }, 500); // Ghost clicks are delayed!
          group.on("touchmove.brush touchend.brush touchcancel.brush", null);
        } else {
          yesdrag(exports.event.view, moving);
          view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
        }
        group.attr("pointer-events", "all");
        overlay.attr("cursor", cursors.overlay);
        if (state.selection) selection$$1 = state.selection; // May be set by brush.move (on start)!
        if (empty(selection$$1)) state.selection = null, redraw.call(that);
        emit.end();
      }

      function keydowned() {
        switch (exports.event.keyCode) {
          case 16:
            {
              // SHIFT
              shifting = signX && signY;
              break;
            }
          case 18:
            {
              // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move();
              }
              break;
            }
          case 32:
            {
              // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx;else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy;else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move();
              }
              break;
            }
          default:
            return;
        }
        noevent$1();
      }

      function keyupped() {
        switch (exports.event.keyCode) {
          case 16:
            {
              // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move();
              }
              break;
            }
          case 18:
            {
              // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move();
              }
              break;
            }
          case 32:
            {
              // SPACE
              if (mode === MODE_SPACE) {
                if (exports.event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move();
              }
              break;
            }
          default:
            return;
        }
        noevent$1();
      }
    }

    function initialize() {
      var state = this.__brush || { selection: null };
      state.extent = extent.apply(this, arguments);
      state.dim = dim;
      return state;
    }

    brush.extent = function (_) {
      return arguments.length ? (extent = typeof _ === "function" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
    };

    brush.filter = function (_) {
      return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), brush) : filter;
    };

    brush.handleSize = function (_) {
      return arguments.length ? (handleSize = +_, brush) : handleSize;
    };

    brush.on = function () {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? brush : value;
    };

    return brush;
  }

  var cos = Math.cos;
  var sin = Math.sin;
  var pi$1 = Math.PI;
  var halfPi$1 = pi$1 / 2;
  var tau$1 = pi$1 * 2;
  var max$1 = Math.max;

  function compareValue(compare) {
    return function (a, b) {
      return compare(a.source.value + a.target.value, b.source.value + b.target.value);
    };
  }

  var chord = function () {
    var padAngle = 0,
        sortGroups = null,
        sortSubgroups = null,
        sortChords = null;

    function chord(matrix) {
      var n = matrix.length,
          groupSums = [],
          groupIndex = sequence(n),
          subgroupIndex = [],
          chords = [],
          groups = chords.groups = new Array(n),
          subgroups = new Array(n * n),
          k,
          x,
          x0,
          dx,
          i,
          j;

      // Compute the sum.
      k = 0, i = -1;while (++i < n) {
        x = 0, j = -1;while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(sequence(n));
        k += x;
      }

      // Sort groups…
      if (sortGroups) groupIndex.sort(function (a, b) {
        return sortGroups(groupSums[a], groupSums[b]);
      });

      // Sort subgroups…
      if (sortSubgroups) subgroupIndex.forEach(function (d, i) {
        d.sort(function (a, b) {
          return sortSubgroups(matrix[i][a], matrix[i][b]);
        });
      });

      // Convert the sum to scaling factor for [0, 2pi].
      // TODO Allow start and end angle to be specified?
      // TODO Allow padding to be specified as percentage?
      k = max$1(0, tau$1 - padAngle * n) / k;
      dx = k ? padAngle : tau$1 / n;

      // Compute the start and end angle for each group and subgroup.
      // Note: Opera has a bug reordering object literal properties!
      x = 0, i = -1;while (++i < n) {
        x0 = x, j = -1;while (++j < n) {
          var di = groupIndex[i],
              dj = subgroupIndex[di][j],
              v = matrix[di][dj],
              a0 = x,
              a1 = x += v * k;
          subgroups[dj * n + di] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += dx;
      }

      // Generate chords for each (non-empty) subgroup-subgroup link.
      i = -1;while (++i < n) {
        j = i - 1;while (++j < n) {
          var source = subgroups[j * n + i],
              target = subgroups[i * n + j];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? { source: target, target: source } : { source: source, target: target });
          }
        }
      }

      return sortChords ? chords.sort(sortChords) : chords;
    }

    chord.padAngle = function (_) {
      return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
    };

    chord.sortGroups = function (_) {
      return arguments.length ? (sortGroups = _, chord) : sortGroups;
    };

    chord.sortSubgroups = function (_) {
      return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
    };

    chord.sortChords = function (_) {
      return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
    };

    return chord;
  };

  var slice$2 = Array.prototype.slice;

  var constant$5 = function (x) {
    return function () {
      return x;
    };
  };

  var pi$2 = Math.PI;
  var tau$2 = 2 * pi$2;
  var epsilon$1 = 1e-6;
  var tauEpsilon = tau$2 - epsilon$1;

  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path() {
    return new Path();
  }

  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function (x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function () {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function (x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function (x1, y1, x, y) {
      this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function (x1, y1, x2, y2, x, y) {
      this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function (x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon$1)) {}

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
            this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
          }

          // Otherwise, draw an arc!
          else {
              var x20 = x2 - x0,
                  y20 = y2 - y0,
                  l21_2 = x21 * x21 + y21 * y21,
                  l20_2 = x20 * x20 + y20 * y20,
                  l21 = Math.sqrt(l21_2),
                  l01 = Math.sqrt(l01_2),
                  l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                  t01 = l / l01,
                  t21 = l / l21;

              // If the start tangent is not coincident with (x0,y0), line to.
              if (Math.abs(t01 - 1) > epsilon$1) {
                this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
              }

              this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
            }
    },
    arc: function (x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
          this._ += "L" + x0 + "," + y0;
        }

      // Is this arc empty? We’re done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau$2 + tau$2;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon$1) {
          this._ += "A" + r + "," + r + ",0," + +(da >= pi$2) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
    },
    rect: function (x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
    },
    toString: function () {
      return this._;
    }
  };

  function defaultSource(d) {
    return d.source;
  }

  function defaultTarget(d) {
    return d.target;
  }

  function defaultRadius(d) {
    return d.radius;
  }

  function defaultStartAngle(d) {
    return d.startAngle;
  }

  function defaultEndAngle(d) {
    return d.endAngle;
  }

  var ribbon = function () {
    var source = defaultSource,
        target = defaultTarget,
        radius = defaultRadius,
        startAngle = defaultStartAngle,
        endAngle = defaultEndAngle,
        context = null;

    function ribbon() {
      var buffer,
          argv = slice$2.call(arguments),
          s = source.apply(this, argv),
          t = target.apply(this, argv),
          sr = +radius.apply(this, (argv[0] = s, argv)),
          sa0 = startAngle.apply(this, argv) - halfPi$1,
          sa1 = endAngle.apply(this, argv) - halfPi$1,
          sx0 = sr * cos(sa0),
          sy0 = sr * sin(sa0),
          tr = +radius.apply(this, (argv[0] = t, argv)),
          ta0 = startAngle.apply(this, argv) - halfPi$1,
          ta1 = endAngle.apply(this, argv) - halfPi$1;

      if (!context) context = buffer = path();

      context.moveTo(sx0, sy0);
      context.arc(0, 0, sr, sa0, sa1);
      if (sa0 !== ta0 || sa1 !== ta1) {
        // TODO sr !== tr?
        context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
        context.arc(0, 0, tr, ta0, ta1);
      }
      context.quadraticCurveTo(0, 0, sx0, sy0);
      context.closePath();

      if (buffer) return context = null, buffer + "" || null;
    }

    ribbon.radius = function (_) {
      return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : radius;
    };

    ribbon.startAngle = function (_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : startAngle;
    };

    ribbon.endAngle = function (_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : endAngle;
    };

    ribbon.source = function (_) {
      return arguments.length ? (source = _, ribbon) : source;
    };

    ribbon.target = function (_) {
      return arguments.length ? (target = _, ribbon) : target;
    };

    ribbon.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
    };

    return ribbon;
  };

  var prefix = "$";

  function Map() {}

  Map.prototype = map$1.prototype = {
    constructor: Map,
    has: function (key) {
      return prefix + key in this;
    },
    get: function (key) {
      return this[prefix + key];
    },
    set: function (key, value) {
      this[prefix + key] = value;
      return this;
    },
    remove: function (key) {
      var property = prefix + key;
      return property in this && delete this[property];
    },
    clear: function () {
      for (var property in this) if (property[0] === prefix) delete this[property];
    },
    keys: function () {
      var keys = [];
      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
      return keys;
    },
    values: function () {
      var values = [];
      for (var property in this) if (property[0] === prefix) values.push(this[property]);
      return values;
    },
    entries: function () {
      var entries = [];
      for (var property in this) if (property[0] === prefix) entries.push({ key: property.slice(1), value: this[property] });
      return entries;
    },
    size: function () {
      var size = 0;
      for (var property in this) if (property[0] === prefix) ++size;
      return size;
    },
    empty: function () {
      for (var property in this) if (property[0] === prefix) return false;
      return true;
    },
    each: function (f) {
      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  };

  function map$1(object, f) {
    var map = new Map();

    // Copy constructor.
    if (object instanceof Map) object.each(function (value, key) {
      map.set(key, value);
    });

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
        var i = -1,
            n = object.length,
            o;

        if (f == null) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f(o = object[i], i, object), o);
      }

      // Convert object to map.
      else if (object) for (var key in object) map.set(key, object[key]);

    return map;
  }

  var nest = function () {
    var keys = [],
        sortKeys = [],
        sortValues,
        rollup,
        nest;

    function apply(array, depth, createResult, setResult) {
      if (depth >= keys.length) return rollup != null ? rollup(array) : sortValues != null ? array.sort(sortValues) : array;

      var i = -1,
          n = array.length,
          key = keys[depth++],
          keyValue,
          value,
          valuesByKey = map$1(),
          values,
          result = createResult();

      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
          values.push(value);
        } else {
          valuesByKey.set(keyValue, [value]);
        }
      }

      valuesByKey.each(function (values, key) {
        setResult(result, key, apply(values, depth, createResult, setResult));
      });

      return result;
    }

    function entries(map, depth) {
      if (++depth > keys.length) return map;
      var array,
          sortKey = sortKeys[depth - 1];
      if (rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
        array.push({ key: k, values: entries(v, depth) });
      });
      return sortKey != null ? array.sort(function (a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }

    return nest = {
      object: function (array) {
        return apply(array, 0, createObject, setObject);
      },
      map: function (array) {
        return apply(array, 0, createMap, setMap);
      },
      entries: function (array) {
        return entries(apply(array, 0, createMap, setMap), 0);
      },
      key: function (d) {
        keys.push(d);return nest;
      },
      sortKeys: function (order) {
        sortKeys[keys.length - 1] = order;return nest;
      },
      sortValues: function (order) {
        sortValues = order;return nest;
      },
      rollup: function (f) {
        rollup = f;return nest;
      }
    };
  };

  function createObject() {
    return {};
  }

  function setObject(object, key, value) {
    object[key] = value;
  }

  function createMap() {
    return map$1();
  }

  function setMap(map, key, value) {
    map.set(key, value);
  }

  function Set() {}

  var proto = map$1.prototype;

  Set.prototype = set$2.prototype = {
    constructor: Set,
    has: proto.has,
    add: function (value) {
      value += "";
      this[prefix + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  function set$2(object, f) {
    var set = new Set();

    // Copy constructor.
    if (object instanceof Set) object.each(function (value) {
      set.add(value);
    });

    // Otherwise, assume it’s an array.
    else if (object) {
        var i = -1,
            n = object.length;
        if (f == null) while (++i < n) set.add(object[i]);else while (++i < n) set.add(f(object[i], i, object));
      }

    return set;
  }

  var keys = function (map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };

  var values = function (map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };

  var entries = function (map) {
    var entries = [];
    for (var key in map) entries.push({ key: key, value: map[key] });
    return entries;
  };

  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function (name, i) {
      return JSON.stringify(name) + ": d[" + i + "]";
    }).join(",") + "}");
  }

  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function (row, i) {
      return f(object(row), i, columns);
    };
  }

  // Compute unique columns in order of discovery.
  function inferColumns(rows) {
    var columnSet = Object.create(null),
        columns = [];

    rows.forEach(function (row) {
      for (var column in row) {
        if (!(column in columnSet)) {
          columns.push(columnSet[column] = column);
        }
      }
    });

    return columns;
  }

  var dsv = function (delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
        delimiterCode = delimiter.charCodeAt(0);

    function parse(text, f) {
      var convert,
          columns,
          rows = parseRows(text, function (row, i) {
        if (convert) return convert(row, i - 1);
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns;
      return rows;
    }

    function parseRows(text, f) {
      var EOL = {},
          // sentinel value for end-of-line
      EOF = {},
          // sentinel value for end-of-file
      rows = [],
          // output rows
      N = text.length,
          I = 0,
          // current character index
      n = 0,
          // the current line number
      t,
          // the current token
      eol; // is the current token followed by EOL?

      function token() {
        if (I >= N) return EOF; // special case: end of file
        if (eol) return eol = false, EOL; // special case: end of line

        // special case: quotes
        var j = I,
            c;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, "\"");
        }

        // common case: find next delimiter or newline
        while (I < N) {
          var k = 1;
          c = text.charCodeAt(I++);
          if (c === 10) eol = true; // \n
          else if (c === 13) {
              eol = true;if (text.charCodeAt(I) === 10) ++I, ++k;
            } // \r|\r\n
            else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }

        // special case: last token before EOF
        return text.slice(j);
      }

      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }

      return rows;
    }

    function format(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
        return columns.map(function (column) {
          return formatValue(row[column]);
        }).join(delimiter);
      })).join("\n");
    }

    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }

    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }

    function formatValue(text) {
      return text == null ? "" : reFormat.test(text += "") ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
    }

    return {
      parse: parse,
      parseRows: parseRows,
      format: format,
      formatRows: formatRows
    };
  };

  var csv = dsv(",");

  var csvParse = csv.parse;
  var csvParseRows = csv.parseRows;
  var csvFormat = csv.format;
  var csvFormatRows = csv.formatRows;

  var tsv = dsv("\t");

  var tsvParse = tsv.parse;
  var tsvParseRows = tsv.parseRows;
  var tsvFormat = tsv.format;
  var tsvFormatRows = tsv.formatRows;

  var center$1 = function (x, y) {
    var nodes;

    if (x == null) x = 0;
    if (y == null) y = 0;

    function force() {
      var i,
          n = nodes.length,
          node,
          sx = 0,
          sy = 0;

      for (i = 0; i < n; ++i) {
        node = nodes[i], sx += node.x, sy += node.y;
      }

      for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
        node = nodes[i], node.x -= sx, node.y -= sy;
      }
    }

    force.initialize = function (_) {
      nodes = _;
    };

    force.x = function (_) {
      return arguments.length ? (x = +_, force) : x;
    };

    force.y = function (_) {
      return arguments.length ? (y = +_, force) : y;
    };

    return force;
  };

  var constant$6 = function (x) {
    return function () {
      return x;
    };
  };

  var jiggle = function () {
    return (Math.random() - 0.5) * 1e-6;
  };

  var tree_add = function (d) {
    var x = +this._x.call(null, d),
        y = +this._y.call(null, d);
    return add(this.cover(x, y), x, y, d);
  };

  function add(tree, x, y, d) {
    if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

    var parent,
        node = tree._root,
        leaf = { data: d },
        x0 = tree._x0,
        y0 = tree._y0,
        x1 = tree._x1,
        y1 = tree._y1,
        xm,
        ym,
        xp,
        yp,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) return tree._root = leaf, tree;

    // Find the existing leaf for the new point, or add it.
    while (node.length) {
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
    }

    // Is the new point is exactly coincident with the existing point?
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

    // Otherwise, split the leaf node until the old and new point are separated.
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
    return parent[j] = node, parent[i] = leaf, tree;
  }

  function addAll(data) {
    var d,
        i,
        n = data.length,
        x,
        y,
        xz = new Array(n),
        yz = new Array(n),
        x0 = Infinity,
        y0 = Infinity,
        x1 = -Infinity,
        y1 = -Infinity;

    // Compute the points and their extent.
    for (i = 0; i < n; ++i) {
      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
      xz[i] = x;
      yz[i] = y;
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }

    // If there were no (valid) points, inherit the existing extent.
    if (x1 < x0) x0 = this._x0, x1 = this._x1;
    if (y1 < y0) y0 = this._y0, y1 = this._y1;

    // Expand the tree to cover the new points.
    this.cover(x0, y0).cover(x1, y1);

    // Add the new points.
    for (i = 0; i < n; ++i) {
      add(this, xz[i], yz[i], data[i]);
    }

    return this;
  }

  var tree_cover = function (x, y) {
    if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

    var x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1;

    // If the quadtree has no extent, initialize them.
    // Integer extent are necessary so that if we later double the extent,
    // the existing quadrant boundaries don’t change due to floating point error!
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x)) + 1;
      y1 = (y0 = Math.floor(y)) + 1;
    }

    // Otherwise, double repeatedly to cover.
    else if (x0 > x || x > x1 || y0 > y || y > y1) {
        var z = x1 - x0,
            node = this._root,
            parent,
            i;

        switch (i = (y < (y0 + y1) / 2) << 1 | x < (x0 + x1) / 2) {
          case 0:
            {
              do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1));
              break;
            }
          case 1:
            {
              do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1));
              break;
            }
          case 2:
            {
              do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y));
              break;
            }
          case 3:
            {
              do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y));
              break;
            }
        }

        if (this._root && this._root.length) this._root = node;
      }

      // If the quadtree covers the point already, just return.
      else return this;

    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  };

  var tree_data = function () {
    var data = [];
    this.visit(function (node) {
      if (!node.length) do data.push(node.data); while (node = node.next);
    });
    return data;
  };

  var tree_extent = function (_) {
    return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
  };

  var Quad = function (node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  };

  var tree_find = function (x, y, radius) {
    var data,
        x0 = this._x0,
        y0 = this._y0,
        x1,
        y1,
        x2,
        y2,
        x3 = this._x1,
        y3 = this._y1,
        quads = [],
        node = this._root,
        q,
        i;

    if (node) quads.push(new Quad(node, x0, y0, x3, y3));
    if (radius == null) radius = Infinity;else {
      x0 = x - radius, y0 = y - radius;
      x3 = x + radius, y3 = y + radius;
      radius *= radius;
    }

    while (q = quads.pop()) {

      // Stop searching if this quadrant can’t contain a closer node.
      if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue;

      // Bisect the current quadrant.
      if (node.length) {
        var xm = (x1 + x2) / 2,
            ym = (y1 + y2) / 2;

        quads.push(new Quad(node[3], xm, ym, x2, y2), new Quad(node[2], x1, ym, xm, y2), new Quad(node[1], xm, y1, x2, ym), new Quad(node[0], x1, y1, xm, ym));

        // Visit the closest quadrant first.
        if (i = (y >= ym) << 1 | x >= xm) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      }

      // Visit this point. (Visiting coincident points isn’t necessary!)
      else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
    }

    return data;
  };

  var tree_remove = function (d) {
    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

    var parent,
        node = this._root,
        retainer,
        previous,
        next,
        x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1,
        x,
        y,
        xm,
        ym,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) return this;

    // Find the leaf node for the point.
    // While descending, also retain the deepest parent with a non-removed sibling.
    if (node.length) while (true) {
      if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
      if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
      if (!node.length) break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
    }

    // Find the point to remove.
    while (node.data !== d) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;

    // If there are multiple coincident points, remove just the point.
    if (previous) return next ? previous.next = next : delete previous.next, this;

    // If this is the root point, remove it.
    if (!parent) return this._root = next, this;

    // Remove this leaf.
    next ? parent[i] = next : delete parent[i];

    // If the parent now contains exactly one leaf, collapse superfluous parents.
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j] = node;else this._root = node;
    }

    return this;
  };

  function removeAll(data) {
    for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
    return this;
  }

  var tree_root = function () {
    return this._root;
  };

  var tree_size = function () {
    var size = 0;
    this.visit(function (node) {
      if (!node.length) do ++size; while (node = node.next);
    });
    return size;
  };

  var tree_visit = function (callback) {
    var quads = [],
        q,
        node = this._root,
        child,
        x0,
        y0,
        x1,
        y1;
    if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2,
            ym = (y0 + y1) / 2;
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      }
    }
    return this;
  };

  var tree_visitAfter = function (callback) {
    var quads = [],
        next = [],
        q;
    if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child,
            x0 = q.x0,
            y0 = q.y0,
            x1 = q.x1,
            y1 = q.y1,
            xm = (x0 + x1) / 2,
            ym = (y0 + y1) / 2;
        if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
        if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
        if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  };

  function defaultX(d) {
    return d[0];
  }

  var tree_x = function (_) {
    return arguments.length ? (this._x = _, this) : this._x;
  };

  function defaultY(d) {
    return d[1];
  }

  var tree_y = function (_) {
    return arguments.length ? (this._y = _, this) : this._y;
  };

  function quadtree(nodes, x, y) {
    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }

  function Quadtree(x, y, x0, y0, x1, y1) {
    this._x = x;
    this._y = y;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = undefined;
  }

  function leaf_copy(leaf) {
    var copy = { data: leaf.data },
        next = copy;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy;
  }

  var treeProto = quadtree.prototype = Quadtree.prototype;

  treeProto.copy = function () {
    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
        node = this._root,
        nodes,
        child;

    if (!node) return copy;

    if (!node.length) return copy._root = leaf_copy(node), copy;

    nodes = [{ source: node, target: copy._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });else node.target[i] = leaf_copy(child);
        }
      }
    }

    return copy;
  };

  treeProto.add = tree_add;
  treeProto.addAll = addAll;
  treeProto.cover = tree_cover;
  treeProto.data = tree_data;
  treeProto.extent = tree_extent;
  treeProto.find = tree_find;
  treeProto.remove = tree_remove;
  treeProto.removeAll = removeAll;
  treeProto.root = tree_root;
  treeProto.size = tree_size;
  treeProto.visit = tree_visit;
  treeProto.visitAfter = tree_visitAfter;
  treeProto.x = tree_x;
  treeProto.y = tree_y;

  function x(d) {
    return d.x + d.vx;
  }

  function y(d) {
    return d.y + d.vy;
  }

  var collide = function (radius) {
    var nodes,
        radii,
        strength = 1,
        iterations = 1;

    if (typeof radius !== "function") radius = constant$6(radius == null ? 1 : +radius);

    function force() {
      var i,
          n = nodes.length,
          tree,
          node,
          xi,
          yi,
          ri,
          ri2;

      for (var k = 0; k < iterations; ++k) {
        tree = quadtree(nodes, x, y).visitAfter(prepare);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          ri = radii[node.index], ri2 = ri * ri;
          xi = node.x + node.vx;
          yi = node.y + node.vy;
          tree.visit(apply);
        }
      }

      function apply(quad, x0, y0, x1, y1) {
        var data = quad.data,
            rj = quad.r,
            r = ri + rj;
        if (data) {
          if (data.index > node.index) {
            var x = xi - data.x - data.vx,
                y = yi - data.y - data.vy,
                l = x * x + y * y;
            if (l < r * r) {
              if (x === 0) x = jiggle(), l += x * x;
              if (y === 0) y = jiggle(), l += y * y;
              l = (r - (l = Math.sqrt(l))) / l * strength;
              node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
              node.vy += (y *= l) * r;
              data.vx -= x * (r = 1 - r);
              data.vy -= y * r;
            }
          }
          return;
        }
        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
      }
    }

    function prepare(quad) {
      if (quad.data) return quad.r = radii[quad.data.index];
      for (var i = quad.r = 0; i < 4; ++i) {
        if (quad[i] && quad[i].r > quad.r) {
          quad.r = quad[i].r;
        }
      }
    }

    function initialize() {
      if (!nodes) return;
      var i,
          n = nodes.length,
          node;
      radii = new Array(n);
      for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
    }

    force.initialize = function (_) {
      nodes = _;
      initialize();
    };

    force.iterations = function (_) {
      return arguments.length ? (iterations = +_, force) : iterations;
    };

    force.strength = function (_) {
      return arguments.length ? (strength = +_, force) : strength;
    };

    force.radius = function (_) {
      return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : radius;
    };

    return force;
  };

  function index(d) {
    return d.index;
  }

  function find(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("missing: " + nodeId);
    return node;
  }

  var link = function (links) {
    var id = index,
        strength = defaultStrength,
        strengths,
        distance = constant$6(30),
        distances,
        nodes,
        count,
        bias,
        iterations = 1;

    if (links == null) links = [];

    function defaultStrength(link) {
      return 1 / Math.min(count[link.source.index], count[link.target.index]);
    }

    function force(alpha) {
      for (var k = 0, n = links.length; k < iterations; ++k) {
        for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
          link = links[i], source = link.source, target = link.target;
          x = target.x + target.vx - source.x - source.vx || jiggle();
          y = target.y + target.vy - source.y - source.vy || jiggle();
          l = Math.sqrt(x * x + y * y);
          l = (l - distances[i]) / l * alpha * strengths[i];
          x *= l, y *= l;
          target.vx -= x * (b = bias[i]);
          target.vy -= y * b;
          source.vx += x * (b = 1 - b);
          source.vy += y * b;
        }
      }
    }

    function initialize() {
      if (!nodes) return;

      var i,
          n = nodes.length,
          m = links.length,
          nodeById = map$1(nodes, id),
          link;

      for (i = 0, count = new Array(n); i < m; ++i) {
        link = links[i], link.index = i;
        if (typeof link.source !== "object") link.source = find(nodeById, link.source);
        if (typeof link.target !== "object") link.target = find(nodeById, link.target);
        count[link.source.index] = (count[link.source.index] || 0) + 1;
        count[link.target.index] = (count[link.target.index] || 0) + 1;
      }

      for (i = 0, bias = new Array(m); i < m; ++i) {
        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
      }

      strengths = new Array(m), initializeStrength();
      distances = new Array(m), initializeDistance();
    }

    function initializeStrength() {
      if (!nodes) return;

      for (var i = 0, n = links.length; i < n; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }

    function initializeDistance() {
      if (!nodes) return;

      for (var i = 0, n = links.length; i < n; ++i) {
        distances[i] = +distance(links[i], i, links);
      }
    }

    force.initialize = function (_) {
      nodes = _;
      initialize();
    };

    force.links = function (_) {
      return arguments.length ? (links = _, initialize(), force) : links;
    };

    force.id = function (_) {
      return arguments.length ? (id = _, force) : id;
    };

    force.iterations = function (_) {
      return arguments.length ? (iterations = +_, force) : iterations;
    };

    force.strength = function (_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initializeStrength(), force) : strength;
    };

    force.distance = function (_) {
      return arguments.length ? (distance = typeof _ === "function" ? _ : constant$6(+_), initializeDistance(), force) : distance;
    };

    return force;
  };

  function x$1(d) {
    return d.x;
  }

  function y$1(d) {
    return d.y;
  }

  var initialRadius = 10;
  var initialAngle = Math.PI * (3 - Math.sqrt(5));

  var simulation = function (nodes) {
    var simulation,
        alpha = 1,
        alphaMin = 0.001,
        alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
        alphaTarget = 0,
        velocityDecay = 0.6,
        forces = map$1(),
        stepper = timer(step),
        event = dispatch("tick", "end");

    if (nodes == null) nodes = [];

    function step() {
      tick();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }

    function tick() {
      var i,
          n = nodes.length,
          node;

      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.each(function (force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;else node.y = node.fy, node.vy = 0;
      }
    }

    function initializeNodes() {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.index = i;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(i),
              angle = i * initialAngle;
          node.x = radius * Math.cos(angle);
          node.y = radius * Math.sin(angle);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }

    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes);
      return force;
    }

    initializeNodes();

    return simulation = {
      tick: tick,

      restart: function () {
        return stepper.restart(step), simulation;
      },

      stop: function () {
        return stepper.stop(), simulation;
      },

      nodes: function (_) {
        return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
      },

      alpha: function (_) {
        return arguments.length ? (alpha = +_, simulation) : alpha;
      },

      alphaMin: function (_) {
        return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
      },

      alphaDecay: function (_) {
        return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
      },

      alphaTarget: function (_) {
        return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
      },

      velocityDecay: function (_) {
        return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
      },

      force: function (name, _) {
        return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
      },

      find: function (x, y, radius) {
        var i = 0,
            n = nodes.length,
            dx,
            dy,
            d2,
            node,
            closest;

        if (radius == null) radius = Infinity;else radius *= radius;

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dx = x - node.x;
          dy = y - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius) closest = node, radius = d2;
        }

        return closest;
      },

      on: function (name, _) {
        return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
      }
    };
  };

  var manyBody = function () {
    var nodes,
        node,
        alpha,
        strength = constant$6(-30),
        strengths,
        distanceMin2 = 1,
        distanceMax2 = Infinity,
        theta2 = 0.81;

    function force(_) {
      var i,
          n = nodes.length,
          tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);
      for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
    }

    function initialize() {
      if (!nodes) return;
      var i,
          n = nodes.length,
          node;
      strengths = new Array(n);
      for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
    }

    function accumulate(quad) {
      var strength = 0,
          q,
          c,
          x$$1,
          y$$1,
          i;

      // For internal nodes, accumulate forces from child quadrants.
      if (quad.length) {
        for (x$$1 = y$$1 = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c = q.value)) {
            strength += c, x$$1 += c * q.x, y$$1 += c * q.y;
          }
        }
        quad.x = x$$1 / strength;
        quad.y = y$$1 / strength;
      }

      // For leaf nodes, accumulate forces from coincident quadrants.
      else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index]; while (q = q.next);
        }

      quad.value = strength;
    }

    function apply(quad, x1, _, x2) {
      if (!quad.value) return true;

      var x$$1 = quad.x - node.x,
          y$$1 = quad.y - node.y,
          w = x2 - x1,
          l = x$$1 * x$$1 + y$$1 * y$$1;

      // Apply the Barnes-Hut approximation if possible.
      // Limit forces for very close nodes; randomize direction if coincident.
      if (w * w / theta2 < l) {
        if (l < distanceMax2) {
          if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;
          if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
          node.vx += x$$1 * quad.value * alpha / l;
          node.vy += y$$1 * quad.value * alpha / l;
        }
        return true;
      }

      // Otherwise, process points directly.
      else if (quad.length || l >= distanceMax2) return;

      // Limit forces for very close nodes; randomize direction if coincident.
      if (quad.data !== node || quad.next) {
        if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;
        if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
      }

      do if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x$$1 * w;
        node.vy += y$$1 * w;
      } while (quad = quad.next);
    }

    force.initialize = function (_) {
      nodes = _;
      initialize();
    };

    force.strength = function (_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
    };

    force.distanceMin = function (_) {
      return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
    };

    force.distanceMax = function (_) {
      return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
    };

    force.theta = function (_) {
      return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
    };

    return force;
  };

  var x$2 = function (x) {
    var strength = constant$6(0.1),
        nodes,
        strengths,
        xz;

    if (typeof x !== "function") x = constant$6(x == null ? 0 : +x);

    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }

    function initialize() {
      if (!nodes) return;
      var i,
          n = nodes.length;
      strengths = new Array(n);
      xz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }

    force.initialize = function (_) {
      nodes = _;
      initialize();
    };

    force.strength = function (_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
    };

    force.x = function (_) {
      return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : x;
    };

    return force;
  };

  var y$2 = function (y) {
    var strength = constant$6(0.1),
        nodes,
        strengths,
        yz;

    if (typeof y !== "function") y = constant$6(y == null ? 0 : +y);

    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }

    function initialize() {
      if (!nodes) return;
      var i,
          n = nodes.length;
      strengths = new Array(n);
      yz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }

    force.initialize = function (_) {
      nodes = _;
      initialize();
    };

    force.strength = function (_) {
      return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
    };

    force.y = function (_) {
      return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : y;
    };

    return force;
  };

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  var formatDecimal = function (x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i,
        coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
  };

  var exponent$1 = function (x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  };

  var formatGroup = function (grouping, thousands) {
    return function (value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  };

  var formatNumerals = function (numerals) {
    return function (value) {
      return value.replace(/[0-9]/g, function (i) {
        return numerals[+i];
      });
    };
  };

  var formatDefault = function (x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".":
          i0 = i1 = i;break;
        case "0":
          if (i0 === 0) i0 = i;i1 = i;break;
        case "e":
          break out;
        default:
          if (i0 > 0) i0 = 0;break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  };

  var prefixExponent;

  var formatPrefixAuto = function (x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  };

  var formatRounded = function (x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  };

  var formatTypes = {
    "": formatDefault,
    "%": function (x, p) {
      return (x * 100).toFixed(p);
    },
    "b": function (x) {
      return Math.round(x).toString(2);
    },
    "c": function (x) {
      return x + "";
    },
    "d": function (x) {
      return Math.round(x).toString(10);
    },
    "e": function (x, p) {
      return x.toExponential(p);
    },
    "f": function (x, p) {
      return x.toFixed(p);
    },
    "g": function (x, p) {
      return x.toPrecision(p);
    },
    "o": function (x) {
      return Math.round(x).toString(8);
    },
    "p": function (x, p) {
      return formatRounded(x * 100, p);
    },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function (x) {
      return Math.round(x).toString(16).toUpperCase();
    },
    "x": function (x) {
      return Math.round(x).toString(16);
    }
  };

  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier.prototype.toString = function () {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + this.type;
  };

  var identity$3 = function (x) {
    return x;
  };

  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

  var formatLocale = function (locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
        currency = locale.currency,
        decimal = locale.decimal,
        numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,
        percent = locale.percent || "%";

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? type ? 6 : 12 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i,
            n,
            c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Perform the initial formatting.
          var valueNegative = value < 0;
          value = formatType(Math.abs(value), precision);

          // If a negative value rounds to zero during formatting, treat as positive.
          if (valueNegative && +value === 0) valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;break;
          case "^":
            value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);break;
          default:
            value = padding + valuePrefix + value + valueSuffix;break;
        }

        return numerals(value);
      }

      format.toString = function () {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function (value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  };

  var locale$1;

  defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale$1 = formatLocale(definition);
    exports.format = locale$1.format;
    exports.formatPrefix = locale$1.formatPrefix;
    return locale$1;
  }

  var precisionFixed = function (step) {
    return Math.max(0, -exponent$1(Math.abs(step)));
  };

  var precisionPrefix = function (step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
  };

  var precisionRound = function (step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
  };

  // Adds floating point numbers with twice the normal precision.
  // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
  // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
  // 305–363 (1997).
  // Code adapted from GeographicLib by Charles F. F. Karney,
  // http://geographiclib.sourceforge.net/

  var adder = function () {
    return new Adder();
  };

  function Adder() {
    this.reset();
  }

  Adder.prototype = {
    constructor: Adder,
    reset: function () {
      this.s = // rounded value
      this.t = 0; // exact error
    },
    add: function (y) {
      add$1(temp, y, this.t);
      add$1(this, temp.s, this.s);
      if (this.s) this.t += temp.t;else this.s = temp.t;
    },
    valueOf: function () {
      return this.s;
    }
  };

  var temp = new Adder();

  function add$1(adder, a, b) {
    var x = adder.s = a + b,
        bv = x - a,
        av = x - bv;
    adder.t = a - av + (b - bv);
  }

  var epsilon$2 = 1e-6;
  var epsilon2$1 = 1e-12;
  var pi$3 = Math.PI;
  var halfPi$2 = pi$3 / 2;
  var quarterPi = pi$3 / 4;
  var tau$3 = pi$3 * 2;

  var degrees$1 = 180 / pi$3;
  var radians = pi$3 / 180;

  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos$1 = Math.cos;
  var ceil = Math.ceil;
  var exp = Math.exp;

  var log = Math.log;
  var pow = Math.pow;
  var sin$1 = Math.sin;
  var sign = Math.sign || function (x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  };
  var sqrt = Math.sqrt;
  var tan = Math.tan;

  function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi$3 : Math.acos(x);
  }

  function asin(x) {
    return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
  }

  function haversin(x) {
    return (x = sin$1(x / 2)) * x;
  }

  function noop$1() {}

  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }

  var streamObjectType = {
    Feature: function (object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function (object, stream) {
      var features = object.features,
          i = -1,
          n = features.length;
      while (++i < n) streamGeometry(features[i].geometry, stream);
    }
  };

  var streamGeometryType = {
    Sphere: function (object, stream) {
      stream.sphere();
    },
    Point: function (object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function (object, stream) {
      var coordinates = object.coordinates,
          i = -1,
          n = coordinates.length;
      while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function (object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function (object, stream) {
      var coordinates = object.coordinates,
          i = -1,
          n = coordinates.length;
      while (++i < n) streamLine(coordinates[i], stream, 0);
    },
    Polygon: function (object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function (object, stream) {
      var coordinates = object.coordinates,
          i = -1,
          n = coordinates.length;
      while (++i < n) streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function (object, stream) {
      var geometries = object.geometries,
          i = -1,
          n = geometries.length;
      while (++i < n) streamGeometry(geometries[i], stream);
    }
  };

  function streamLine(coordinates, stream, closed) {
    var i = -1,
        n = coordinates.length - closed,
        coordinate;
    stream.lineStart();
    while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }

  function streamPolygon(coordinates, stream) {
    var i = -1,
        n = coordinates.length;
    stream.polygonStart();
    while (++i < n) streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }

  var geoStream = function (object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  };

  var areaRingSum = adder();

  var areaSum = adder();
  var lambda00;
  var phi00;
  var lambda0;
  var cosPhi0;
  var sinPhi0;

  var areaStream = {
    point: noop$1,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: function () {
      areaRingSum.reset();
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function () {
      var areaRing = +areaRingSum;
      areaSum.add(areaRing < 0 ? tau$3 + areaRing : areaRing);
      this.lineStart = this.lineEnd = this.point = noop$1;
    },
    sphere: function () {
      areaSum.add(tau$3);
    }
  };

  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }

  function areaRingEnd() {
    areaPoint(lambda00, phi00);
  }

  function areaPointFirst(lambda, phi) {
    areaStream.point = areaPoint;
    lambda00 = lambda, phi00 = phi;
    lambda *= radians, phi *= radians;
    lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
  }

  function areaPoint(lambda, phi) {
    lambda *= radians, phi *= radians;
    phi = phi / 2 + quarterPi; // half the angular distance from south pole

    // Spherical excess E for a spherical triangle with vertices: south pole,
    // previous point, current point.  Uses a formula derived from Cagnoli’s
    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
    var dLambda = lambda - lambda0,
        sdLambda = dLambda >= 0 ? 1 : -1,
        adLambda = sdLambda * dLambda,
        cosPhi = cos$1(phi),
        sinPhi = sin$1(phi),
        k = sinPhi0 * sinPhi,
        u = cosPhi0 * cosPhi + k * cos$1(adLambda),
        v = k * sdLambda * sin$1(adLambda);
    areaRingSum.add(atan2(v, u));

    // Advance the previous points.
    lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
  }

  var area = function (object) {
    areaSum.reset();
    geoStream(object, areaStream);
    return areaSum * 2;
  };

  function spherical(cartesian) {
    return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
  }

  function cartesian(spherical) {
    var lambda = spherical[0],
        phi = spherical[1],
        cosPhi = cos$1(phi);
    return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
  }

  function cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }

  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }

  // TODO return a
  function cartesianAddInPlace(a, b) {
    a[0] += b[0], a[1] += b[1], a[2] += b[2];
  }

  function cartesianScale(vector, k) {
    return [vector[0] * k, vector[1] * k, vector[2] * k];
  }

  // TODO return d
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  var lambda0$1;
  var phi0;
  var lambda1;
  var phi1;
  var lambda2;
  var lambda00$1;
  var phi00$1;
  var p0;
  var deltaSum = adder();
  var ranges;
  var range;

  var boundsStream = {
    point: boundsPoint,
    lineStart: boundsLineStart,
    lineEnd: boundsLineEnd,
    polygonStart: function () {
      boundsStream.point = boundsRingPoint;
      boundsStream.lineStart = boundsRingStart;
      boundsStream.lineEnd = boundsRingEnd;
      deltaSum.reset();
      areaStream.polygonStart();
    },
    polygonEnd: function () {
      areaStream.polygonEnd();
      boundsStream.point = boundsPoint;
      boundsStream.lineStart = boundsLineStart;
      boundsStream.lineEnd = boundsLineEnd;
      if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > epsilon$2) phi1 = 90;else if (deltaSum < -epsilon$2) phi0 = -90;
      range[0] = lambda0$1, range[1] = lambda1;
    }
  };

  function boundsPoint(lambda, phi) {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
    if (phi < phi0) phi0 = phi;
    if (phi > phi1) phi1 = phi;
  }

  function linePoint(lambda, phi) {
    var p = cartesian([lambda * radians, phi * radians]);
    if (p0) {
      var normal = cartesianCross(p0, p),
          equatorial = [normal[1], -normal[0], 0],
          inflection = cartesianCross(equatorial, normal);
      cartesianNormalizeInPlace(inflection);
      inflection = spherical(inflection);
      var delta = lambda - lambda2,
          sign$$1 = delta > 0 ? 1 : -1,
          lambdai = inflection[0] * degrees$1 * sign$$1,
          phii,
          antimeridian = abs(delta) > 180;
      if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
        phii = inflection[1] * degrees$1;
        if (phii > phi1) phi1 = phii;
      } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
        phii = -inflection[1] * degrees$1;
        if (phii < phi0) phi0 = phii;
      } else {
        if (phi < phi0) phi0 = phi;
        if (phi > phi1) phi1 = phi;
      }
      if (antimeridian) {
        if (lambda < lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      } else {
        if (lambda1 >= lambda0$1) {
          if (lambda < lambda0$1) lambda0$1 = lambda;
          if (lambda > lambda1) lambda1 = lambda;
        } else {
          if (lambda > lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        }
      }
    } else {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
    }
    if (phi < phi0) phi0 = phi;
    if (phi > phi1) phi1 = phi;
    p0 = p, lambda2 = lambda;
  }

  function boundsLineStart() {
    boundsStream.point = linePoint;
  }

  function boundsLineEnd() {
    range[0] = lambda0$1, range[1] = lambda1;
    boundsStream.point = boundsPoint;
    p0 = null;
  }

  function boundsRingPoint(lambda, phi) {
    if (p0) {
      var delta = lambda - lambda2;
      deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
    } else {
      lambda00$1 = lambda, phi00$1 = phi;
    }
    areaStream.point(lambda, phi);
    linePoint(lambda, phi);
  }

  function boundsRingStart() {
    areaStream.lineStart();
  }

  function boundsRingEnd() {
    boundsRingPoint(lambda00$1, phi00$1);
    areaStream.lineEnd();
    if (abs(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);
    range[0] = lambda0$1, range[1] = lambda1;
    p0 = null;
  }

  // Finds the left-right distance between two longitudes.
  // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
  // the distance between ±180° to be 360°.
  function angle(lambda0, lambda1) {
    return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
  }

  function rangeCompare(a, b) {
    return a[0] - b[0];
  }

  function rangeContains(range, x) {
    return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
  }

  var bounds = function (feature) {
    var i, n, a, b, merged, deltaMax, delta;

    phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
    ranges = [];
    geoStream(feature, boundsStream);

    // First, sort ranges by their minimum longitudes.
    if (n = ranges.length) {
      ranges.sort(rangeCompare);

      // Then, merge any ranges that overlap.
      for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
        b = ranges[i];
        if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
          if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
          if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
        } else {
          merged.push(a = b);
        }
      }

      // Finally, find the largest gap between the merged ranges.
      // The final bounding box will be the inverse of this gap.
      for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
        b = merged[i];
        if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
      }
    }

    ranges = range = null;

    return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
  };

  var W0;
  var W1;
  var X0;
  var Y0;
  var Z0;
  var X1;
  var Y1;
  var Z1;
  var X2;
  var Y2;
  var Z2;
  var lambda00$2;
  var phi00$2;
  var x0;
  var y0;
  var z0; // previous point

  var centroidStream = {
    sphere: noop$1,
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function () {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function () {
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    }
  };

  // Arithmetic mean of Cartesian vectors.
  function centroidPoint(lambda, phi) {
    lambda *= radians, phi *= radians;
    var cosPhi = cos$1(phi);
    centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
  }

  function centroidPointCartesian(x, y, z) {
    ++W0;
    X0 += (x - X0) / W0;
    Y0 += (y - Y0) / W0;
    Z0 += (z - Z0) / W0;
  }

  function centroidLineStart() {
    centroidStream.point = centroidLinePointFirst;
  }

  function centroidLinePointFirst(lambda, phi) {
    lambda *= radians, phi *= radians;
    var cosPhi = cos$1(phi);
    x0 = cosPhi * cos$1(lambda);
    y0 = cosPhi * sin$1(lambda);
    z0 = sin$1(phi);
    centroidStream.point = centroidLinePoint;
    centroidPointCartesian(x0, y0, z0);
  }

  function centroidLinePoint(lambda, phi) {
    lambda *= radians, phi *= radians;
    var cosPhi = cos$1(phi),
        x = cosPhi * cos$1(lambda),
        y = cosPhi * sin$1(lambda),
        z = sin$1(phi),
        w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
    W1 += w;
    X1 += w * (x0 + (x0 = x));
    Y1 += w * (y0 + (y0 = y));
    Z1 += w * (z0 + (z0 = z));
    centroidPointCartesian(x0, y0, z0);
  }

  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }

  // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
  // J. Applied Mechanics 42, 239 (1975).
  function centroidRingStart() {
    centroidStream.point = centroidRingPointFirst;
  }

  function centroidRingEnd() {
    centroidRingPoint(lambda00$2, phi00$2);
    centroidStream.point = centroidPoint;
  }

  function centroidRingPointFirst(lambda, phi) {
    lambda00$2 = lambda, phi00$2 = phi;
    lambda *= radians, phi *= radians;
    centroidStream.point = centroidRingPoint;
    var cosPhi = cos$1(phi);
    x0 = cosPhi * cos$1(lambda);
    y0 = cosPhi * sin$1(lambda);
    z0 = sin$1(phi);
    centroidPointCartesian(x0, y0, z0);
  }

  function centroidRingPoint(lambda, phi) {
    lambda *= radians, phi *= radians;
    var cosPhi = cos$1(phi),
        x = cosPhi * cos$1(lambda),
        y = cosPhi * sin$1(lambda),
        z = sin$1(phi),
        cx = y0 * z - z0 * y,
        cy = z0 * x - x0 * z,
        cz = x0 * y - y0 * x,
        m = sqrt(cx * cx + cy * cy + cz * cz),
        w = asin(m),
        // line weight = angle
    v = m && -w / m; // area weight multiplier
    X2 += v * cx;
    Y2 += v * cy;
    Z2 += v * cz;
    W1 += w;
    X1 += w * (x0 + (x0 = x));
    Y1 += w * (y0 + (y0 = y));
    Z1 += w * (z0 + (z0 = z));
    centroidPointCartesian(x0, y0, z0);
  }

  var centroid = function (object) {
    W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    geoStream(object, centroidStream);

    var x = X2,
        y = Y2,
        z = Z2,
        m = x * x + y * y + z * z;

    // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
    if (m < epsilon2$1) {
      x = X1, y = Y1, z = Z1;
      // If the feature has zero length, fall back to arithmetic mean of point vectors.
      if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;
      m = x * x + y * y + z * z;
      // If the feature still has an undefined ccentroid, then return.
      if (m < epsilon2$1) return [NaN, NaN];
    }

    return [atan2(y, x) * degrees$1, asin(z / sqrt(m)) * degrees$1];
  };

  var constant$7 = function (x) {
    return function () {
      return x;
    };
  };

  var compose = function (a, b) {

    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }

    if (a.invert && b.invert) compose.invert = function (x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };

    return compose;
  };

  function rotationIdentity(lambda, phi) {
    return [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];
  }

  rotationIdentity.invert = rotationIdentity;

  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau$3) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }

  function forwardRotationLambda(deltaLambda) {
    return function (lambda, phi) {
      return lambda += deltaLambda, [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];
    };
  }

  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }

  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos$1(deltaPhi),
        sinDeltaPhi = sin$1(deltaPhi),
        cosDeltaGamma = cos$1(deltaGamma),
        sinDeltaGamma = sin$1(deltaGamma);

    function rotation(lambda, phi) {
      var cosPhi = cos$1(phi),
          x = cos$1(lambda) * cosPhi,
          y = sin$1(lambda) * cosPhi,
          z = sin$1(phi),
          k = z * cosDeltaPhi + x * sinDeltaPhi;
      return [atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), asin(k * cosDeltaGamma + y * sinDeltaGamma)];
    }

    rotation.invert = function (lambda, phi) {
      var cosPhi = cos$1(phi),
          x = cos$1(lambda) * cosPhi,
          y = sin$1(lambda) * cosPhi,
          z = sin$1(phi),
          k = z * cosDeltaGamma - y * sinDeltaGamma;
      return [atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), asin(k * cosDeltaPhi - x * sinDeltaPhi)];
    };

    return rotation;
  }

  var rotation = function (rotate) {
    rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
      return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
    }

    forward.invert = function (coordinates) {
      coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
      return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
    };

    return forward;
  };

  // Generates a circle centered at [0°, 0°], with a given radius and precision.
  function circleStream(stream, radius, delta, direction, t0, t1) {
    if (!delta) return;
    var cosRadius = cos$1(radius),
        sinRadius = sin$1(radius),
        step = direction * delta;
    if (t0 == null) {
      t0 = radius + direction * tau$3;
      t1 = radius - step / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$3;
    }
    for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
      point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
      stream.point(point[0], point[1]);
    }
  }

  // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
  function circleRadius(cosRadius, point) {
    point = cartesian(point), point[0] -= cosRadius;
    cartesianNormalizeInPlace(point);
    var radius = acos(-point[1]);
    return ((-point[2] < 0 ? -radius : radius) + tau$3 - epsilon$2) % tau$3;
  }

  var circle = function () {
    var center = constant$7([0, 0]),
        radius = constant$7(90),
        precision = constant$7(6),
        ring,
        rotate,
        stream = { point: point };

    function point(x, y) {
      ring.push(x = rotate(x, y));
      x[0] *= degrees$1, x[1] *= degrees$1;
    }

    function circle() {
      var c = center.apply(this, arguments),
          r = radius.apply(this, arguments) * radians,
          p = precision.apply(this, arguments) * radians;
      ring = [];
      rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
      circleStream(stream, r, p, 1);
      c = { type: "Polygon", coordinates: [ring] };
      ring = rotate = null;
      return c;
    }

    circle.center = function (_) {
      return arguments.length ? (center = typeof _ === "function" ? _ : constant$7([+_[0], +_[1]]), circle) : center;
    };

    circle.radius = function (_) {
      return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), circle) : radius;
    };

    circle.precision = function (_) {
      return arguments.length ? (precision = typeof _ === "function" ? _ : constant$7(+_), circle) : precision;
    };

    return circle;
  };

  var clipBuffer = function () {
    var lines = [],
        line;
    return {
      point: function (x, y) {
        line.push([x, y]);
      },
      lineStart: function () {
        lines.push(line = []);
      },
      lineEnd: noop$1,
      rejoin: function () {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function () {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  };

  var clipLine = function (a, b, x0, y0, x1, y1) {
    var ax = a[0],
        ay = a[1],
        bx = b[0],
        by = b[1],
        t0 = 0,
        t1 = 1,
        dx = bx - ax,
        dy = by - ay,
        r;

    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dx > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dx > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dy > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dy > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
  };

  var pointEqual = function (a, b) {
    return abs(a[0] - b[0]) < epsilon$2 && abs(a[1] - b[1]) < epsilon$2;
  };

  function Intersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other; // another intersection
    this.e = entry; // is an entry?
    this.v = false; // visited
    this.n = this.p = null; // next & previous
  }

  // A generalized polygon clipping algorithm: given a polygon that has been cut
  // into its visible line segments, and rejoins the segments by interpolating
  // along the clip edge.
  var clipPolygon = function (segments, compareIntersection, startInside, interpolate, stream) {
    var subject = [],
        clip = [],
        i,
        n;

    segments.forEach(function (segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n,
          p0 = segment[0],
          p1 = segment[n],
          x;

      // If the first and last points of a segment are coincident, then treat as a
      // closed ring. TODO if all rings are closed, then the winding order of the
      // exterior ring should be checked.
      if (pointEqual(p0, p1)) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }

      subject.push(x = new Intersection(p0, segment, null, true));
      clip.push(x.o = new Intersection(p0, null, x, false));
      subject.push(x = new Intersection(p1, segment, null, false));
      clip.push(x.o = new Intersection(p1, null, x, true));
    });

    if (!subject.length) return;

    clip.sort(compareIntersection);
    link$1(subject);
    link$1(clip);

    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }

    var start = subject[0],
        points,
        point;

    while (1) {
      // Find first unvisited intersection.
      var current = start,
          isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  };

  function link$1(array) {
    if (!(n = array.length)) return;
    var n,
        i = 0,
        a = array[0],
        b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }

  var clipMax = 1e9;
  var clipMin = -clipMax;

  // TODO Use d3-polygon’s polygonContains here for the ring check?
  // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

  function clipExtent(x0, y0, x1, y1) {

    function visible(x, y) {
      return x0 <= x && x <= x1 && y0 <= y && y <= y1;
    }

    function interpolate(from, to, direction, stream) {
      var a = 0,
          a1 = 0;
      if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
        do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function corner(p, direction) {
      return abs(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
    }

    function compareIntersection(a, b) {
      return comparePoint(a.x, b.x);
    }

    function comparePoint(a, b) {
      var ca = corner(a, 1),
          cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }

    return function (stream) {
      var activeStream = stream,
          bufferStream = clipBuffer(),
          segments,
          polygon,
          ring,
          x__,
          y__,
          v__,
          // first point
      x_,
          y_,
          v_,
          // previous point
      first,
          clean;

      var clipStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: polygonStart,
        polygonEnd: polygonEnd
      };

      function point(x, y) {
        if (visible(x, y)) activeStream.point(x, y);
      }

      function polygonInside() {
        var winding = 0;

        for (var i = 0, n = polygon.length; i < n; ++i) {
          for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
            a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
            if (a1 <= y1) {
              if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
            } else {
              if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
            }
          }
        }

        return winding;
      }

      // Buffer geometry within a polygon and then clip it en masse.
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }

      function polygonEnd() {
        var startInside = polygonInside(),
            cleanInside = clean && startInside,
            visible = (segments = merge(segments)).length;
        if (cleanInside || visible) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible) {
            clipPolygon(segments, compareIntersection, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }

      function lineStart() {
        clipStream.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }

      // TODO rather than special-case polygons, simply handle them separately.
      // Ideally, coincident intersection points should be jittered to avoid
      // clipping issues.
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point;
        if (v_) activeStream.lineEnd();
      }

      function linePoint(x, y) {
        var v = visible(x, y);
        if (polygon) ring.push([x, y]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
          }
        } else {
          if (v && v_) activeStream.point(x, y);else {
            var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
            if (clipLine(a, b, x0, y0, x1, y1)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a[0], a[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v) activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }

      return clipStream;
    };
  }

  var extent$1 = function () {
    var x0 = 0,
        y0 = 0,
        x1 = 960,
        y1 = 500,
        cache,
        cacheStream,
        clip;

    return clip = {
      stream: function (stream) {
        return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
      },
      extent: function (_) {
        return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
      }
    };
  };

  var sum$1 = adder();

  var polygonContains = function (polygon, point) {
    var lambda = point[0],
        phi = point[1],
        normal = [sin$1(lambda), -cos$1(lambda), 0],
        angle = 0,
        winding = 0;

    sum$1.reset();

    for (var i = 0, n = polygon.length; i < n; ++i) {
      if (!(m = (ring = polygon[i]).length)) continue;
      var ring,
          m,
          point0 = ring[m - 1],
          lambda0 = point0[0],
          phi0 = point0[1] / 2 + quarterPi,
          sinPhi0 = sin$1(phi0),
          cosPhi0 = cos$1(phi0);

      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j],
            lambda1 = point1[0],
            phi1 = point1[1] / 2 + quarterPi,
            sinPhi1 = sin$1(phi1),
            cosPhi1 = cos$1(phi1),
            delta = lambda1 - lambda0,
            sign$$1 = delta >= 0 ? 1 : -1,
            absDelta = sign$$1 * delta,
            antimeridian = absDelta > pi$3,
            k = sinPhi0 * sinPhi1;

        sum$1.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
        angle += antimeridian ? delta + sign$$1 * tau$3 : delta;

        // Are the longitudes either side of the point’s meridian (lambda),
        // and are the latitudes smaller than the parallel (phi)?
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }

    // First, determine whether the South pole is inside or outside:
    //
    // It is inside if:
    // * the polygon winds around it in a clockwise direction.
    // * the polygon does not (cumulatively) wind around it, but has a negative
    //   (counter-clockwise) area.
    //
    // Second, count the (signed) number of times a segment crosses a lambda
    // from the point to the South pole.  If it is zero, then the point is the
    // same side as the South pole.

    return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ winding & 1;
  };

  var lengthSum = adder();
  var lambda0$2;
  var sinPhi0$1;
  var cosPhi0$1;

  var lengthStream = {
    sphere: noop$1,
    point: noop$1,
    lineStart: lengthLineStart,
    lineEnd: noop$1,
    polygonStart: noop$1,
    polygonEnd: noop$1
  };

  function lengthLineStart() {
    lengthStream.point = lengthPointFirst;
    lengthStream.lineEnd = lengthLineEnd;
  }

  function lengthLineEnd() {
    lengthStream.point = lengthStream.lineEnd = noop$1;
  }

  function lengthPointFirst(lambda, phi) {
    lambda *= radians, phi *= radians;
    lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
    lengthStream.point = lengthPoint;
  }

  function lengthPoint(lambda, phi) {
    lambda *= radians, phi *= radians;
    var sinPhi = sin$1(phi),
        cosPhi = cos$1(phi),
        delta = abs(lambda - lambda0$2),
        cosDelta = cos$1(delta),
        sinDelta = sin$1(delta),
        x = cosPhi * sinDelta,
        y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
        z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
    lengthSum.add(atan2(sqrt(x * x + y * y), z));
    lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
  }

  var length$1 = function (object) {
    lengthSum.reset();
    geoStream(object, lengthStream);
    return +lengthSum;
  };

  var coordinates = [null, null];
  var object$1 = { type: "LineString", coordinates: coordinates };

  var distance = function (a, b) {
    coordinates[0] = a;
    coordinates[1] = b;
    return length$1(object$1);
  };

  var containsObjectType = {
    Feature: function (object, point) {
      return containsGeometry(object.geometry, point);
    },
    FeatureCollection: function (object, point) {
      var features = object.features,
          i = -1,
          n = features.length;
      while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
      return false;
    }
  };

  var containsGeometryType = {
    Sphere: function () {
      return true;
    },
    Point: function (object, point) {
      return containsPoint(object.coordinates, point);
    },
    MultiPoint: function (object, point) {
      var coordinates = object.coordinates,
          i = -1,
          n = coordinates.length;
      while (++i < n) if (containsPoint(coordinates[i], point)) return true;
      return false;
    },
    LineString: function (object, point) {
      return containsLine(object.coordinates, point);
    },
    MultiLineString: function (object, point) {
      var coordinates = object.coordinates,
          i = -1,
          n = coordinates.length;
      while (++i < n) if (containsLine(coordinates[i], point)) return true;
      return false;
    },
    Polygon: function (object, point) {
      return containsPolygon(object.coordinates, point);
    },
    MultiPolygon: function (object, point) {
      var coordinates = object.coordinates,
          i = -1,
          n = coordinates.length;
      while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
      return false;
    },
    GeometryCollection: function (object, point) {
      var geometries = object.geometries,
          i = -1,
          n = geometries.length;
      while (++i < n) if (containsGeometry(geometries[i], point)) return true;
      return false;
    }
  };

  function containsGeometry(geometry, point) {
    return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
  }

  function containsPoint(coordinates, point) {
    return distance(coordinates, point) === 0;
  }

  function containsLine(coordinates, point) {
    var ab = distance(coordinates[0], coordinates[1]),
        ao = distance(coordinates[0], point),
        ob = distance(point, coordinates[1]);
    return ao + ob <= ab + epsilon$2;
  }

  function containsPolygon(coordinates, point) {
    return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
  }

  function ringRadians(ring) {
    return ring = ring.map(pointRadians), ring.pop(), ring;
  }

  function pointRadians(point) {
    return [point[0] * radians, point[1] * radians];
  }

  var contains = function (object, point) {
    return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
  };

  function graticuleX(y0, y1, dy) {
    var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);
    return function (x) {
      return y.map(function (y) {
        return [x, y];
      });
    };
  }

  function graticuleY(x0, x1, dx) {
    var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);
    return function (y) {
      return x.map(function (x) {
        return [x, y];
      });
    };
  }

  function graticule() {
    var x1,
        x0,
        X1,
        X0,
        y1,
        y0,
        Y1,
        Y0,
        dx = 10,
        dy = dx,
        DX = 90,
        DY = 360,
        x,
        y,
        X,
        Y,
        precision = 2.5;

    function graticule() {
      return { type: "MultiLineString", coordinates: lines() };
    }

    function lines() {
      return sequence(ceil(X0 / DX) * DX, X1, DX).map(X).concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
        return abs(x % DX) > epsilon$2;
      }).map(x)).concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
        return abs(y % DY) > epsilon$2;
      }).map(y));
    }

    graticule.lines = function () {
      return lines().map(function (coordinates) {
        return { type: "LineString", coordinates: coordinates };
      });
    };

    graticule.outline = function () {
      return {
        type: "Polygon",
        coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
      };
    };

    graticule.extent = function (_) {
      if (!arguments.length) return graticule.extentMinor();
      return graticule.extentMajor(_).extentMinor(_);
    };

    graticule.extentMajor = function (_) {
      if (!arguments.length) return [[X0, Y0], [X1, Y1]];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };

    graticule.extentMinor = function (_) {
      if (!arguments.length) return [[x0, y0], [x1, y1]];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };

    graticule.step = function (_) {
      if (!arguments.length) return graticule.stepMinor();
      return graticule.stepMajor(_).stepMinor(_);
    };

    graticule.stepMajor = function (_) {
      if (!arguments.length) return [DX, DY];
      DX = +_[0], DY = +_[1];
      return graticule;
    };

    graticule.stepMinor = function (_) {
      if (!arguments.length) return [dx, dy];
      dx = +_[0], dy = +_[1];
      return graticule;
    };

    graticule.precision = function (_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = graticuleX(y0, y1, 90);
      y = graticuleY(x0, x1, precision);
      X = graticuleX(Y0, Y1, 90);
      Y = graticuleY(X0, X1, precision);
      return graticule;
    };

    return graticule.extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]]).extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
  }

  function graticule10() {
    return graticule()();
  }

  var interpolate$1 = function (a, b) {
    var x0 = a[0] * radians,
        y0 = a[1] * radians,
        x1 = b[0] * radians,
        y1 = b[1] * radians,
        cy0 = cos$1(y0),
        sy0 = sin$1(y0),
        cy1 = cos$1(y1),
        sy1 = sin$1(y1),
        kx0 = cy0 * cos$1(x0),
        ky0 = cy0 * sin$1(x0),
        kx1 = cy1 * cos$1(x1),
        ky1 = cy1 * sin$1(x1),
        d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
        k = sin$1(d);

    var interpolate = d ? function (t) {
      var B = sin$1(t *= d) / k,
          A = sin$1(d - t) / k,
          x = A * kx0 + B * kx1,
          y = A * ky0 + B * ky1,
          z = A * sy0 + B * sy1;
      return [atan2(y, x) * degrees$1, atan2(z, sqrt(x * x + y * y)) * degrees$1];
    } : function () {
      return [x0 * degrees$1, y0 * degrees$1];
    };

    interpolate.distance = d;

    return interpolate;
  };

  var identity$4 = function (x) {
    return x;
  };

  var areaSum$1 = adder();
  var areaRingSum$1 = adder();
  var x00;
  var y00;
  var x0$1;
  var y0$1;

  var areaStream$1 = {
    point: noop$1,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: function () {
      areaStream$1.lineStart = areaRingStart$1;
      areaStream$1.lineEnd = areaRingEnd$1;
    },
    polygonEnd: function () {
      areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$1;
      areaSum$1.add(abs(areaRingSum$1));
      areaRingSum$1.reset();
    },
    result: function () {
      var area = areaSum$1 / 2;
      areaSum$1.reset();
      return area;
    }
  };

  function areaRingStart$1() {
    areaStream$1.point = areaPointFirst$1;
  }

  function areaPointFirst$1(x, y) {
    areaStream$1.point = areaPoint$1;
    x00 = x0$1 = x, y00 = y0$1 = y;
  }

  function areaPoint$1(x, y) {
    areaRingSum$1.add(y0$1 * x - x0$1 * y);
    x0$1 = x, y0$1 = y;
  }

  function areaRingEnd$1() {
    areaPoint$1(x00, y00);
  }

  var x0$2 = Infinity;
  var y0$2 = x0$2;
  var x1 = -x0$2;
  var y1 = x1;

  var boundsStream$1 = {
    point: boundsPoint$1,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: noop$1,
    polygonEnd: noop$1,
    result: function () {
      var bounds = [[x0$2, y0$2], [x1, y1]];
      x1 = y1 = -(y0$2 = x0$2 = Infinity);
      return bounds;
    }
  };

  function boundsPoint$1(x, y) {
    if (x < x0$2) x0$2 = x;
    if (x > x1) x1 = x;
    if (y < y0$2) y0$2 = y;
    if (y > y1) y1 = y;
  }

  // TODO Enforce positive area for exterior, negative area for interior?

  var X0$1 = 0;
  var Y0$1 = 0;
  var Z0$1 = 0;
  var X1$1 = 0;
  var Y1$1 = 0;
  var Z1$1 = 0;
  var X2$1 = 0;
  var Y2$1 = 0;
  var Z2$1 = 0;
  var x00$1;
  var y00$1;
  var x0$3;
  var y0$3;

  var centroidStream$1 = {
    point: centroidPoint$1,
    lineStart: centroidLineStart$1,
    lineEnd: centroidLineEnd$1,
    polygonStart: function () {
      centroidStream$1.lineStart = centroidRingStart$1;
      centroidStream$1.lineEnd = centroidRingEnd$1;
    },
    polygonEnd: function () {
      centroidStream$1.point = centroidPoint$1;
      centroidStream$1.lineStart = centroidLineStart$1;
      centroidStream$1.lineEnd = centroidLineEnd$1;
    },
    result: function () {
      var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
      X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
      return centroid;
    }
  };

  function centroidPoint$1(x, y) {
    X0$1 += x;
    Y0$1 += y;
    ++Z0$1;
  }

  function centroidLineStart$1() {
    centroidStream$1.point = centroidPointFirstLine;
  }

  function centroidPointFirstLine(x, y) {
    centroidStream$1.point = centroidPointLine;
    centroidPoint$1(x0$3 = x, y0$3 = y);
  }

  function centroidPointLine(x, y) {
    var dx = x - x0$3,
        dy = y - y0$3,
        z = sqrt(dx * dx + dy * dy);
    X1$1 += z * (x0$3 + x) / 2;
    Y1$1 += z * (y0$3 + y) / 2;
    Z1$1 += z;
    centroidPoint$1(x0$3 = x, y0$3 = y);
  }

  function centroidLineEnd$1() {
    centroidStream$1.point = centroidPoint$1;
  }

  function centroidRingStart$1() {
    centroidStream$1.point = centroidPointFirstRing;
  }

  function centroidRingEnd$1() {
    centroidPointRing(x00$1, y00$1);
  }

  function centroidPointFirstRing(x, y) {
    centroidStream$1.point = centroidPointRing;
    centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
  }

  function centroidPointRing(x, y) {
    var dx = x - x0$3,
        dy = y - y0$3,
        z = sqrt(dx * dx + dy * dy);

    X1$1 += z * (x0$3 + x) / 2;
    Y1$1 += z * (y0$3 + y) / 2;
    Z1$1 += z;

    z = y0$3 * x - x0$3 * y;
    X2$1 += z * (x0$3 + x);
    Y2$1 += z * (y0$3 + y);
    Z2$1 += z * 3;
    centroidPoint$1(x0$3 = x, y0$3 = y);
  }

  function PathContext(context) {
    this._context = context;
  }

  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function (_) {
      return this._radius = _, this;
    },
    polygonStart: function () {
      this._line = 0;
    },
    polygonEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function (x, y) {
      switch (this._point) {
        case 0:
          {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
        case 1:
          {
            this._context.lineTo(x, y);
            break;
          }
        default:
          {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$3);
            break;
          }
      }
    },
    result: noop$1
  };

  var lengthSum$1 = adder();
  var lengthRing;
  var x00$2;
  var y00$2;
  var x0$4;
  var y0$4;

  var lengthStream$1 = {
    point: noop$1,
    lineStart: function () {
      lengthStream$1.point = lengthPointFirst$1;
    },
    lineEnd: function () {
      if (lengthRing) lengthPoint$1(x00$2, y00$2);
      lengthStream$1.point = noop$1;
    },
    polygonStart: function () {
      lengthRing = true;
    },
    polygonEnd: function () {
      lengthRing = null;
    },
    result: function () {
      var length = +lengthSum$1;
      lengthSum$1.reset();
      return length;
    }
  };

  function lengthPointFirst$1(x, y) {
    lengthStream$1.point = lengthPoint$1;
    x00$2 = x0$4 = x, y00$2 = y0$4 = y;
  }

  function lengthPoint$1(x, y) {
    x0$4 -= x, y0$4 -= y;
    lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
    x0$4 = x, y0$4 = y;
  }

  function PathString() {
    this._string = [];
  }

  PathString.prototype = {
    _radius: 4.5,
    _circle: circle$1(4.5),
    pointRadius: function (_) {
      if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function () {
      this._line = 0;
    },
    polygonEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      if (this._line === 0) this._string.push("Z");
      this._point = NaN;
    },
    point: function (x, y) {
      switch (this._point) {
        case 0:
          {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
        case 1:
          {
            this._string.push("L", x, ",", y);
            break;
          }
        default:
          {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
      }
    },
    result: function () {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };

  function circle$1(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }

  var index$1 = function (projection, context) {
    var pointRadius = 4.5,
        projectionStream,
        contextStream;

    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        geoStream(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }

    path.area = function (object) {
      geoStream(object, projectionStream(areaStream$1));
      return areaStream$1.result();
    };

    path.measure = function (object) {
      geoStream(object, projectionStream(lengthStream$1));
      return lengthStream$1.result();
    };

    path.bounds = function (object) {
      geoStream(object, projectionStream(boundsStream$1));
      return boundsStream$1.result();
    };

    path.centroid = function (object) {
      geoStream(object, projectionStream(centroidStream$1));
      return centroidStream$1.result();
    };

    path.projection = function (_) {
      return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
    };

    path.context = function (_) {
      if (!arguments.length) return context;
      contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path;
    };

    path.pointRadius = function (_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };

    return path.projection(projection).context(context);
  };

  var clip = function (pointVisible, clipLine, interpolate, start) {
    return function (rotate, sink) {
      var line = clipLine(sink),
          rotatedStart = rotate.invert(start[0], start[1]),
          ringBuffer = clipBuffer(),
          ringSink = clipLine(ringBuffer),
          polygonStarted = false,
          polygon,
          segments,
          ring;

      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function () {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function () {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains(polygon, rotatedStart);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function () {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };

      function point(lambda, phi) {
        var point = rotate(lambda, phi);
        if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
      }

      function pointLine(lambda, phi) {
        var point = rotate(lambda, phi);
        line.point(point[0], point[1]);
      }

      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }

      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }

      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        var point = rotate(lambda, phi);
        ringSink.point(point[0], point[1]);
      }

      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }

      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();

        var clean = ringSink.clean(),
            ringSegments = ringBuffer.result(),
            i,
            n = ringSegments.length,
            m,
            segment,
            point;

        ring.pop();
        polygon.push(ring);
        ring = null;

        if (!n) return;

        // No intersections.
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
            sink.lineEnd();
          }
          return;
        }

        // Rejoin connected segments.
        // TODO reuse ringBuffer.rejoin()?
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

        segments.push(ringSegments.filter(validSegment));
      }

      return clip;
    };
  };

  function validSegment(segment) {
    return segment.length > 1;
  }

  // Intersections are sorted along the clip edge. For both antimeridian cutting
  // and circle clipping, the same comparison is used.
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);
  }

  var clipAntimeridian = clip(function () {
    return true;
  }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi$3, -halfPi$2]);

  // Takes a line and cuts into visible segments. Return values: 0 - there were
  // intersections or the line was empty; 1 - no intersections; 2 - there were
  // intersections, and the first and last segments should be rejoined.
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN,
        phi0 = NaN,
        sign0 = NaN,
        clean; // no intersections

    return {
      lineStart: function () {
        stream.lineStart();
        clean = 1;
      },
      point: function (lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi$3 : -pi$3,
            delta = abs(lambda1 - lambda0);
        if (abs(delta - pi$3) < epsilon$2) {
          // line crosses a pole
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi$3) {
          // line crosses antimeridian
          if (abs(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies
          if (abs(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function () {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function () {
        return 2 - clean; // if intersections, rejoin first and last segments
      }
    };
  }

  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0,
        cosPhi1,
        sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
    return abs(sinLambda0Lambda1) > epsilon$2 ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1) - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }

  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi$2;
      stream.point(-pi$3, phi);
      stream.point(0, phi);
      stream.point(pi$3, phi);
      stream.point(pi$3, 0);
      stream.point(pi$3, -phi);
      stream.point(0, -phi);
      stream.point(-pi$3, -phi);
      stream.point(-pi$3, 0);
      stream.point(-pi$3, phi);
    } else if (abs(from[0] - to[0]) > epsilon$2) {
      var lambda = from[0] < to[0] ? pi$3 : -pi$3;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  var clipCircle = function (radius, delta) {
    var cr = cos$1(radius),
        smallRadius = cr > 0,
        notHemisphere = abs(cr) > epsilon$2; // TODO optimise for this common case

    function interpolate(from, to, direction, stream) {
      circleStream(stream, radius, delta, direction, from, to);
    }

    function visible(lambda, phi) {
      return cos$1(lambda) * cos$1(phi) > cr;
    }

    // Takes a line and cuts into visible segments. Return values used for polygon
    // clipping: 0 - there were intersections or the line was empty; 1 - no
    // intersections 2 - there were intersections, and the first and last segments
    // should be rejoined.
    function clipLine(stream) {
      var point0, // previous point
      c0, // code for previous point
      v0, // visibility of previous point
      v00, // visibility of first point
      clean; // no intersections
      return {
        lineStart: function () {
          v00 = v0 = false;
          clean = 1;
        },
        point: function (lambda, phi) {
          var point1 = [lambda, phi],
              point2,
              v = visible(lambda, phi),
              c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi$3 : -pi$3), phi) : 0;
          if (!point0 && (v00 = v0 = v)) stream.lineStart();
          // Handle degeneracies.
          // TODO ignore if not clipping polygons.
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
              point1[0] += epsilon$2;
              point1[1] += epsilon$2;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              // outside going in
              stream.lineStart();
              point2 = intersect(point1, point0);
              stream.point(point2[0], point2[1]);
            } else {
              // inside going out
              point2 = intersect(point0, point1);
              stream.point(point2[0], point2[1]);
              stream.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            // If the codes for two points are different, or are both zero,
            // and there this segment intersects with the small circle.
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !pointEqual(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function () {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function () {
          return clean | (v00 && v0) << 1;
        }
      };
    }

    // Intersects the great circle between a and b with the clip circle.
    function intersect(a, b, two) {
      var pa = cartesian(a),
          pb = cartesian(b);

      // We have two planes, n1.p = d1 and n2.p = d2.
      // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
      var n1 = [1, 0, 0],
          // normal
      n2 = cartesianCross(pa, pb),
          n2n2 = cartesianDot(n2, n2),
          n1n2 = n2[0],
          // cartesianDot(n1, n2),
      determinant = n2n2 - n1n2 * n1n2;

      // Two polar points.
      if (!determinant) return !two && a;

      var c1 = cr * n2n2 / determinant,
          c2 = -cr * n1n2 / determinant,
          n1xn2 = cartesianCross(n1, n2),
          A = cartesianScale(n1, c1),
          B = cartesianScale(n2, c2);
      cartesianAddInPlace(A, B);

      // Solve |p(t)|^2 = 1.
      var u = n1xn2,
          w = cartesianDot(A, u),
          uu = cartesianDot(u, u),
          t2 = w * w - uu * (cartesianDot(A, A) - 1);

      if (t2 < 0) return;

      var t = sqrt(t2),
          q = cartesianScale(u, (-w - t) / uu);
      cartesianAddInPlace(q, A);
      q = spherical(q);

      if (!two) return q;

      // Two intersection points.
      var lambda0 = a[0],
          lambda1 = b[0],
          phi0 = a[1],
          phi1 = b[1],
          z;

      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

      var delta = lambda1 - lambda0,
          polar = abs(delta - pi$3) < epsilon$2,
          meridian = polar || delta < epsilon$2;

      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

      // Check that the first point is between a and b.
      if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$2 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi$3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q1 = cartesianScale(u, (-w + t) / uu);
        cartesianAddInPlace(q1, A);
        return [q, spherical(q1)];
      }
    }

    // Generates a 4-bit vector representing the location of a point relative to
    // the small circle's bounding box.
    function code(lambda, phi) {
      var r = smallRadius ? radius : pi$3 - radius,
          code = 0;
      if (lambda < -r) code |= 1; // left
      else if (lambda > r) code |= 2; // right
      if (phi < -r) code |= 4; // below
      else if (phi > r) code |= 8; // above
      return code;
    }

    return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);
  };

  var transform = function (methods) {
    return {
      stream: transformer(methods)
    };
  };

  function transformer(methods) {
    return function (stream) {
      var s = new TransformStream();
      for (var key in methods) s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }

  function TransformStream() {}

  TransformStream.prototype = {
    constructor: TransformStream,
    point: function (x, y) {
      this.stream.point(x, y);
    },
    sphere: function () {
      this.stream.sphere();
    },
    lineStart: function () {
      this.stream.lineStart();
    },
    lineEnd: function () {
      this.stream.lineEnd();
    },
    polygonStart: function () {
      this.stream.polygonStart();
    },
    polygonEnd: function () {
      this.stream.polygonEnd();
    }
  };

  function fitExtent(projection, extent, object) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        clip = projection.clipExtent && projection.clipExtent();

    projection.scale(150).translate([0, 0]);

    if (clip != null) projection.clipExtent(null);

    geoStream(object, projection.stream(boundsStream$1));

    var b = boundsStream$1.result(),
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;

    if (clip != null) projection.clipExtent(clip);

    return projection.scale(k * 150).translate([x, y]);
  }

  function fitSize(projection, size, object) {
    return fitExtent(projection, [[0, 0], size], object);
  }

  var maxDepth = 16;
  var cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

  var resample = function (project, delta2) {
    return +delta2 ? resample$1(project, delta2) : resampleNone(project);
  };

  function resampleNone(project) {
    return transformer({
      point: function (x, y) {
        x = project(x, y);
        this.stream.point(x[0], x[1]);
      }
    });
  }

  function resample$1(project, delta2) {

    function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0,
          dy = y1 - y0,
          d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a = a0 + a1,
            b = b0 + b1,
            c = c0 + c1,
            m = sqrt(a * a + b * b + c * c),
            phi2 = asin(c /= m),
            lambda2 = abs(abs(c) - 1) < epsilon$2 || abs(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),
            p = project(lambda2, phi2),
            x2 = p[0],
            y2 = p[1],
            dx2 = x2 - x0,
            dy2 = y2 - y0,
            dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 // perpendicular projected distance
        || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
        || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          // angular distance
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function (stream) {
      var lambda00, x00, y00, a00, b00, c00, // first point
      lambda0, x0, y0, a0, b0, c0; // previous point

      var resampleStream = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function () {
          stream.polygonStart();resampleStream.lineStart = ringStart;
        },
        polygonEnd: function () {
          stream.polygonEnd();resampleStream.lineStart = lineStart;
        }
      };

      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }

      function lineStart() {
        x0 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }

      function linePoint(lambda, phi) {
        var c = cartesian([lambda, phi]),
            p = project(lambda, phi);
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }

      function lineEnd() {
        resampleStream.point = point;
        stream.lineEnd();
      }

      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }

      function ringPoint(lambda, phi) {
        linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }

      function ringEnd() {
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }

      return resampleStream;
    };
  }

  var transformRadians = transformer({
    point: function (x, y) {
      this.stream.point(x * radians, y * radians);
    }
  });

  function projection(project) {
    return projectionMutator(function () {
      return project;
    })();
  }

  function projectionMutator(projectAt) {
    var project,
        k = 150,
        // scale
    x = 480,
        y = 250,
        // translate
    dx,
        dy,
        lambda = 0,
        phi = 0,
        // center
    deltaLambda = 0,
        deltaPhi = 0,
        deltaGamma = 0,
        rotate,
        projectRotate,
        // rotate
    theta = null,
        preclip = clipAntimeridian,
        // clip angle
    x0 = null,
        y0,
        x1,
        y1,
        postclip = identity$4,
        // clip extent
    delta2 = 0.5,
        projectResample = resample(projectTransform, delta2),
        // precision
    cache,
        cacheStream;

    function projection(point) {
      point = projectRotate(point[0] * radians, point[1] * radians);
      return [point[0] * k + dx, dy - point[1] * k];
    }

    function invert(point) {
      point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
      return point && [point[0] * degrees$1, point[1] * degrees$1];
    }

    function projectTransform(x, y) {
      return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
    }

    projection.stream = function (stream) {
      return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
    };

    projection.clipAngle = function (_) {
      return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
    };

    projection.clipExtent = function (_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    };

    projection.scale = function (_) {
      return arguments.length ? (k = +_, recenter()) : k;
    };

    projection.translate = function (_) {
      return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
    };

    projection.center = function (_) {
      return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
    };

    projection.rotate = function (_) {
      return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
    };

    projection.precision = function (_) {
      return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
    };

    projection.fitExtent = function (extent, object) {
      return fitExtent(projection, extent, object);
    };

    projection.fitSize = function (size, object) {
      return fitSize(projection, size, object);
    };

    function recenter() {
      projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
      var center = project(lambda, phi);
      dx = x - center[0] * k;
      dy = y + center[1] * k;
      return reset();
    }

    function reset() {
      cache = cacheStream = null;
      return projection;
    }

    return function () {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return recenter();
    };
  }

  function conicProjection(projectAt) {
    var phi0 = 0,
        phi1 = pi$3 / 3,
        m = projectionMutator(projectAt),
        p = m(phi0, phi1);

    p.parallels = function (_) {
      return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];
    };

    return p;
  }

  function cylindricalEqualAreaRaw(phi0) {
    var cosPhi0 = cos$1(phi0);

    function forward(lambda, phi) {
      return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
    }

    forward.invert = function (x, y) {
      return [x / cosPhi0, asin(y * cosPhi0)];
    };

    return forward;
  }

  function conicEqualAreaRaw(y0, y1) {
    var sy0 = sin$1(y0),
        n = (sy0 + sin$1(y1)) / 2;

    // Are the parallels symmetrical around the Equator?
    if (abs(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);

    var c = 1 + sy0 * (2 * n - sy0),
        r0 = sqrt(c) / n;

    function project(x, y) {
      var r = sqrt(c - 2 * n * sin$1(y)) / n;
      return [r * sin$1(x *= n), r0 - r * cos$1(x)];
    }

    project.invert = function (x, y) {
      var r0y = r0 - y;
      return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
    };

    return project;
  }

  var conicEqualArea = function () {
    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
  };

  var albers = function () {
    return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  };

  // The projections must have mutually exclusive clip regions on the sphere,
  // as this will avoid emitting interleaving lines and polygons.
  function multiplex(streams) {
    var n = streams.length;
    return {
      point: function (x, y) {
        var i = -1;while (++i < n) streams[i].point(x, y);
      },
      sphere: function () {
        var i = -1;while (++i < n) streams[i].sphere();
      },
      lineStart: function () {
        var i = -1;while (++i < n) streams[i].lineStart();
      },
      lineEnd: function () {
        var i = -1;while (++i < n) streams[i].lineEnd();
      },
      polygonStart: function () {
        var i = -1;while (++i < n) streams[i].polygonStart();
      },
      polygonEnd: function () {
        var i = -1;while (++i < n) streams[i].polygonEnd();
      }
    };
  }

  // A composite projection for the United States, configured by default for
  // 960×500. The projection also works quite well at 960×600 if you change the
  // scale to 1285 and adjust the translate accordingly. The set of standard
  // parallels for each region comes from USGS, which is published here:
  // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
  var albersUsa = function () {
    var cache,
        cacheStream,
        lower48 = albers(),
        lower48Point,
        alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
        alaskaPoint,
        // EPSG:3338
    hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
        hawaiiPoint,
        // ESRI:102007
    point,
        pointStream = { point: function (x, y) {
        point = [x, y];
      } };

    function albersUsa(coordinates) {
      var x = coordinates[0],
          y = coordinates[1];
      return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
    }

    albersUsa.invert = function (coordinates) {
      var k = lower48.scale(),
          t = lower48.translate(),
          x = (coordinates[0] - t[0]) / k,
          y = (coordinates[1] - t[1]) / k;
      return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
    };

    albersUsa.stream = function (stream) {
      return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
    };

    albersUsa.precision = function (_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_), alaska.precision(_), hawaii.precision(_);
      return reset();
    };

    albersUsa.scale = function (_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };

    albersUsa.translate = function (_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(),
          x = +_[0],
          y = +_[1];

      lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);

      alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]]).stream(pointStream);

      hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]]).stream(pointStream);

      return reset();
    };

    albersUsa.fitExtent = function (extent, object) {
      return fitExtent(albersUsa, extent, object);
    };

    albersUsa.fitSize = function (size, object) {
      return fitSize(albersUsa, size, object);
    };

    function reset() {
      cache = cacheStream = null;
      return albersUsa;
    }

    return albersUsa.scale(1070);
  };

  function azimuthalRaw(scale) {
    return function (x, y) {
      var cx = cos$1(x),
          cy = cos$1(y),
          k = scale(cx * cy);
      return [k * cy * sin$1(x), k * sin$1(y)];
    };
  }

  function azimuthalInvert(angle) {
    return function (x, y) {
      var z = sqrt(x * x + y * y),
          c = angle(z),
          sc = sin$1(c),
          cc = cos$1(c);
      return [atan2(x * sc, z * cc), asin(z && y * sc / z)];
    };
  }

  var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {
    return sqrt(2 / (1 + cxcy));
  });

  azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {
    return 2 * asin(z / 2);
  });

  var azimuthalEqualArea = function () {
    return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
  };

  var azimuthalEquidistantRaw = azimuthalRaw(function (c) {
    return (c = acos(c)) && c / sin$1(c);
  });

  azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {
    return z;
  });

  var azimuthalEquidistant = function () {
    return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
  };

  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi$2 + phi) / 2))];
  }

  mercatorRaw.invert = function (x, y) {
    return [x, 2 * atan(exp(y)) - halfPi$2];
  };

  var mercator = function () {
    return mercatorProjection(mercatorRaw).scale(961 / tau$3);
  };

  function mercatorProjection(project) {
    var m = projection(project),
        center = m.center,
        scale = m.scale,
        translate = m.translate,
        clipExtent = m.clipExtent,
        x0 = null,
        y0,
        x1,
        y1; // clip extent

    m.scale = function (_) {
      return arguments.length ? (scale(_), reclip()) : scale();
    };

    m.translate = function (_) {
      return arguments.length ? (translate(_), reclip()) : translate();
    };

    m.center = function (_) {
      return arguments.length ? (center(_), reclip()) : center();
    };

    m.clipExtent = function (_) {
      return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    };

    function reclip() {
      var k = pi$3 * scale(),
          t = m(rotation(m.rotate()).invert([0, 0]));
      return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
    }

    return reclip();
  }

  function tany(y) {
    return tan((halfPi$2 + y) / 2);
  }

  function conicConformalRaw(y0, y1) {
    var cy0 = cos$1(y0),
        n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),
        f = cy0 * pow(tany(y0), n) / n;

    if (!n) return mercatorRaw;

    function project(x, y) {
      if (f > 0) {
        if (y < -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2;
      } else {
        if (y > halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2;
      }
      var r = f / pow(tany(y), n);
      return [r * sin$1(n * x), f - r * cos$1(n * x)];
    }

    project.invert = function (x, y) {
      var fy = f - y,
          r = sign(n) * sqrt(x * x + fy * fy);
      return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi$2];
    };

    return project;
  }

  var conicConformal = function () {
    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
  };

  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }

  equirectangularRaw.invert = equirectangularRaw;

  var equirectangular = function () {
    return projection(equirectangularRaw).scale(152.63);
  };

  function conicEquidistantRaw(y0, y1) {
    var cy0 = cos$1(y0),
        n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
        g = cy0 / n + y0;

    if (abs(n) < epsilon$2) return equirectangularRaw;

    function project(x, y) {
      var gy = g - y,
          nx = n * x;
      return [gy * sin$1(nx), g - gy * cos$1(nx)];
    }

    project.invert = function (x, y) {
      var gy = g - y;
      return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
    };

    return project;
  }

  var conicEquidistant = function () {
    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
  };

  function gnomonicRaw(x, y) {
    var cy = cos$1(y),
        k = cos$1(x) * cy;
    return [cy * sin$1(x) / k, sin$1(y) / k];
  }

  gnomonicRaw.invert = azimuthalInvert(atan);

  var gnomonic = function () {
    return projection(gnomonicRaw).scale(144.049).clipAngle(60);
  };

  function scaleTranslate(kx, ky, tx, ty) {
    return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$4 : transformer({
      point: function (x, y) {
        this.stream.point(x * kx + tx, y * ky + ty);
      }
    });
  }

  var identity$5 = function () {
    var k = 1,
        tx = 0,
        ty = 0,
        sx = 1,
        sy = 1,
        transform = identity$4,
        // scale, translate and reflect
    x0 = null,
        y0,
        x1,
        y1,
        clip = identity$4,
        // clip extent
    cache,
        cacheStream,
        projection;

    function reset() {
      cache = cacheStream = null;
      return projection;
    }

    return projection = {
      stream: function (stream) {
        return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));
      },
      clipExtent: function (_) {
        return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      },
      scale: function (_) {
        return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
      },
      translate: function (_) {
        return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
      },
      reflectX: function (_) {
        return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
      },
      reflectY: function (_) {
        return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
      },
      fitExtent: function (extent, object) {
        return fitExtent(projection, extent, object);
      },
      fitSize: function (size, object) {
        return fitSize(projection, size, object);
      }
    };
  };

  function orthographicRaw(x, y) {
    return [cos$1(y) * sin$1(x), sin$1(y)];
  }

  orthographicRaw.invert = azimuthalInvert(asin);

  var orthographic = function () {
    return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$2);
  };

  function stereographicRaw(x, y) {
    var cy = cos$1(y),
        k = 1 + cos$1(x) * cy;
    return [cy * sin$1(x) / k, sin$1(y) / k];
  }

  stereographicRaw.invert = azimuthalInvert(function (z) {
    return 2 * atan(z);
  });

  var stereographic = function () {
    return projection(stereographicRaw).scale(250).clipAngle(142);
  };

  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi$2 + phi) / 2)), -lambda];
  }

  transverseMercatorRaw.invert = function (x, y) {
    return [-y, 2 * atan(exp(x)) - halfPi$2];
  };

  var transverseMercator = function () {
    var m = mercatorProjection(transverseMercatorRaw),
        center = m.center,
        rotate = m.rotate;

    m.center = function (_) {
      return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
    };

    m.rotate = function (_) {
      return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
    };

    return rotate([0, 0, 90]).scale(159.155);
  };

  function defaultSeparation(a, b) {
    return a.parent === b.parent ? 1 : 2;
  }

  function meanX(children) {
    return children.reduce(meanXReduce, 0) / children.length;
  }

  function meanXReduce(x, c) {
    return x + c.x;
  }

  function maxY(children) {
    return 1 + children.reduce(maxYReduce, 0);
  }

  function maxYReduce(y, c) {
    return Math.max(y, c.y);
  }

  function leafLeft(node) {
    var children;
    while (children = node.children) node = children[0];
    return node;
  }

  function leafRight(node) {
    var children;
    while (children = node.children) node = children[children.length - 1];
    return node;
  }

  var cluster = function () {
    var separation = defaultSeparation,
        dx = 1,
        dy = 1,
        nodeSize = false;

    function cluster(root) {
      var previousNode,
          x = 0;

      // First walk, computing the initial x & y values.
      root.eachAfter(function (node) {
        var children = node.children;
        if (children) {
          node.x = meanX(children);
          node.y = maxY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });

      var left = leafLeft(root),
          right = leafRight(root),
          x0 = left.x - separation(left, right) / 2,
          x1 = right.x + separation(right, left) / 2;

      // Second walk, normalizing x & y to the desired size.
      return root.eachAfter(nodeSize ? function (node) {
        node.x = (node.x - root.x) * dx;
        node.y = (root.y - node.y) * dy;
      } : function (node) {
        node.x = (node.x - x0) / (x1 - x0) * dx;
        node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
      });
    }

    cluster.separation = function (x) {
      return arguments.length ? (separation = x, cluster) : separation;
    };

    cluster.size = function (x) {
      return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
    };

    cluster.nodeSize = function (x) {
      return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
    };

    return cluster;
  };

  function count(node) {
    var sum = 0,
        children = node.children,
        i = children && children.length;
    if (!i) sum = 1;else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }

  var node_count = function () {
    return this.eachAfter(count);
  };

  var node_each = function (callback) {
    var node = this,
        current,
        next = [node],
        children,
        i,
        n;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        callback(node), children = node.children;
        if (children) for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    } while (next.length);
    return this;
  };

  var node_eachBefore = function (callback) {
    var node = this,
        nodes = [node],
        children,
        i;
    while (node = nodes.pop()) {
      callback(node), children = node.children;
      if (children) for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
    return this;
  };

  var node_eachAfter = function (callback) {
    var node = this,
        nodes = [node],
        next = [],
        children,
        i,
        n;
    while (node = nodes.pop()) {
      next.push(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
    while (node = next.pop()) {
      callback(node);
    }
    return this;
  };

  var node_sum = function (value) {
    return this.eachAfter(function (node) {
      var sum = +value(node.data) || 0,
          children = node.children,
          i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  };

  var node_sort = function (compare) {
    return this.eachBefore(function (node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  };

  var node_path = function (end) {
    var start = this,
        ancestor = leastCommonAncestor(start, end),
        nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  };

  function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
        bNodes = b.ancestors(),
        c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }

  var node_ancestors = function () {
    var node = this,
        nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  };

  var node_descendants = function () {
    var nodes = [];
    this.each(function (node) {
      nodes.push(node);
    });
    return nodes;
  };

  var node_leaves = function () {
    var leaves = [];
    this.eachBefore(function (node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  };

  var node_links = function () {
    var root = this,
        links = [];
    root.each(function (node) {
      if (node !== root) {
        // Don’t include the root’s parent, if any.
        links.push({ source: node.parent, target: node });
      }
    });
    return links;
  };

  function hierarchy(data, children) {
    var root = new Node(data),
        valued = +data.value && (root.value = data.value),
        node,
        nodes = [root],
        child,
        childs,
        i,
        n;

    if (children == null) children = defaultChildren;

    while (node = nodes.pop()) {
      if (valued) node.value = +node.data.value;
      if ((childs = children(node.data)) && (n = childs.length)) {
        node.children = new Array(n);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new Node(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }

    return root.eachBefore(computeHeight);
  }

  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }

  function defaultChildren(d) {
    return d.children;
  }

  function copyData(node) {
    node.data = node.data.data;
  }

  function computeHeight(node) {
    var height = 0;
    do node.height = height; while ((node = node.parent) && node.height < ++height);
  }

  function Node(data) {
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
  }

  Node.prototype = hierarchy.prototype = {
    constructor: Node,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy
  };

  function Node$2(value) {
    this._ = value;
    this.next = null;
  }

  var shuffle$1 = function (array) {
    var i,
        n = (array = array.slice()).length,
        head = null,
        node = head;

    while (n) {
      var next = new Node$2(array[n - 1]);
      if (node) node = node.next = next;else node = head = next;
      array[i] = array[--n];
    }

    return {
      head: head,
      tail: node
    };
  };

  var enclose = function (circles) {
    return encloseN(shuffle$1(circles), []);
  };

  function encloses(a, b) {
    var dx = b.x - a.x,
        dy = b.y - a.y,
        dr = a.r - b.r;
    return dr * dr + 1e-6 > dx * dx + dy * dy;
  }

  // Returns the smallest circle that contains circles L and intersects circles B.
  function encloseN(L, B) {
    var circle,
        l0 = null,
        l1 = L.head,
        l2,
        p1;

    switch (B.length) {
      case 1:
        circle = enclose1(B[0]);break;
      case 2:
        circle = enclose2(B[0], B[1]);break;
      case 3:
        circle = enclose3(B[0], B[1], B[2]);break;
    }

    while (l1) {
      p1 = l1._, l2 = l1.next;
      if (!circle || !encloses(circle, p1)) {

        // Temporarily truncate L before l1.
        if (l0) L.tail = l0, l0.next = null;else L.head = L.tail = null;

        B.push(p1);
        circle = encloseN(L, B); // Note: reorders L!
        B.pop();

        // Move l1 to the front of L and reconnect the truncated list L.
        if (L.head) l1.next = L.head, L.head = l1;else l1.next = null, L.head = L.tail = l1;
        l0 = L.tail, l0.next = l2;
      } else {
        l0 = l1;
      }
      l1 = l2;
    }

    L.tail = l0;
    return circle;
  }

  function enclose1(a) {
    return {
      x: a.x,
      y: a.y,
      r: a.r
    };
  }

  function enclose2(a, b) {
    var x1 = a.x,
        y1 = a.y,
        r1 = a.r,
        x2 = b.x,
        y2 = b.y,
        r2 = b.r,
        x21 = x2 - x1,
        y21 = y2 - y1,
        r21 = r2 - r1,
        l = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x1 + x2 + x21 / l * r21) / 2,
      y: (y1 + y2 + y21 / l * r21) / 2,
      r: (l + r1 + r2) / 2
    };
  }

  function enclose3(a, b, c) {
    var x1 = a.x,
        y1 = a.y,
        r1 = a.r,
        x2 = b.x,
        y2 = b.y,
        r2 = b.r,
        x3 = c.x,
        y3 = c.y,
        r3 = c.r,
        a2 = 2 * (x1 - x2),
        b2 = 2 * (y1 - y2),
        c2 = 2 * (r2 - r1),
        d2 = x1 * x1 + y1 * y1 - r1 * r1 - x2 * x2 - y2 * y2 + r2 * r2,
        a3 = 2 * (x1 - x3),
        b3 = 2 * (y1 - y3),
        c3 = 2 * (r3 - r1),
        d3 = x1 * x1 + y1 * y1 - r1 * r1 - x3 * x3 - y3 * y3 + r3 * r3,
        ab = a3 * b2 - a2 * b3,
        xa = (b2 * d3 - b3 * d2) / ab - x1,
        xb = (b3 * c2 - b2 * c3) / ab,
        ya = (a3 * d2 - a2 * d3) / ab - y1,
        yb = (a2 * c3 - a3 * c2) / ab,
        A = xb * xb + yb * yb - 1,
        B = 2 * (xa * xb + ya * yb + r1),
        C = xa * xa + ya * ya - r1 * r1,
        r = (-B - Math.sqrt(B * B - 4 * A * C)) / (2 * A);
    return {
      x: xa + xb * r + x1,
      y: ya + yb * r + y1,
      r: r
    };
  }

  function place(a, b, c) {
    var ax = a.x,
        ay = a.y,
        da = b.r + c.r,
        db = a.r + c.r,
        dx = b.x - ax,
        dy = b.y - ay,
        dc = dx * dx + dy * dy;
    if (dc) {
      var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
          y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = ax + x * dx + y * dy;
      c.y = ay + x * dy - y * dx;
    } else {
      c.x = ax + db;
      c.y = ay;
    }
  }

  function intersects(a, b) {
    var dx = b.x - a.x,
        dy = b.y - a.y,
        dr = a.r + b.r;
    return dr * dr - 1e-6 > dx * dx + dy * dy;
  }

  function distance2(node, x, y) {
    var a = node._,
        b = node.next._,
        ab = a.r + b.r,
        dx = (a.x * b.r + b.x * a.r) / ab - x,
        dy = (a.y * b.r + b.y * a.r) / ab - y;
    return dx * dx + dy * dy;
  }

  function Node$1(circle) {
    this._ = circle;
    this.next = null;
    this.previous = null;
  }

  function packEnclose(circles) {
    if (!(n = circles.length)) return 0;

    var a, b, c, n;

    // Place the first circle.
    a = circles[0], a.x = 0, a.y = 0;
    if (!(n > 1)) return a.r;

    // Place the second circle.
    b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
    if (!(n > 2)) return a.r + b.r;

    // Place the third circle.
    place(b, a, c = circles[2]);

    // Initialize the weighted centroid.
    var aa = a.r * a.r,
        ba = b.r * b.r,
        ca = c.r * c.r,
        oa = aa + ba + ca,
        ox = aa * a.x + ba * b.x + ca * c.x,
        oy = aa * a.y + ba * b.y + ca * c.y,
        cx,
        cy,
        i,
        j,
        k,
        sj,
        sk;

    // Initialize the front-chain using the first three circles a, b and c.
    a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
    a.next = c.previous = b;
    b.next = a.previous = c;
    c.next = b.previous = a;

    // Attempt to place each remaining circle…
    pack: for (i = 3; i < n; ++i) {
      place(a._, b._, c = circles[i]), c = new Node$1(c);

      // Find the closest intersecting circle on the front-chain, if any.
      // “Closeness” is determined by linear distance along the front-chain.
      // “Ahead” or “behind” is likewise determined by linear distance.
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);

      // Success! Insert the new circle c between a and b.
      c.previous = a, c.next = b, a.next = b.previous = b = c;

      // Update the weighted centroid.
      oa += ca = c._.r * c._.r;
      ox += ca * c._.x;
      oy += ca * c._.y;

      // Compute the new closest circle pair to the centroid.
      aa = distance2(a, cx = ox / oa, cy = oy / oa);
      while ((c = c.next) !== b) {
        if ((ca = distance2(c, cx, cy)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }

    // Compute the enclosing circle of the front chain.
    a = [b._], c = b;while ((c = c.next) !== b) a.push(c._);c = enclose(a);

    // Translate the circles to put the enclosing circle around the origin.
    for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

    return c.r;
  }

  var siblings = function (circles) {
    packEnclose(circles);
    return circles;
  };

  function optional(f) {
    return f == null ? null : required(f);
  }

  function required(f) {
    if (typeof f !== "function") throw new Error();
    return f;
  }

  function constantZero() {
    return 0;
  }

  var constant$8 = function (x) {
    return function () {
      return x;
    };
  };

  function defaultRadius$1(d) {
    return Math.sqrt(d.value);
  }

  var index$2 = function () {
    var radius = null,
        dx = 1,
        dy = 1,
        padding = constantZero;

    function pack(root) {
      root.x = dx / 2, root.y = dy / 2;
      if (radius) {
        root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
      } else {
        root.eachBefore(radiusLeaf(defaultRadius$1)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
      }
      return root;
    }

    pack.radius = function (x) {
      return arguments.length ? (radius = optional(x), pack) : radius;
    };

    pack.size = function (x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
    };

    pack.padding = function (x) {
      return arguments.length ? (padding = typeof x === "function" ? x : constant$8(+x), pack) : padding;
    };

    return pack;
  };

  function radiusLeaf(radius) {
    return function (node) {
      if (!node.children) {
        node.r = Math.max(0, +radius(node) || 0);
      }
    };
  }

  function packChildren(padding, k) {
    return function (node) {
      if (children = node.children) {
        var children,
            i,
            n = children.length,
            r = padding(node) * k || 0,
            e;

        if (r) for (i = 0; i < n; ++i) children[i].r += r;
        e = packEnclose(children);
        if (r) for (i = 0; i < n; ++i) children[i].r -= r;
        node.r = e + r;
      }
    };
  }

  function translateChild(k) {
    return function (node) {
      var parent = node.parent;
      node.r *= k;
      if (parent) {
        node.x = parent.x + k * node.x;
        node.y = parent.y + k * node.y;
      }
    };
  }

  var roundNode = function (node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  };

  var treemapDice = function (parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (x1 - x0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.y0 = y0, node.y1 = y1;
      node.x0 = x0, node.x1 = x0 += node.value * k;
    }
  };

  var partition = function () {
    var dx = 1,
        dy = 1,
        padding = 0,
        round = false;

    function partition(root) {
      var n = root.height + 1;
      root.x0 = root.y0 = padding;
      root.x1 = dx;
      root.y1 = dy / n;
      root.eachBefore(positionNode(dy, n));
      if (round) root.eachBefore(roundNode);
      return root;
    }

    function positionNode(dy, n) {
      return function (node) {
        if (node.children) {
          treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
        }
        var x0 = node.x0,
            y0 = node.y0,
            x1 = node.x1 - padding,
            y1 = node.y1 - padding;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
      };
    }

    partition.round = function (x) {
      return arguments.length ? (round = !!x, partition) : round;
    };

    partition.size = function (x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
    };

    partition.padding = function (x) {
      return arguments.length ? (padding = +x, partition) : padding;
    };

    return partition;
  };

  var keyPrefix$1 = "$";
  var preroot = { depth: -1 };
  var ambiguous = {};

  function defaultId(d) {
    return d.id;
  }

  function defaultParentId(d) {
    return d.parentId;
  }

  var stratify = function () {
    var id = defaultId,
        parentId = defaultParentId;

    function stratify(data) {
      var d,
          i,
          n = data.length,
          root,
          parent,
          node,
          nodes = new Array(n),
          nodeId,
          nodeKey,
          nodeByKey = {};

      for (i = 0; i < n; ++i) {
        d = data[i], node = nodes[i] = new Node(d);
        if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
          nodeKey = keyPrefix$1 + (node.id = nodeId);
          nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
        }
      }

      for (i = 0; i < n; ++i) {
        node = nodes[i], nodeId = parentId(data[i], i, data);
        if (nodeId == null || !(nodeId += "")) {
          if (root) throw new Error("multiple roots");
          root = node;
        } else {
          parent = nodeByKey[keyPrefix$1 + nodeId];
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);else parent.children = [node];
          node.parent = parent;
        }
      }

      if (!root) throw new Error("no root");
      root.parent = preroot;
      root.eachBefore(function (node) {
        node.depth = node.parent.depth + 1;--n;
      }).eachBefore(computeHeight);
      root.parent = null;
      if (n > 0) throw new Error("cycle");

      return root;
    }

    stratify.id = function (x) {
      return arguments.length ? (id = required(x), stratify) : id;
    };

    stratify.parentId = function (x) {
      return arguments.length ? (parentId = required(x), stratify) : parentId;
    };

    return stratify;
  };

  function defaultSeparation$1(a, b) {
    return a.parent === b.parent ? 1 : 2;
  }

  // function radialSeparation(a, b) {
  //   return (a.parent === b.parent ? 1 : 2) / a.depth;
  // }

  // This function is used to traverse the left contour of a subtree (or
  // subforest). It returns the successor of v on this contour. This successor is
  // either given by the leftmost child of v or by the thread of v. The function
  // returns null if and only if v is on the highest level of its subtree.
  function nextLeft(v) {
    var children = v.children;
    return children ? children[0] : v.t;
  }

  // This function works analogously to nextLeft.
  function nextRight(v) {
    var children = v.children;
    return children ? children[children.length - 1] : v.t;
  }

  // Shifts the current subtree rooted at w+. This is done by increasing
  // prelim(w+) and mod(w+) by shift.
  function moveSubtree(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }

  // All other shifts, applied to the smaller subtrees between w- and w+, are
  // performed by this function. To prepare the shifts, we have to adjust
  // change(w+), shift(w+), and change(w-).
  function executeShifts(v) {
    var shift = 0,
        change = 0,
        children = v.children,
        i = children.length,
        w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }

  // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
  // returns the specified (default) ancestor.
  function nextAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }

  function TreeNode(node, i) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null; // default ancestor
    this.a = this; // ancestor
    this.z = 0; // prelim
    this.m = 0; // mod
    this.c = 0; // change
    this.s = 0; // shift
    this.t = null; // thread
    this.i = i; // number
  }

  TreeNode.prototype = Object.create(Node.prototype);

  function treeRoot(root) {
    var tree = new TreeNode(root, 0),
        node,
        nodes = [tree],
        child,
        children,
        i,
        n;

    while (node = nodes.pop()) {
      if (children = node._.children) {
        node.children = new Array(n = children.length);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new TreeNode(children[i], i));
          child.parent = node;
        }
      }
    }

    (tree.parent = new TreeNode(null, 0)).children = [tree];
    return tree;
  }

  // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
  var tree = function () {
    var separation = defaultSeparation$1,
        dx = 1,
        dy = 1,
        nodeSize = null;

    function tree(root) {
      var t = treeRoot(root);

      // Compute the layout using Buchheim et al.’s algorithm.
      t.eachAfter(firstWalk), t.parent.m = -t.z;
      t.eachBefore(secondWalk);

      // If a fixed node size is specified, scale x and y.
      if (nodeSize) root.eachBefore(sizeNode);

      // If a fixed tree size is specified, scale x and y based on the extent.
      // Compute the left-most, right-most, and depth-most nodes for extents.
      else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function (node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function (node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

      return root;
    }

    // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
    // applied recursively to the children of v, as well as the function
    // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
    // node v is placed to the midpoint of its outermost children.
    function firstWalk(v) {
      var children = v.children,
          siblings = v.parent.children,
          w = v.i ? siblings[v.i - 1] : null;
      if (children) {
        executeShifts(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }

    // Computes all real x-coordinates by summing up the modifiers recursively.
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }

    // The core of the algorithm. Here, a new subtree is combined with the
    // previous subtrees. Threads are used to traverse the inside and outside
    // contours of the left and right subtree up to the highest common level. The
    // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
    // superscript o means outside and i means inside, the subscript - means left
    // subtree and + means right subtree. For summing up the modifiers along the
    // contour, we use respective variables si+, si-, so-, and so+. Whenever two
    // nodes of the inside contours conflict, we compute the left one of the
    // greatest uncommon ancestors using the function ANCESTOR and call MOVE
    // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
    // Finally, we add a new thread (if necessary).
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v,
            vop = v,
            vim = w,
            vom = vip.parent.children[0],
            sip = vip.m,
            sop = vop.m,
            sim = vim.m,
            som = vom.m,
            shift;
        while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
          vom = nextLeft(vom);
          vop = nextRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }

    function sizeNode(node) {
      node.x *= dx;
      node.y = node.depth * dy;
    }

    tree.separation = function (x) {
      return arguments.length ? (separation = x, tree) : separation;
    };

    tree.size = function (x) {
      return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
    };

    tree.nodeSize = function (x) {
      return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
    };

    return tree;
  };

  var treemapSlice = function (parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        node,
        i = -1,
        n = nodes.length,
        k = parent.value && (y1 - y0) / parent.value;

    while (++i < n) {
      node = nodes[i], node.x0 = x0, node.x1 = x1;
      node.y0 = y0, node.y1 = y0 += node.value * k;
    }
  };

  var phi = (1 + Math.sqrt(5)) / 2;

  function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
    var rows = [],
        nodes = parent.children,
        row,
        nodeValue,
        i0 = 0,
        i1 = 0,
        n = nodes.length,
        dx,
        dy,
        value = parent.value,
        sumValue,
        minValue,
        maxValue,
        newRatio,
        minRatio,
        alpha,
        beta;

    while (i0 < n) {
      dx = x1 - x0, dy = y1 - y0;

      // Find the next non-empty node.
      do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);

      // Keep adding nodes while the aspect ratio maintains or improves.
      for (; i1 < n; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) {
          sumValue -= nodeValue;break;
        }
        minRatio = newRatio;
      }

      // Position and record the row orientation.
      rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
      if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
      value -= sumValue, i0 = i1;
    }

    return rows;
  }

  var squarify = function custom(ratio) {

    function squarify(parent, x0, y0, x1, y1) {
      squarifyRatio(ratio, parent, x0, y0, x1, y1);
    }

    squarify.ratio = function (x) {
      return custom((x = +x) > 1 ? x : 1);
    };

    return squarify;
  }(phi);

  var index$3 = function () {
    var tile = squarify,
        round = false,
        dx = 1,
        dy = 1,
        paddingStack = [0],
        paddingInner = constantZero,
        paddingTop = constantZero,
        paddingRight = constantZero,
        paddingBottom = constantZero,
        paddingLeft = constantZero;

    function treemap(root) {
      root.x0 = root.y0 = 0;
      root.x1 = dx;
      root.y1 = dy;
      root.eachBefore(positionNode);
      paddingStack = [0];
      if (round) root.eachBefore(roundNode);
      return root;
    }

    function positionNode(node) {
      var p = paddingStack[node.depth],
          x0 = node.x0 + p,
          y0 = node.y0 + p,
          x1 = node.x1 - p,
          y1 = node.y1 - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
      if (node.children) {
        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x0 += paddingLeft(node) - p;
        y0 += paddingTop(node) - p;
        x1 -= paddingRight(node) - p;
        y1 -= paddingBottom(node) - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        tile(node, x0, y0, x1, y1);
      }
    }

    treemap.round = function (x) {
      return arguments.length ? (round = !!x, treemap) : round;
    };

    treemap.size = function (x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
    };

    treemap.tile = function (x) {
      return arguments.length ? (tile = required(x), treemap) : tile;
    };

    treemap.padding = function (x) {
      return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
    };

    treemap.paddingInner = function (x) {
      return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$8(+x), treemap) : paddingInner;
    };

    treemap.paddingOuter = function (x) {
      return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
    };

    treemap.paddingTop = function (x) {
      return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$8(+x), treemap) : paddingTop;
    };

    treemap.paddingRight = function (x) {
      return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$8(+x), treemap) : paddingRight;
    };

    treemap.paddingBottom = function (x) {
      return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$8(+x), treemap) : paddingBottom;
    };

    treemap.paddingLeft = function (x) {
      return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$8(+x), treemap) : paddingLeft;
    };

    return treemap;
  };

  var binary = function (parent, x0, y0, x1, y1) {
    var nodes = parent.children,
        i,
        n = nodes.length,
        sum,
        sums = new Array(n + 1);

    for (sums[0] = sum = i = 0; i < n; ++i) {
      sums[i + 1] = sum += nodes[i].value;
    }

    partition(0, n, parent.value, x0, y0, x1, y1);

    function partition(i, j, value, x0, y0, x1, y1) {
      if (i >= j - 1) {
        var node = nodes[i];
        node.x0 = x0, node.y0 = y0;
        node.x1 = x1, node.y1 = y1;
        return;
      }

      var valueOffset = sums[i],
          valueTarget = value / 2 + valueOffset,
          k = i + 1,
          hi = j - 1;

      while (k < hi) {
        var mid = k + hi >>> 1;
        if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
      }

      if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;

      var valueLeft = sums[k] - valueOffset,
          valueRight = value - valueLeft;

      if (x1 - x0 > y1 - y0) {
        var xk = (x0 * valueRight + x1 * valueLeft) / value;
        partition(i, k, valueLeft, x0, y0, xk, y1);
        partition(k, j, valueRight, xk, y0, x1, y1);
      } else {
        var yk = (y0 * valueRight + y1 * valueLeft) / value;
        partition(i, k, valueLeft, x0, y0, x1, yk);
        partition(k, j, valueRight, x0, yk, x1, y1);
      }
    }
  };

  var sliceDice = function (parent, x0, y0, x1, y1) {
    (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
  };

  var resquarify = function custom(ratio) {

    function resquarify(parent, x0, y0, x1, y1) {
      if ((rows = parent._squarify) && rows.ratio === ratio) {
        var rows,
            row,
            nodes,
            i,
            j = -1,
            n,
            m = rows.length,
            value = parent.value;

        while (++j < m) {
          row = rows[j], nodes = row.children;
          for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
          if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
          value -= row.value;
        }
      } else {
        parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
        rows.ratio = ratio;
      }
    }

    resquarify.ratio = function (x) {
      return custom((x = +x) > 1 ? x : 1);
    };

    return resquarify;
  }(phi);

  var area$1 = function (polygon) {
    var i = -1,
        n = polygon.length,
        a,
        b = polygon[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = polygon[i];
      area += a[1] * b[0] - a[0] * b[1];
    }

    return area / 2;
  };

  var centroid$1 = function (polygon) {
    var i = -1,
        n = polygon.length,
        x = 0,
        y = 0,
        a,
        b = polygon[n - 1],
        c,
        k = 0;

    while (++i < n) {
      a = b;
      b = polygon[i];
      k += c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }

    return k *= 3, [x / k, y / k];
  };

  // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
  // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
  // right, +y is up). Returns a positive value if ABC is counter-clockwise,
  // negative if clockwise, and zero if the points are collinear.
  var cross$1 = function (a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  };

  function lexicographicOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }

  // Computes the upper convex hull per the monotone chain algorithm.
  // Assumes points.length >= 3, is sorted by x, unique in y.
  // Returns an array of indices into points in left-to-right order.
  function computeUpperHullIndexes(points) {
    var n = points.length,
        indexes = [0, 1],
        size = 2;

    for (var i = 2; i < n; ++i) {
      while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
      indexes[size++] = i;
    }

    return indexes.slice(0, size); // remove popped points
  }

  var hull = function (points) {
    if ((n = points.length) < 3) return null;

    var i,
        n,
        sortedPoints = new Array(n),
        flippedPoints = new Array(n);

    for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
    sortedPoints.sort(lexicographicOrder);
    for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

    var upperIndexes = computeUpperHullIndexes(sortedPoints),
        lowerIndexes = computeUpperHullIndexes(flippedPoints);

    // Construct the hull polygon, removing possible duplicate endpoints.
    var skipLeft = lowerIndexes[0] === upperIndexes[0],
        skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
        hull = [];

    // Add upper hull in right-to-l order.
    // Then add lower hull in left-to-right order.
    for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

    return hull;
  };

  var contains$1 = function (polygon, point) {
    var n = polygon.length,
        p = polygon[n - 1],
        x = point[0],
        y = point[1],
        x0 = p[0],
        y0 = p[1],
        x1,
        y1,
        inside = false;

    for (var i = 0; i < n; ++i) {
      p = polygon[i], x1 = p[0], y1 = p[1];
      if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
      x0 = x1, y0 = y1;
    }

    return inside;
  };

  var length$2 = function (polygon) {
    var i = -1,
        n = polygon.length,
        b = polygon[n - 1],
        xa,
        ya,
        xb = b[0],
        yb = b[1],
        perimeter = 0;

    while (++i < n) {
      xa = xb;
      ya = yb;
      b = polygon[i];
      xb = b[0];
      yb = b[1];
      xa -= xb;
      ya -= yb;
      perimeter += Math.sqrt(xa * xa + ya * ya);
    }

    return perimeter;
  };

  var slice$3 = [].slice;

  var noabort = {};

  function Queue(size) {
    this._size = size;
    this._call = this._error = null;
    this._tasks = [];
    this._data = [];
    this._waiting = this._active = this._ended = this._start = 0; // inside a synchronous task callback?
  }

  Queue.prototype = queue.prototype = {
    constructor: Queue,
    defer: function (callback) {
      if (typeof callback !== "function") throw new Error("invalid callback");
      if (this._call) throw new Error("defer after await");
      if (this._error != null) return this;
      var t = slice$3.call(arguments, 1);
      t.push(callback);
      ++this._waiting, this._tasks.push(t);
      poke$1(this);
      return this;
    },
    abort: function () {
      if (this._error == null) abort(this, new Error("abort"));
      return this;
    },
    await: function (callback) {
      if (typeof callback !== "function") throw new Error("invalid callback");
      if (this._call) throw new Error("multiple await");
      this._call = function (error, results) {
        callback.apply(null, [error].concat(results));
      };
      maybeNotify(this);
      return this;
    },
    awaitAll: function (callback) {
      if (typeof callback !== "function") throw new Error("invalid callback");
      if (this._call) throw new Error("multiple await");
      this._call = callback;
      maybeNotify(this);
      return this;
    }
  };

  function poke$1(q) {
    if (!q._start) {
      try {
        start$1(q);
      } // let the current task complete
      catch (e) {
        if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
        else if (!q._data) throw e; // await callback errored synchronously
      }
    }
  }

  function start$1(q) {
    while (q._start = q._waiting && q._active < q._size) {
      var i = q._ended + q._active,
          t = q._tasks[i],
          j = t.length - 1,
          c = t[j];
      t[j] = end(q, i);
      --q._waiting, ++q._active;
      t = c.apply(null, t);
      if (!q._tasks[i]) continue; // task finished synchronously
      q._tasks[i] = t || noabort;
    }
  }

  function end(q, i) {
    return function (e, r) {
      if (!q._tasks[i]) return; // ignore multiple callbacks
      --q._active, ++q._ended;
      q._tasks[i] = null;
      if (q._error != null) return; // ignore secondary errors
      if (e != null) {
        abort(q, e);
      } else {
        q._data[i] = r;
        if (q._waiting) poke$1(q);else maybeNotify(q);
      }
    };
  }

  function abort(q, e) {
    var i = q._tasks.length,
        t;
    q._error = e; // ignore active callbacks
    q._data = undefined; // allow gc
    q._waiting = NaN; // prevent starting

    while (--i >= 0) {
      if (t = q._tasks[i]) {
        q._tasks[i] = null;
        if (t.abort) {
          try {
            t.abort();
          } catch (e) {/* ignore */}
        }
      }
    }

    q._active = NaN; // allow notification
    maybeNotify(q);
  }

  function maybeNotify(q) {
    if (!q._active && q._call) {
      var d = q._data;
      q._data = undefined; // allow gc
      q._call(q._error, d);
    }
  }

  function queue(concurrency) {
    if (concurrency == null) concurrency = Infinity;else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
    return new Queue(concurrency);
  }

  var defaultSource$1 = function () {
    return Math.random();
  };

  var uniform = function sourceRandomUniform(source) {
    function randomUniform(min, max) {
      min = min == null ? 0 : +min;
      max = max == null ? 1 : +max;
      if (arguments.length === 1) max = min, min = 0;else max -= min;
      return function () {
        return source() * max + min;
      };
    }

    randomUniform.source = sourceRandomUniform;

    return randomUniform;
  }(defaultSource$1);

  var normal = function sourceRandomNormal(source) {
    function randomNormal(mu, sigma) {
      var x, r;
      mu = mu == null ? 0 : +mu;
      sigma = sigma == null ? 1 : +sigma;
      return function () {
        var y;

        // If available, use the second previously-generated uniform random.
        if (x != null) y = x, x = null;

        // Otherwise, generate a new x and y.
        else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

        return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
      };
    }

    randomNormal.source = sourceRandomNormal;

    return randomNormal;
  }(defaultSource$1);

  var logNormal = function sourceRandomLogNormal(source) {
    function randomLogNormal() {
      var randomNormal = normal.source(source).apply(this, arguments);
      return function () {
        return Math.exp(randomNormal());
      };
    }

    randomLogNormal.source = sourceRandomLogNormal;

    return randomLogNormal;
  }(defaultSource$1);

  var irwinHall = function sourceRandomIrwinHall(source) {
    function randomIrwinHall(n) {
      return function () {
        for (var sum = 0, i = 0; i < n; ++i) sum += source();
        return sum;
      };
    }

    randomIrwinHall.source = sourceRandomIrwinHall;

    return randomIrwinHall;
  }(defaultSource$1);

  var bates = function sourceRandomBates(source) {
    function randomBates(n) {
      var randomIrwinHall = irwinHall.source(source)(n);
      return function () {
        return randomIrwinHall() / n;
      };
    }

    randomBates.source = sourceRandomBates;

    return randomBates;
  }(defaultSource$1);

  var exponential$1 = function sourceRandomExponential(source) {
    function randomExponential(lambda) {
      return function () {
        return -Math.log(1 - source()) / lambda;
      };
    }

    randomExponential.source = sourceRandomExponential;

    return randomExponential;
  }(defaultSource$1);

  var request = function (url, callback) {
    var request,
        event = dispatch("beforesend", "progress", "load", "error"),
        mimeType,
        headers = map$1(),
        xhr = new XMLHttpRequest(),
        user = null,
        password = null,
        response,
        responseType,
        timeout = 0;

    // If IE does not support CORS, use XDomainRequest.
    if (typeof XDomainRequest !== "undefined" && !("withCredentials" in xhr) && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest();

    "onload" in xhr ? xhr.onload = xhr.onerror = xhr.ontimeout = respond : xhr.onreadystatechange = function (o) {
      xhr.readyState > 3 && respond(o);
    };

    function respond(o) {
      var status = xhr.status,
          result;
      if (!status && hasResponse(xhr) || status >= 200 && status < 300 || status === 304) {
        if (response) {
          try {
            result = response.call(request, xhr);
          } catch (e) {
            event.call("error", request, e);
            return;
          }
        } else {
          result = xhr;
        }
        event.call("load", request, result);
      } else {
        event.call("error", request, o);
      }
    }

    xhr.onprogress = function (e) {
      event.call("progress", request, e);
    };

    request = {
      header: function (name, value) {
        name = (name + "").toLowerCase();
        if (arguments.length < 2) return headers.get(name);
        if (value == null) headers.remove(name);else headers.set(name, value + "");
        return request;
      },

      // If mimeType is non-null and no Accept header is set, a default is used.
      mimeType: function (value) {
        if (!arguments.length) return mimeType;
        mimeType = value == null ? null : value + "";
        return request;
      },

      // Specifies what type the response value should take;
      // for instance, arraybuffer, blob, document, or text.
      responseType: function (value) {
        if (!arguments.length) return responseType;
        responseType = value;
        return request;
      },

      timeout: function (value) {
        if (!arguments.length) return timeout;
        timeout = +value;
        return request;
      },

      user: function (value) {
        return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
      },

      password: function (value) {
        return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
      },

      // Specify how to convert the response content to a specific type;
      // changes the callback value on "load" events.
      response: function (value) {
        response = value;
        return request;
      },

      // Alias for send("GET", …).
      get: function (data, callback) {
        return request.send("GET", data, callback);
      },

      // Alias for send("POST", …).
      post: function (data, callback) {
        return request.send("POST", data, callback);
      },

      // If callback is non-null, it will be used for error and load events.
      send: function (method, data, callback) {
        xhr.open(method, url, true, user, password);
        if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
        if (xhr.setRequestHeader) headers.each(function (value, name) {
          xhr.setRequestHeader(name, value);
        });
        if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
        if (responseType != null) xhr.responseType = responseType;
        if (timeout > 0) xhr.timeout = timeout;
        if (callback == null && typeof data === "function") callback = data, data = null;
        if (callback != null && callback.length === 1) callback = fixCallback(callback);
        if (callback != null) request.on("error", callback).on("load", function (xhr) {
          callback(null, xhr);
        });
        event.call("beforesend", request, xhr);
        xhr.send(data == null ? null : data);
        return request;
      },

      abort: function () {
        xhr.abort();
        return request;
      },

      on: function () {
        var value = event.on.apply(event, arguments);
        return value === event ? request : value;
      }
    };

    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return request.get(callback);
    }

    return request;
  };

  function fixCallback(callback) {
    return function (error, xhr) {
      callback(error == null ? xhr : null);
    };
  }

  function hasResponse(xhr) {
    var type = xhr.responseType;
    return type && type !== "text" ? xhr.response // null on error
    : xhr.responseText; // "" on error
  }

  var type$1 = function (defaultMimeType, response) {
    return function (url, callback) {
      var r = request(url).mimeType(defaultMimeType).response(response);
      if (callback != null) {
        if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
        return r.get(callback);
      }
      return r;
    };
  };

  var html = type$1("text/html", function (xhr) {
    return document.createRange().createContextualFragment(xhr.responseText);
  });

  var json = type$1("application/json", function (xhr) {
    return JSON.parse(xhr.responseText);
  });

  var text = type$1("text/plain", function (xhr) {
    return xhr.responseText;
  });

  var xml = type$1("application/xml", function (xhr) {
    var xml = xhr.responseXML;
    if (!xml) throw new Error("parse error");
    return xml;
  });

  var dsv$1 = function (defaultMimeType, parse) {
    return function (url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var r = request(url).mimeType(defaultMimeType);
      r.row = function (_) {
        return arguments.length ? r.response(responseOf(parse, row = _)) : row;
      };
      r.row(row);
      return callback ? r.get(callback) : r;
    };
  };

  function responseOf(parse, row) {
    return function (request$$1) {
      return parse(request$$1.responseText, row);
    };
  }

  var csv$1 = dsv$1("text/csv", csvParse);

  var tsv$1 = dsv$1("text/tab-separated-values", tsvParse);

  var array$2 = Array.prototype;

  var map$3 = array$2.map;
  var slice$4 = array$2.slice;

  var implicit = { name: "implicit" };

  function ordinal(range) {
    var index = map$1(),
        domain = [],
        unknown = implicit;

    range = range == null ? [] : slice$4.call(range);

    function scale(d) {
      var key = d + "",
          i = index.get(key);
      if (!i) {
        if (unknown !== implicit) return unknown;
        index.set(key, i = domain.push(d));
      }
      return range[(i - 1) % range.length];
    }

    scale.domain = function (_) {
      if (!arguments.length) return domain.slice();
      domain = [], index = map$1();
      var i = -1,
          n = _.length,
          d,
          key;
      while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
      return scale;
    };

    scale.range = function (_) {
      return arguments.length ? (range = slice$4.call(_), scale) : range.slice();
    };

    scale.unknown = function (_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    scale.copy = function () {
      return ordinal().domain(domain).range(range).unknown(unknown);
    };

    return scale;
  }

  function band() {
    var scale = ordinal().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range,
        range$$1 = [0, 1],
        step,
        bandwidth,
        round = false,
        paddingInner = 0,
        paddingOuter = 0,
        align = 0.5;

    delete scale.unknown;

    function rescale() {
      var n = domain().length,
          reverse = range$$1[1] < range$$1[0],
          start = range$$1[reverse - 0],
          stop = range$$1[1 - reverse];
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round) step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = sequence(n).map(function (i) {
        return start + step * i;
      });
      return ordinalRange(reverse ? values.reverse() : values);
    }

    scale.domain = function (_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.range = function (_) {
      return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
    };

    scale.rangeRound = function (_) {
      return range$$1 = [+_[0], +_[1]], round = true, rescale();
    };

    scale.bandwidth = function () {
      return bandwidth;
    };

    scale.step = function () {
      return step;
    };

    scale.round = function (_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };

    scale.padding = function (_) {
      return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingInner = function (_) {
      return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
    };

    scale.paddingOuter = function (_) {
      return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
    };

    scale.align = function (_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };

    scale.copy = function () {
      return band().domain(domain()).range(range$$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };

    return rescale();
  }

  function pointish(scale) {
    var copy = scale.copy;

    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;

    scale.copy = function () {
      return pointish(copy());
    };

    return scale;
  }

  function point$1() {
    return pointish(band().paddingInner(1));
  }

  var constant$9 = function (x) {
    return function () {
      return x;
    };
  };

  var number$1 = function (x) {
    return +x;
  };

  var unit = [0, 1];

  function deinterpolateLinear(a, b) {
    return (b -= a = +a) ? function (x) {
      return (x - a) / b;
    } : constant$9(b);
  }

  function deinterpolateClamp(deinterpolate) {
    return function (a, b) {
      var d = deinterpolate(a = +a, b = +b);
      return function (x) {
        return x <= a ? 0 : x >= b ? 1 : d(x);
      };
    };
  }

  function reinterpolateClamp(reinterpolate) {
    return function (a, b) {
      var r = reinterpolate(a = +a, b = +b);
      return function (t) {
        return t <= 0 ? a : t >= 1 ? b : r(t);
      };
    };
  }

  function bimap(domain, range$$1, deinterpolate, reinterpolate) {
    var d0 = domain[0],
        d1 = domain[1],
        r0 = range$$1[0],
        r1 = range$$1[1];
    if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
    return function (x) {
      return r0(d0(x));
    };
  }

  function polymap(domain, range$$1, deinterpolate, reinterpolate) {
    var j = Math.min(domain.length, range$$1.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range$$1 = range$$1.slice().reverse();
    }

    while (++i < j) {
      d[i] = deinterpolate(domain[i], domain[i + 1]);
      r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
    }

    return function (x) {
      var i = bisectRight(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());
  }

  // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
  function continuous(deinterpolate, reinterpolate) {
    var domain = unit,
        range$$1 = unit,
        interpolate$$1 = interpolateValue,
        clamp = false,
        piecewise,
        output,
        input;

    function rescale() {
      piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
    }

    scale.invert = function (y) {
      return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
    };

    scale.domain = function (_) {
      return arguments.length ? (domain = map$3.call(_, number$1), rescale()) : domain.slice();
    };

    scale.range = function (_) {
      return arguments.length ? (range$$1 = slice$4.call(_), rescale()) : range$$1.slice();
    };

    scale.rangeRound = function (_) {
      return range$$1 = slice$4.call(_), interpolate$$1 = interpolateRound, rescale();
    };

    scale.clamp = function (_) {
      return arguments.length ? (clamp = !!_, rescale()) : clamp;
    };

    scale.interpolate = function (_) {
      return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
    };

    return rescale();
  }

  var tickFormat = function (domain, count, specifier) {
    var start = domain[0],
        stop = domain[domain.length - 1],
        step = tickStep(start, stop, count == null ? 10 : count),
        precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s":
        {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return exports.formatPrefix(specifier, value);
        }
      case "":
      case "e":
      case "g":
      case "p":
      case "r":
        {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
      case "f":
      case "%":
        {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
    }
    return exports.format(specifier);
  };

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function (count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function (count, specifier) {
      return tickFormat(domain(), count, specifier);
    };

    scale.nice = function (count) {
      if (count == null) count = 10;

      var d = domain(),
          i0 = 0,
          i1 = d.length - 1,
          start = d[i0],
          stop = d[i1],
          step;

      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }

      step = tickIncrement(start, stop, count);

      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count);
      }

      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        domain(d);
      }

      return scale;
    };

    return scale;
  }

  function linear$2() {
    var scale = continuous(deinterpolateLinear, reinterpolate);

    scale.copy = function () {
      return copy(scale, linear$2());
    };

    return linearish(scale);
  }

  function identity$6() {
    var domain = [0, 1];

    function scale(x) {
      return +x;
    }

    scale.invert = scale;

    scale.domain = scale.range = function (_) {
      return arguments.length ? (domain = map$3.call(_, number$1), scale) : domain.slice();
    };

    scale.copy = function () {
      return identity$6().domain(domain);
    };

    return linearish(scale);
  }

  var nice = function (domain, interval) {
    domain = domain.slice();

    var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;

    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }

    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  };

  function deinterpolate(a, b) {
    return (b = Math.log(b / a)) ? function (x) {
      return Math.log(x / a) / b;
    } : constant$9(b);
  }

  function reinterpolate$1(a, b) {
    return a < 0 ? function (t) {
      return -Math.pow(-b, t) * Math.pow(-a, 1 - t);
    } : function (t) {
      return Math.pow(b, t) * Math.pow(a, 1 - t);
    };
  }

  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }

  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
      return Math.pow(base, x);
    };
  }

  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
      return Math.log(x) / base;
    });
  }

  function reflect(f) {
    return function (x) {
      return -f(-x);
    };
  }

  function log$1() {
    var scale = continuous(deinterpolate, reinterpolate$1).domain([1, 10]),
        domain = scale.domain,
        base = 10,
        logs = logp(10),
        pows = powp(10);

    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
      return scale;
    }

    scale.base = function (_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };

    scale.domain = function (_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };

    scale.ticks = function (count) {
      var d = domain(),
          u = d[0],
          v = d[d.length - 1],
          r;

      if (r = v < u) i = u, u = v, v = i;

      var i = logs(u),
          j = logs(v),
          p,
          k,
          t,
          n = count == null ? 10 : +count,
          z = [];

      if (!(base % 1) && j - i < n) {
        i = Math.round(i) - 1, j = Math.round(j) + 1;
        if (u > 0) for (; i < j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        } else for (; i < j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
      } else {
        z = ticks(i, j, Math.min(j - i, n)).map(pows);
      }

      return r ? z.reverse() : z;
    };

    scale.tickFormat = function (count, specifier) {
      if (specifier == null) specifier = base === 10 ? ".0e" : ",";
      if (typeof specifier !== "function") specifier = exports.format(specifier);
      if (count === Infinity) return specifier;
      if (count == null) count = 10;
      var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
      return function (d) {
        var i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };

    scale.nice = function () {
      return domain(nice(domain(), {
        floor: function (x) {
          return pows(Math.floor(logs(x)));
        },
        ceil: function (x) {
          return pows(Math.ceil(logs(x)));
        }
      }));
    };

    scale.copy = function () {
      return copy(scale, log$1().base(base));
    };

    return scale;
  }

  function raise$1(x, exponent) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  }

  function pow$1() {
    var exponent = 1,
        scale = continuous(deinterpolate, reinterpolate),
        domain = scale.domain;

    function deinterpolate(a, b) {
      return (b = raise$1(b, exponent) - (a = raise$1(a, exponent))) ? function (x) {
        return (raise$1(x, exponent) - a) / b;
      } : constant$9(b);
    }

    function reinterpolate(a, b) {
      b = raise$1(b, exponent) - (a = raise$1(a, exponent));
      return function (t) {
        return raise$1(a + b * t, 1 / exponent);
      };
    }

    scale.exponent = function (_) {
      return arguments.length ? (exponent = +_, domain(domain())) : exponent;
    };

    scale.copy = function () {
      return copy(scale, pow$1().exponent(exponent));
    };

    return linearish(scale);
  }

  function sqrt$1() {
    return pow$1().exponent(0.5);
  }

  function quantile$$1() {
    var domain = [],
        range$$1 = [],
        thresholds = [];

    function rescale() {
      var i = 0,
          n = Math.max(1, range$$1.length);
      thresholds = new Array(n - 1);
      while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
      return scale;
    }

    function scale(x) {
      if (!isNaN(x = +x)) return range$$1[bisectRight(thresholds, x)];
    }

    scale.invertExtent = function (y) {
      var i = range$$1.indexOf(y);
      return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
    };

    scale.domain = function (_) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
      domain.sort(ascending);
      return rescale();
    };

    scale.range = function (_) {
      return arguments.length ? (range$$1 = slice$4.call(_), rescale()) : range$$1.slice();
    };

    scale.quantiles = function () {
      return thresholds.slice();
    };

    scale.copy = function () {
      return quantile$$1().domain(domain).range(range$$1);
    };

    return scale;
  }

  function quantize$1() {
    var x0 = 0,
        x1 = 1,
        n = 1,
        domain = [0.5],
        range$$1 = [0, 1];

    function scale(x) {
      if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];
    }

    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }

    scale.domain = function (_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
    };

    scale.range = function (_) {
      return arguments.length ? (n = (range$$1 = slice$4.call(_)).length - 1, rescale()) : range$$1.slice();
    };

    scale.invertExtent = function (y) {
      var i = range$$1.indexOf(y);
      return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
    };

    scale.copy = function () {
      return quantize$1().domain([x0, x1]).range(range$$1);
    };

    return linearish(scale);
  }

  function threshold$1() {
    var domain = [0.5],
        range$$1 = [0, 1],
        n = 1;

    function scale(x) {
      if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];
    }

    scale.domain = function (_) {
      return arguments.length ? (domain = slice$4.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
    };

    scale.range = function (_) {
      return arguments.length ? (range$$1 = slice$4.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
    };

    scale.invertExtent = function (y) {
      var i = range$$1.indexOf(y);
      return [domain[i - 1], domain[i]];
    };

    scale.copy = function () {
      return threshold$1().domain(domain).range(range$$1);
    };

    return scale;
  }

  var t0$1 = new Date();
  var t1$1 = new Date();

  function newInterval(floori, offseti, count, field) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.ceil = function (date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };

    interval.round = function (date) {
      var d0 = interval(date),
          d1 = interval.ceil(date);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.offset = function (date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function (start, stop, step) {
      var range = [];
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      do range.push(new Date(+start)); while ((offseti(start, step), floori(start), start < stop));
      return range;
    };

    interval.filter = function (test) {
      return newInterval(function (date) {
        if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
      }, function (date, step) {
        if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty
      });
    };

    if (count) {
      interval.count = function (start, end) {
        t0$1.setTime(+start), t1$1.setTime(+end);
        floori(t0$1), floori(t1$1);
        return Math.floor(count(t0$1, t1$1));
      };

      interval.every = function (step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
          return field(d) % step === 0;
        } : function (d) {
          return interval.count(0, d) % step === 0;
        });
      };
    }

    return interval;
  }

  var millisecond = newInterval(function () {
    // noop
  }, function (date, step) {
    date.setTime(+date + step);
  }, function (start, end) {
    return end - start;
  });

  // An optimized implementation for this simple case.
  millisecond.every = function (k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return newInterval(function (date) {
      date.setTime(Math.floor(date / k) * k);
    }, function (date, step) {
      date.setTime(+date + step * k);
    }, function (start, end) {
      return (end - start) / k;
    });
  };

  var milliseconds = millisecond.range;

  var durationSecond$1 = 1e3;
  var durationMinute$1 = 6e4;
  var durationHour$1 = 36e5;
  var durationDay$1 = 864e5;
  var durationWeek$1 = 6048e5;

  var second = newInterval(function (date) {
    date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1);
  }, function (date, step) {
    date.setTime(+date + step * durationSecond$1);
  }, function (start, end) {
    return (end - start) / durationSecond$1;
  }, function (date) {
    return date.getUTCSeconds();
  });

  var seconds = second.range;

  var minute = newInterval(function (date) {
    date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1);
  }, function (date, step) {
    date.setTime(+date + step * durationMinute$1);
  }, function (start, end) {
    return (end - start) / durationMinute$1;
  }, function (date) {
    return date.getMinutes();
  });

  var minutes = minute.range;

  var hour = newInterval(function (date) {
    var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1;
    if (offset < 0) offset += durationHour$1;
    date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset);
  }, function (date, step) {
    date.setTime(+date + step * durationHour$1);
  }, function (start, end) {
    return (end - start) / durationHour$1;
  }, function (date) {
    return date.getHours();
  });

  var hours = hour.range;

  var day = newInterval(function (date) {
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
  }, function (date) {
    return date.getDate() - 1;
  });

  var days = day.range;

  function weekday(i) {
    return newInterval(function (date) {
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function (start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);
  var tuesday = weekday(2);
  var wednesday = weekday(3);
  var thursday = weekday(4);
  var friday = weekday(5);
  var saturday = weekday(6);

  var sundays = sunday.range;
  var mondays = monday.range;
  var tuesdays = tuesday.range;
  var wednesdays = wednesday.range;
  var thursdays = thursday.range;
  var fridays = friday.range;
  var saturdays = saturday.range;

  var month = newInterval(function (date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setMonth(date.getMonth() + step);
  }, function (start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, function (date) {
    return date.getMonth();
  });

  var months = month.range;

  var year = newInterval(function (date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function (start, end) {
    return end.getFullYear() - start.getFullYear();
  }, function (date) {
    return date.getFullYear();
  });

  // An optimized implementation for this simple case.
  year.every = function (k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setFullYear(date.getFullYear() + step * k);
    });
  };

  var years = year.range;

  var utcMinute = newInterval(function (date) {
    date.setUTCSeconds(0, 0);
  }, function (date, step) {
    date.setTime(+date + step * durationMinute$1);
  }, function (start, end) {
    return (end - start) / durationMinute$1;
  }, function (date) {
    return date.getUTCMinutes();
  });

  var utcMinutes = utcMinute.range;

  var utcHour = newInterval(function (date) {
    date.setUTCMinutes(0, 0, 0);
  }, function (date, step) {
    date.setTime(+date + step * durationHour$1);
  }, function (start, end) {
    return (end - start) / durationHour$1;
  }, function (date) {
    return date.getUTCHours();
  });

  var utcHours = utcHour.range;

  var utcDay = newInterval(function (date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function (start, end) {
    return (end - start) / durationDay$1;
  }, function (date) {
    return date.getUTCDate() - 1;
  });

  var utcDays = utcDay.range;

  function utcWeekday(i) {
    return newInterval(function (date) {
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function (start, end) {
      return (end - start) / durationWeek$1;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);

  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;

  var utcMonth = newInterval(function (date) {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function (start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, function (date) {
    return date.getUTCMonth();
  });

  var utcMonths = utcMonth.range;

  var utcYear = newInterval(function (date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function (start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, function (date) {
    return date.getUTCFullYear();
  });

  // An optimized implementation for this simple case.
  utcYear.every = function (k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
  };

  var utcYears = utcYear.range;

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newYear(y) {
    return { y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 };
  }

  function formatLocale$1(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "S": formatSeconds,
      "U": formatWeekNumberSunday,
      "w": formatWeekdayNumber,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "S": formatUTCSeconds,
      "U": formatUTCWeekNumberSunday,
      "w": formatUTCWeekdayNumber,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "S": parseSeconds,
      "U": parseWeekNumberSunday,
      "w": parseWeekdayNumber,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function (date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        if (!(date instanceof Date)) date = new Date(+date);

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
            if (format = formats[c]) c = format(date, pad);
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, newDate) {
      return function (string) {
        var d = newYear(1900),
            i = parseSpecifier(d, specifier, string += "", 0);
        if (i != string.length) return null;

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // Convert day-of-week and week-of-year to day-of-year.
        if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          var day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
        }

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        return newDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || (j = parse(d, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    return {
      format: function (specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function () {
          return specifier;
        };
        return f;
      },
      parse: function (specifier) {
        var p = newParse(specifier += "", localDate);
        p.toString = function () {
          return specifier;
        };
        return p;
      },
      utcFormat: function (specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function () {
          return specifier;
        };
        return f;
      },
      utcParse: function (specifier) {
        var p = newParse(specifier, utcDate);
        p.toString = function () {
          return specifier;
        };
        return p;
      }
    };
  }

  var pads = { "-": "", "_": " ", "0": "0" };
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  function pad(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    var map = {},
        i = -1,
        n = names.length;
    while (++i < n) map[names[i].toLowerCase()] = i;
    return map;
  }

  function parseWeekdayNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad(1 + day.count(year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }

  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }

  function formatWeekNumberSunday(d, p) {
    return pad(sunday.count(year(d), d), p, 2);
  }

  function formatWeekdayNumber(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad(monday.count(year(d), d), p, 2);
  }

  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d), d), p, 2);
  }

  function formatUTCWeekdayNumber(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d), d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  var locale$2;

  defaultLocale$1({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  function defaultLocale$1(definition) {
    locale$2 = formatLocale$1(definition);
    exports.timeFormat = locale$2.format;
    exports.timeParse = locale$2.parse;
    exports.utcFormat = locale$2.utcFormat;
    exports.utcParse = locale$2.utcParse;
    return locale$2;
  }

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

  function formatIsoNative(date) {
    return date.toISOString();
  }

  var formatIso = Date.prototype.toISOString ? formatIsoNative : exports.utcFormat(isoSpecifier);

  function parseIsoNative(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  }

  var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : exports.utcParse(isoSpecifier);

  var durationSecond = 1000;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;

  function date$1(t) {
    return new Date(t);
  }

  function number$2(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }

  function calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {
    var scale = continuous(deinterpolateLinear, reinterpolate),
        invert = scale.invert,
        domain = scale.domain;

    var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");

    var tickIntervals = [[second$$1, 1, durationSecond], [second$$1, 5, 5 * durationSecond], [second$$1, 15, 15 * durationSecond], [second$$1, 30, 30 * durationSecond], [minute$$1, 1, durationMinute], [minute$$1, 5, 5 * durationMinute], [minute$$1, 15, 15 * durationMinute], [minute$$1, 30, 30 * durationMinute], [hour$$1, 1, durationHour], [hour$$1, 3, 3 * durationHour], [hour$$1, 6, 6 * durationHour], [hour$$1, 12, 12 * durationHour], [day$$1, 1, durationDay], [day$$1, 2, 2 * durationDay], [week, 1, durationWeek], [month$$1, 1, durationMonth], [month$$1, 3, 3 * durationMonth], [year$$1, 1, durationYear]];

    function tickFormat(date) {
      return (second$$1(date) < date ? formatMillisecond : minute$$1(date) < date ? formatSecond : hour$$1(date) < date ? formatMinute : day$$1(date) < date ? formatHour : month$$1(date) < date ? week(date) < date ? formatDay : formatWeek : year$$1(date) < date ? formatMonth : formatYear)(date);
    }

    function tickInterval(interval, start, stop, step) {
      if (interval == null) interval = 10;

      // If a desired tick count is specified, pick a reasonable tick interval
      // based on the extent of the domain and a rough estimate of tick size.
      // Otherwise, assume interval is already a time interval and use it.
      if (typeof interval === "number") {
        var target = Math.abs(stop - start) / interval,
            i = bisector(function (i) {
          return i[2];
        }).right(tickIntervals, target);
        if (i === tickIntervals.length) {
          step = tickStep(start / durationYear, stop / durationYear, interval);
          interval = year$$1;
        } else if (i) {
          i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
          step = i[1];
          interval = i[0];
        } else {
          step = tickStep(start, stop, interval);
          interval = millisecond$$1;
        }
      }

      return step == null ? interval : interval.every(step);
    }

    scale.invert = function (y) {
      return new Date(invert(y));
    };

    scale.domain = function (_) {
      return arguments.length ? domain(map$3.call(_, number$2)) : domain().map(date$1);
    };

    scale.ticks = function (interval, step) {
      var d = domain(),
          t0 = d[0],
          t1 = d[d.length - 1],
          r = t1 < t0,
          t;
      if (r) t = t0, t0 = t1, t1 = t;
      t = tickInterval(interval, t0, t1, step);
      t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
      return r ? t.reverse() : t;
    };

    scale.tickFormat = function (count, specifier) {
      return specifier == null ? tickFormat : format(specifier);
    };

    scale.nice = function (interval, step) {
      var d = domain();
      return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;
    };

    scale.copy = function () {
      return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));
    };

    return scale;
  }

  var time = function () {
    return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
  };

  var utcTime = function () {
    return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
  };

  var colors = function (s) {
    return s.match(/.{6}/g).map(function (x) {
      return "#" + x;
    });
  };

  var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

  var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

  var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

  var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

  var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

  var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

  var rainbow = cubehelix();

  var rainbow$1 = function (t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    rainbow.h = 360 * t - 100;
    rainbow.s = 1.5 - 1.5 * ts;
    rainbow.l = 0.8 - 0.9 * ts;
    return rainbow + "";
  };

  function ramp(range) {
    var n = range.length;
    return function (t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

  var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

  var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

  var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  function sequential(interpolator) {
    var x0 = 0,
        x1 = 1,
        clamp = false;

    function scale(x) {
      var t = (x - x0) / (x1 - x0);
      return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
    }

    scale.domain = function (_) {
      return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
    };

    scale.clamp = function (_) {
      return arguments.length ? (clamp = !!_, scale) : clamp;
    };

    scale.interpolator = function (_) {
      return arguments.length ? (interpolator = _, scale) : interpolator;
    };

    scale.copy = function () {
      return sequential(interpolator).domain([x0, x1]).clamp(clamp);
    };

    return linearish(scale);
  }

  var constant$10 = function (x) {
    return function constant() {
      return x;
    };
  };

  var abs$1 = Math.abs;
  var atan2$1 = Math.atan2;
  var cos$2 = Math.cos;
  var max$2 = Math.max;
  var min$1 = Math.min;
  var sin$2 = Math.sin;
  var sqrt$2 = Math.sqrt;

  var epsilon$3 = 1e-12;
  var pi$4 = Math.PI;
  var halfPi$3 = pi$4 / 2;
  var tau$4 = 2 * pi$4;

  function acos$1(x) {
    return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
  }

  function asin$1(x) {
    return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
  }

  function arcInnerRadius(d) {
    return d.innerRadius;
  }

  function arcOuterRadius(d) {
    return d.outerRadius;
  }

  function arcStartAngle(d) {
    return d.startAngle;
  }

  function arcEndAngle(d) {
    return d.endAngle;
  }

  function arcPadAngle(d) {
    return d && d.padAngle; // Note: optional!
  }

  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0,
        y10 = y1 - y0,
        x32 = x3 - x2,
        y32 = y3 - y2,
        t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
    return [x0 + t * x10, y0 + t * y10];
  }

  // Compute perpendicular offset line of length rc.
  // http://mathworld.wolfram.com/Circle-LineIntersection.html
  function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
    var x01 = x0 - x1,
        y01 = y0 - y1,
        lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
        ox = lo * y01,
        oy = -lo * x01,
        x11 = x0 + ox,
        y11 = y0 + oy,
        x10 = x1 + ox,
        y10 = y1 + oy,
        x00 = (x11 + x10) / 2,
        y00 = (y11 + y10) / 2,
        dx = x10 - x11,
        dy = y10 - y11,
        d2 = dx * dx + dy * dy,
        r = r1 - rc,
        D = x11 * y10 - x10 * y11,
        d = (dy < 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),
        cx0 = (D * dy - dx * d) / d2,
        cy0 = (-D * dx - dy * d) / d2,
        cx1 = (D * dy + dx * d) / d2,
        cy1 = (-D * dx + dy * d) / d2,
        dx0 = cx0 - x00,
        dy0 = cy0 - y00,
        dx1 = cx1 - x00,
        dy1 = cy1 - y00;

    // Pick the closer of the two intersection points.
    // TODO Is there a faster way to determine which intersection to use?
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }

  var arc = function () {
    var innerRadius = arcInnerRadius,
        outerRadius = arcOuterRadius,
        cornerRadius = constant$10(0),
        padRadius = null,
        startAngle = arcStartAngle,
        endAngle = arcEndAngle,
        padAngle = arcPadAngle,
        context = null;

    function arc() {
      var buffer,
          r,
          r0 = +innerRadius.apply(this, arguments),
          r1 = +outerRadius.apply(this, arguments),
          a0 = startAngle.apply(this, arguments) - halfPi$3,
          a1 = endAngle.apply(this, arguments) - halfPi$3,
          da = abs$1(a1 - a0),
          cw = a1 > a0;

      if (!context) context = buffer = path();

      // Ensure that the outer radius is always larger than the inner radius.
      if (r1 < r0) r = r1, r1 = r0, r0 = r;

      // Is it a point?
      if (!(r1 > epsilon$3)) context.moveTo(0, 0);

      // Or is it a circle or annulus?
      else if (da > tau$4 - epsilon$3) {
          context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon$3) {
            context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
            var a01 = a0,
                a11 = a1,
                a00 = a0,
                a10 = a1,
                da0 = da,
                da1 = da,
                ap = padAngle.apply(this, arguments) / 2,
                rp = ap > epsilon$3 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
                rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
                rc0 = rc,
                rc1 = rc,
                t0,
                t1;

            // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
            if (rp > epsilon$3) {
              var p0 = asin$1(rp / r0 * sin$2(ap)),
                  p1 = asin$1(rp / r1 * sin$2(ap));
              if ((da0 -= p0 * 2) > epsilon$3) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
              if ((da1 -= p1 * 2) > epsilon$3) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
            }

            var x01 = r1 * cos$2(a01),
                y01 = r1 * sin$2(a01),
                x10 = r0 * cos$2(a10),
                y10 = r0 * sin$2(a10);

            // Apply rounded corners?
            if (rc > epsilon$3) {
              var x11 = r1 * cos$2(a11),
                  y11 = r1 * sin$2(a11),
                  x00 = r0 * cos$2(a00),
                  y00 = r0 * sin$2(a00);

              // Restrict the corner radius according to the sector angle.
              if (da < pi$4) {
                var oc = da0 > epsilon$3 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
                    ax = x01 - oc[0],
                    ay = y01 - oc[1],
                    bx = x11 - oc[0],
                    by = y11 - oc[1],
                    kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
                    lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = min$1(rc, (r0 - lc) / (kc - 1));
                rc1 = min$1(rc, (r1 - lc) / (kc + 1));
              }
            }

            // Is the sector collapsed to a line?
            if (!(da1 > epsilon$3)) context.moveTo(x01, y01);

            // Does the sector’s outer ring have rounded corners?
            else if (rc1 > epsilon$3) {
                t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
                t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

                context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

                // Have the corners merged?
                if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

                // Otherwise, draw the two corners and the ring.
                else {
                    context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
                    context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                    context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
                  }
              }

              // Or is the outer ring just a circular arc?
              else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

            // Is there no inner ring, and it’s a circular sector?
            // Or perhaps it’s an annular sector collapsed due to padding?
            if (!(r0 > epsilon$3) || !(da0 > epsilon$3)) context.lineTo(x10, y10);

            // Does the sector’s inner ring (or point) have rounded corners?
            else if (rc0 > epsilon$3) {
                t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
                t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

                context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

                // Have the corners merged?
                if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

                // Otherwise, draw the two corners and the ring.
                else {
                    context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
                    context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                    context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
                  }
              }

              // Or is the inner ring just a circular arc?
              else context.arc(0, 0, r0, a10, a00, cw);
          }

      context.closePath();

      if (buffer) return context = null, buffer + "" || null;
    }

    arc.centroid = function () {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
          a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
      return [cos$2(a) * r, sin$2(a) * r];
    };

    arc.innerRadius = function (_) {
      return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : innerRadius;
    };

    arc.outerRadius = function (_) {
      return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : outerRadius;
    };

    arc.cornerRadius = function (_) {
      return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : cornerRadius;
    };

    arc.padRadius = function (_) {
      return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), arc) : padRadius;
    };

    arc.startAngle = function (_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : startAngle;
    };

    arc.endAngle = function (_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : endAngle;
    };

    arc.padAngle = function (_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : padAngle;
    };

    arc.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, arc) : context;
    };

    return arc;
  };

  function Linear(context) {
    this._context = context;
  }

  Linear.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
        case 1:
          this._point = 2; // proceed
        default:
          this._context.lineTo(x, y);break;
      }
    }
  };

  var curveLinear = function (context) {
    return new Linear(context);
  };

  function x$3(p) {
    return p[0];
  }

  function y$3(p) {
    return p[1];
  }

  var line = function () {
    var x$$1 = x$3,
        y$$1 = y$3,
        defined = constant$10(true),
        context = null,
        curve = curveLinear,
        output = null;

    function line(data) {
      var i,
          n = data.length,
          d,
          defined0 = false,
          buffer;

      if (context == null) output = curve(buffer = path());

      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) output.lineStart();else output.lineEnd();
        }
        if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
      }

      if (buffer) return output = null, buffer + "" || null;
    }

    line.x = function (_) {
      return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$10(+_), line) : x$$1;
    };

    line.y = function (_) {
      return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$10(+_), line) : y$$1;
    };

    line.defined = function (_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant$10(!!_), line) : defined;
    };

    line.curve = function (_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };

    line.context = function (_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };

    return line;
  };

  var area$2 = function () {
    var x0 = x$3,
        x1 = null,
        y0 = constant$10(0),
        y1 = y$3,
        defined = constant$10(true),
        context = null,
        curve = curveLinear,
        output = null;

    function area(data) {
      var i,
          j,
          k,
          n = data.length,
          d,
          defined0 = false,
          buffer,
          x0z = new Array(n),
          y0z = new Array(n);

      if (context == null) output = curve(buffer = path());

      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k = i - 1; k >= j; --k) {
              output.point(x0z[k], y0z[k]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
          output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
        }
      }

      if (buffer) return output = null, buffer + "" || null;
    }

    function arealine() {
      return line().defined(defined).curve(curve).context(context);
    }

    area.x = function (_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$10(+_), x1 = null, area) : x0;
    };

    area.x0 = function (_) {
      return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$10(+_), area) : x0;
    };

    area.x1 = function (_) {
      return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), area) : x1;
    };

    area.y = function (_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$10(+_), y1 = null, area) : y0;
    };

    area.y0 = function (_) {
      return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$10(+_), area) : y0;
    };

    area.y1 = function (_) {
      return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), area) : y1;
    };

    area.lineX0 = area.lineY0 = function () {
      return arealine().x(x0).y(y0);
    };

    area.lineY1 = function () {
      return arealine().x(x0).y(y1);
    };

    area.lineX1 = function () {
      return arealine().x(x1).y(y0);
    };

    area.defined = function (_) {
      return arguments.length ? (defined = typeof _ === "function" ? _ : constant$10(!!_), area) : defined;
    };

    area.curve = function (_) {
      return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
    };

    area.context = function (_) {
      return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
    };

    return area;
  };

  var descending$1 = function (a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };

  var identity$7 = function (d) {
    return d;
  };

  var pie = function () {
    var value = identity$7,
        sortValues = descending$1,
        sort = null,
        startAngle = constant$10(0),
        endAngle = constant$10(tau$4),
        padAngle = constant$10(0);

    function pie(data) {
      var i,
          n = data.length,
          j,
          k,
          sum = 0,
          index = new Array(n),
          arcs = new Array(n),
          a0 = +startAngle.apply(this, arguments),
          da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
          a1,
          p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
          pa = p * (da < 0 ? -1 : 1),
          v;

      for (i = 0; i < n; ++i) {
        if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
          sum += v;
        }
      }

      // Optionally sort the arcs by previously-computed values or by data.
      if (sortValues != null) index.sort(function (i, j) {
        return sortValues(arcs[i], arcs[j]);
      });else if (sort != null) index.sort(function (i, j) {
        return sort(data[i], data[j]);
      });

      // Compute the arcs! They are stored in the original data's order.
      for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
        j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
          data: data[j],
          index: i,
          value: v,
          startAngle: a0,
          endAngle: a1,
          padAngle: p
        };
      }

      return arcs;
    }

    pie.value = function (_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$10(+_), pie) : value;
    };

    pie.sortValues = function (_) {
      return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
    };

    pie.sort = function (_) {
      return arguments.length ? (sort = _, sortValues = null, pie) : sort;
    };

    pie.startAngle = function (_) {
      return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : startAngle;
    };

    pie.endAngle = function (_) {
      return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : endAngle;
    };

    pie.padAngle = function (_) {
      return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : padAngle;
    };

    return pie;
  };

  var curveRadialLinear = curveRadial(curveLinear);

  function Radial(curve) {
    this._curve = curve;
  }

  Radial.prototype = {
    areaStart: function () {
      this._curve.areaStart();
    },
    areaEnd: function () {
      this._curve.areaEnd();
    },
    lineStart: function () {
      this._curve.lineStart();
    },
    lineEnd: function () {
      this._curve.lineEnd();
    },
    point: function (a, r) {
      this._curve.point(r * Math.sin(a), r * -Math.cos(a));
    }
  };

  function curveRadial(curve) {

    function radial(context) {
      return new Radial(curve(context));
    }

    radial._curve = curve;

    return radial;
  }

  function radialLine(l) {
    var c = l.curve;

    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;

    l.curve = function (_) {
      return arguments.length ? c(curveRadial(_)) : c()._curve;
    };

    return l;
  }

  var radialLine$1 = function () {
    return radialLine(line().curve(curveRadialLinear));
  };

  var radialArea = function () {
    var a = area$2().curve(curveRadialLinear),
        c = a.curve,
        x0 = a.lineX0,
        x1 = a.lineX1,
        y0 = a.lineY0,
        y1 = a.lineY1;

    a.angle = a.x, delete a.x;
    a.startAngle = a.x0, delete a.x0;
    a.endAngle = a.x1, delete a.x1;
    a.radius = a.y, delete a.y;
    a.innerRadius = a.y0, delete a.y0;
    a.outerRadius = a.y1, delete a.y1;
    a.lineStartAngle = function () {
      return radialLine(x0());
    }, delete a.lineX0;
    a.lineEndAngle = function () {
      return radialLine(x1());
    }, delete a.lineX1;
    a.lineInnerRadius = function () {
      return radialLine(y0());
    }, delete a.lineY0;
    a.lineOuterRadius = function () {
      return radialLine(y1());
    }, delete a.lineY1;

    a.curve = function (_) {
      return arguments.length ? c(curveRadial(_)) : c()._curve;
    };

    return a;
  };

  var slice$5 = Array.prototype.slice;

  var radialPoint = function (x, y) {
    return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
  };

  function linkSource(d) {
    return d.source;
  }

  function linkTarget(d) {
    return d.target;
  }

  function link$2(curve) {
    var source = linkSource,
        target = linkTarget,
        x$$1 = x$3,
        y$$1 = y$3,
        context = null;

    function link() {
      var buffer,
          argv = slice$5.call(arguments),
          s = source.apply(this, argv),
          t = target.apply(this, argv);
      if (!context) context = buffer = path();
      curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
      if (buffer) return context = null, buffer + "" || null;
    }

    link.source = function (_) {
      return arguments.length ? (source = _, link) : source;
    };

    link.target = function (_) {
      return arguments.length ? (target = _, link) : target;
    };

    link.x = function (_) {
      return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$10(+_), link) : x$$1;
    };

    link.y = function (_) {
      return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$10(+_), link) : y$$1;
    };

    link.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, link) : context;
    };

    return link;
  }

  function curveHorizontal(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
  }

  function curveVertical(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
  }

  function curveRadial$1(context, x0, y0, x1, y1) {
    var p0 = radialPoint(x0, y0),
        p1 = radialPoint(x0, y0 = (y0 + y1) / 2),
        p2 = radialPoint(x1, y0),
        p3 = radialPoint(x1, y1);
    context.moveTo(p0[0], p0[1]);
    context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
  }

  function linkHorizontal() {
    return link$2(curveHorizontal);
  }

  function linkVertical() {
    return link$2(curveVertical);
  }

  function linkRadial() {
    var l = link$2(curveRadial$1);
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    return l;
  }

  var circle$2 = {
    draw: function (context, size) {
      var r = Math.sqrt(size / pi$4);
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, tau$4);
    }
  };

  var cross$2 = {
    draw: function (context, size) {
      var r = Math.sqrt(size / 5) / 2;
      context.moveTo(-3 * r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, -3 * r);
      context.lineTo(r, -3 * r);
      context.lineTo(r, -r);
      context.lineTo(3 * r, -r);
      context.lineTo(3 * r, r);
      context.lineTo(r, r);
      context.lineTo(r, 3 * r);
      context.lineTo(-r, 3 * r);
      context.lineTo(-r, r);
      context.lineTo(-3 * r, r);
      context.closePath();
    }
  };

  var tan30 = Math.sqrt(1 / 3);
  var tan30_2 = tan30 * 2;

  var diamond = {
    draw: function (context, size) {
      var y = Math.sqrt(size / tan30_2),
          x = y * tan30;
      context.moveTo(0, -y);
      context.lineTo(x, 0);
      context.lineTo(0, y);
      context.lineTo(-x, 0);
      context.closePath();
    }
  };

  var ka = 0.89081309152928522810;
  var kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10);
  var kx = Math.sin(tau$4 / 10) * kr;
  var ky = -Math.cos(tau$4 / 10) * kr;

  var star = {
    draw: function (context, size) {
      var r = Math.sqrt(size * ka),
          x = kx * r,
          y = ky * r;
      context.moveTo(0, -r);
      context.lineTo(x, y);
      for (var i = 1; i < 5; ++i) {
        var a = tau$4 * i / 5,
            c = Math.cos(a),
            s = Math.sin(a);
        context.lineTo(s * r, -c * r);
        context.lineTo(c * x - s * y, s * x + c * y);
      }
      context.closePath();
    }
  };

  var square = {
    draw: function (context, size) {
      var w = Math.sqrt(size),
          x = -w / 2;
      context.rect(x, x, w, w);
    }
  };

  var sqrt3 = Math.sqrt(3);

  var triangle = {
    draw: function (context, size) {
      var y = -Math.sqrt(size / (sqrt3 * 3));
      context.moveTo(0, y * 2);
      context.lineTo(-sqrt3 * y, -y);
      context.lineTo(sqrt3 * y, -y);
      context.closePath();
    }
  };

  var c = -0.5;
  var s = Math.sqrt(3) / 2;
  var k = 1 / Math.sqrt(12);
  var a = (k / 2 + 1) * 3;

  var wye = {
    draw: function (context, size) {
      var r = Math.sqrt(size / a),
          x0 = r / 2,
          y0 = r * k,
          x1 = x0,
          y1 = r * k + r,
          x2 = -x1,
          y2 = y1;
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
      context.lineTo(x2, y2);
      context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
      context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
      context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
      context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
      context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
      context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
      context.closePath();
    }
  };

  var symbols = [circle$2, cross$2, diamond, square, star, triangle, wye];

  var symbol = function () {
    var type = constant$10(circle$2),
        size = constant$10(64),
        context = null;

    function symbol() {
      var buffer;
      if (!context) context = buffer = path();
      type.apply(this, arguments).draw(context, +size.apply(this, arguments));
      if (buffer) return context = null, buffer + "" || null;
    }

    symbol.type = function (_) {
      return arguments.length ? (type = typeof _ === "function" ? _ : constant$10(_), symbol) : type;
    };

    symbol.size = function (_) {
      return arguments.length ? (size = typeof _ === "function" ? _ : constant$10(+_), symbol) : size;
    };

    symbol.context = function (_) {
      return arguments.length ? (context = _ == null ? null : _, symbol) : context;
    };

    return symbol;
  };

  var noop$2 = function () {};

  function point$2(that, x, y) {
    that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
  }

  function Basis(context) {
    this._context = context;
  }

  Basis.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 3:
          point$2(this, this._x1, this._y1); // proceed
        case 2:
          this._context.lineTo(this._x1, this._y1);break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
        case 1:
          this._point = 2;break;
        case 2:
          this._point = 3;this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
        default:
          point$2(this, x, y);break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  var basis$2 = function (context) {
    return new Basis(context);
  };

  function BasisClosed(context) {
    this._context = context;
  }

  BasisClosed.prototype = {
    areaStart: noop$2,
    areaEnd: noop$2,
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 1:
          {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
        case 2:
          {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
        case 3:
          {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
      }
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;this._x2 = x, this._y2 = y;break;
        case 1:
          this._point = 2;this._x3 = x, this._y3 = y;break;
        case 2:
          this._point = 3;this._x4 = x, this._y4 = y;this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);break;
        default:
          point$2(this, x, y);break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  var basisClosed$1 = function (context) {
    return new BasisClosed(context);
  };

  function BasisOpen(context) {
    this._context = context;
  }

  BasisOpen.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;break;
        case 1:
          this._point = 2;break;
        case 2:
          this._point = 3;var x0 = (this._x0 + 4 * this._x1 + x) / 6,
              y0 = (this._y0 + 4 * this._y1 + y) / 6;this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);break;
        case 3:
          this._point = 4; // proceed
        default:
          point$2(this, x, y);break;
      }
      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
    }
  };

  var basisOpen = function (context) {
    return new BasisOpen(context);
  };

  function Bundle(context, beta) {
    this._basis = new Basis(context);
    this._beta = beta;
  }

  Bundle.prototype = {
    lineStart: function () {
      this._x = [];
      this._y = [];
      this._basis.lineStart();
    },
    lineEnd: function () {
      var x = this._x,
          y = this._y,
          j = x.length - 1;

      if (j > 0) {
        var x0 = x[0],
            y0 = y[0],
            dx = x[j] - x0,
            dy = y[j] - y0,
            i = -1,
            t;

        while (++i <= j) {
          t = i / j;
          this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
        }
      }

      this._x = this._y = null;
      this._basis.lineEnd();
    },
    point: function (x, y) {
      this._x.push(+x);
      this._y.push(+y);
    }
  };

  var bundle = function custom(beta) {

    function bundle(context) {
      return beta === 1 ? new Basis(context) : new Bundle(context, beta);
    }

    bundle.beta = function (beta) {
      return custom(+beta);
    };

    return bundle;
  }(0.85);

  function point$3(that, x, y) {
    that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
  }

  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }

  Cardinal.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);break;
        case 3:
          point$3(this, this._x1, this._y1);break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
        case 1:
          this._point = 2;this._x1 = x, this._y1 = y;break;
        case 2:
          this._point = 3; // proceed
        default:
          point$3(this, x, y);break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var cardinal = function custom(tension) {

    function cardinal(context) {
      return new Cardinal(context, tension);
    }

    cardinal.tension = function (tension) {
      return custom(+tension);
    };

    return cardinal;
  }(0);

  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }

  CardinalClosed.prototype = {
    areaStart: noop$2,
    areaEnd: noop$2,
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 1:
          {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
        case 2:
          {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
        case 3:
          {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
      }
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;this._x3 = x, this._y3 = y;break;
        case 1:
          this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
        case 2:
          this._point = 3;this._x5 = x, this._y5 = y;break;
        default:
          point$3(this, x, y);break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var cardinalClosed = function custom(tension) {

    function cardinal(context) {
      return new CardinalClosed(context, tension);
    }

    cardinal.tension = function (tension) {
      return custom(+tension);
    };

    return cardinal;
  }(0);

  function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }

  CardinalOpen.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;break;
        case 1:
          this._point = 2;break;
        case 2:
          this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
        case 3:
          this._point = 4; // proceed
        default:
          point$3(this, x, y);break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var cardinalOpen = function custom(tension) {

    function cardinal(context) {
      return new CardinalOpen(context, tension);
    }

    cardinal.tension = function (tension) {
      return custom(+tension);
    };

    return cardinal;
  }(0);

  function point$4(that, x, y) {
    var x1 = that._x1,
        y1 = that._y1,
        x2 = that._x2,
        y2 = that._y2;

    if (that._l01_a > epsilon$3) {
      var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
          n = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
      y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }

    if (that._l23_a > epsilon$3) {
      var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
          m = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
      y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
    }

    that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
  }

  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }

  CatmullRom.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);break;
        case 3:
          this.point(this._x2, this._y2);break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;

      if (this._point) {
        var x23 = this._x2 - x,
            y23 = this._y2 - y;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }

      switch (this._point) {
        case 0:
          this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
        case 1:
          this._point = 2;break;
        case 2:
          this._point = 3; // proceed
        default:
          point$4(this, x, y);break;
      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var catmullRom = function custom(alpha) {

    function catmullRom(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }

    catmullRom.alpha = function (alpha) {
      return custom(+alpha);
    };

    return catmullRom;
  }(0.5);

  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }

  CatmullRomClosed.prototype = {
    areaStart: noop$2,
    areaEnd: noop$2,
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 1:
          {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
        case 2:
          {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
        case 3:
          {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
      }
    },
    point: function (x, y) {
      x = +x, y = +y;

      if (this._point) {
        var x23 = this._x2 - x,
            y23 = this._y2 - y;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }

      switch (this._point) {
        case 0:
          this._point = 1;this._x3 = x, this._y3 = y;break;
        case 1:
          this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
        case 2:
          this._point = 3;this._x5 = x, this._y5 = y;break;
        default:
          point$4(this, x, y);break;
      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var catmullRomClosed = function custom(alpha) {

    function catmullRom(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }

    catmullRom.alpha = function (alpha) {
      return custom(+alpha);
    };

    return catmullRom;
  }(0.5);

  function CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }

  CatmullRomOpen.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function () {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;

      if (this._point) {
        var x23 = this._x2 - x,
            y23 = this._y2 - y;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }

      switch (this._point) {
        case 0:
          this._point = 1;break;
        case 1:
          this._point = 2;break;
        case 2:
          this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
        case 3:
          this._point = 4; // proceed
        default:
          point$4(this, x, y);break;
      }

      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
  };

  var catmullRomOpen = function custom(alpha) {

    function catmullRom(context) {
      return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
    }

    catmullRom.alpha = function (alpha) {
      return custom(+alpha);
    };

    return catmullRom;
  }(0.5);

  function LinearClosed(context) {
    this._context = context;
  }

  LinearClosed.prototype = {
    areaStart: noop$2,
    areaEnd: noop$2,
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      if (this._point) this._context.closePath();
    },
    point: function (x, y) {
      x = +x, y = +y;
      if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
    }
  };

  var linearClosed = function (context) {
    return new LinearClosed(context);
  };

  function sign$1(x) {
    return x < 0 ? -1 : 1;
  }

  // Calculate the slopes of the tangents (Hermite-type interpolation) based on
  // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
  // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
  // NOV(II), P. 443, 1990.
  function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0,
        h1 = x2 - that._x1,
        s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
        s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
        p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }

  // Calculate a one-sided slope.
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }

  // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
  // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
  function point$5(that, t0, t1) {
    var x0 = that._x0,
        y0 = that._y0,
        x1 = that._x1,
        y1 = that._y1,
        dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
  }

  function MonotoneX(context) {
    this._context = context;
  }

  MonotoneX.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);break;
        case 3:
          point$5(this, this._t0, slope2(this, this._t0));break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function (x, y) {
      var t1 = NaN;

      x = +x, y = +y;
      if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
      switch (this._point) {
        case 0:
          this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
        case 1:
          this._point = 2;break;
        case 2:
          this._point = 3;point$5(this, slope2(this, t1 = slope3(this, x, y)), t1);break;
        default:
          point$5(this, this._t0, t1 = slope3(this, x, y));break;
      }

      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
      this._t0 = t1;
    }
  };

  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }

  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
    MonotoneX.prototype.point.call(this, y, x);
  };

  function ReflectContext(context) {
    this._context = context;
  }

  ReflectContext.prototype = {
    moveTo: function (x, y) {
      this._context.moveTo(y, x);
    },
    closePath: function () {
      this._context.closePath();
    },
    lineTo: function (x, y) {
      this._context.lineTo(y, x);
    },
    bezierCurveTo: function (x1, y1, x2, y2, x, y) {
      this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
    }
  };

  function monotoneX(context) {
    return new MonotoneX(context);
  }

  function monotoneY(context) {
    return new MonotoneY(context);
  }

  function Natural(context) {
    this._context = context;
  }

  Natural.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x = [];
      this._y = [];
    },
    lineEnd: function () {
      var x = this._x,
          y = this._y,
          n = x.length;

      if (n) {
        this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
        if (n === 2) {
          this._context.lineTo(x[1], y[1]);
        } else {
          var px = controlPoints(x),
              py = controlPoints(y);
          for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
          }
        }
      }

      if (this._line || this._line !== 0 && n === 1) this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point: function (x, y) {
      this._x.push(+x);
      this._y.push(+y);
    }
  };

  // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
  function controlPoints(x) {
    var i,
        n = x.length - 1,
        m,
        a = new Array(n),
        b = new Array(n),
        r = new Array(n);
    a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
    for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
    a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
    for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
    a[n - 1] = r[n - 1] / b[n - 1];
    for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
    b[n - 1] = (x[n] + a[n - 1]) / 2;
    for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
    return [a, b];
  }

  var natural = function (context) {
    return new Natural(context);
  };

  function Step(context, t) {
    this._context = context;
    this._t = t;
  }

  Step.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function () {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function (x, y) {
      x = +x, y = +y;
      switch (this._point) {
        case 0:
          this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
        case 1:
          this._point = 2; // proceed
        default:
          {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
      }
      this._x = x, this._y = y;
    }
  };

  var step = function (context) {
    return new Step(context, 0.5);
  };

  function stepBefore(context) {
    return new Step(context, 0);
  }

  function stepAfter(context) {
    return new Step(context, 1);
  }

  var none$1 = function (series, order) {
    if (!((n = series.length) > 1)) return;
    for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j = 0; j < m; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  };

  var none$2 = function (series) {
    var n = series.length,
        o = new Array(n);
    while (--n >= 0) o[n] = n;
    return o;
  };

  function stackValue(d, key) {
    return d[key];
  }

  var stack = function () {
    var keys = constant$10([]),
        order = none$2,
        offset = none$1,
        value = stackValue;

    function stack(data) {
      var kz = keys.apply(this, arguments),
          i,
          m = data.length,
          n = kz.length,
          sz = new Array(n),
          oz;

      for (i = 0; i < n; ++i) {
        for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
          si[j] = sij = [0, +value(data[j], ki, j, data)];
          sij.data = data[j];
        }
        si.key = ki;
      }

      for (i = 0, oz = order(sz); i < n; ++i) {
        sz[oz[i]].index = i;
      }

      offset(sz, oz);
      return sz;
    }

    stack.keys = function (_) {
      return arguments.length ? (keys = typeof _ === "function" ? _ : constant$10(slice$5.call(_)), stack) : keys;
    };

    stack.value = function (_) {
      return arguments.length ? (value = typeof _ === "function" ? _ : constant$10(+_), stack) : value;
    };

    stack.order = function (_) {
      return arguments.length ? (order = _ == null ? none$2 : typeof _ === "function" ? _ : constant$10(slice$5.call(_)), stack) : order;
    };

    stack.offset = function (_) {
      return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
    };

    return stack;
  };

  var expand = function (series, order) {
    if (!((n = series.length) > 0)) return;
    for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
      for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
      if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
    }
    none$1(series, order);
  };

  var diverging = function (series, order) {
    if (!((n = series.length) > 1)) return;
    for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
      for (yp = yn = 0, i = 0; i < n; ++i) {
        if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
          d[0] = yp, d[1] = yp += dy;
        } else if (dy < 0) {
          d[1] = yn, d[0] = yn += dy;
        } else {
          d[0] = yp;
        }
      }
    }
  };

  var silhouette = function (series, order) {
    if (!((n = series.length) > 0)) return;
    for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
      for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
      s0[j][1] += s0[j][0] = -y / 2;
    }
    none$1(series, order);
  };

  var wiggle = function (series, order) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
    for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        var si = series[order[i]],
            sij0 = si[j][1] || 0,
            sij1 = si[j - 1][1] || 0,
            s3 = (sij0 - sij1) / 2;
        for (var k = 0; k < i; ++k) {
          var sk = series[order[k]],
              skj0 = sk[j][1] || 0,
              skj1 = sk[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      if (s1) y -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    none$1(series, order);
  };

  var ascending$2 = function (series) {
    var sums = series.map(sum$2);
    return none$2(series).sort(function (a, b) {
      return sums[a] - sums[b];
    });
  };

  function sum$2(series) {
    var s = 0,
        i = -1,
        n = series.length,
        v;
    while (++i < n) if (v = +series[i][1]) s += v;
    return s;
  }

  var descending$2 = function (series) {
    return ascending$2(series).reverse();
  };

  var insideOut = function (series) {
    var n = series.length,
        i,
        j,
        sums = series.map(sum$2),
        order = none$2(series).sort(function (a, b) {
      return sums[b] - sums[a];
    }),
        top = 0,
        bottom = 0,
        tops = [],
        bottoms = [];

    for (i = 0; i < n; ++i) {
      j = order[i];
      if (top < bottom) {
        top += sums[j];
        tops.push(j);
      } else {
        bottom += sums[j];
        bottoms.push(j);
      }
    }

    return bottoms.reverse().concat(tops);
  };

  var reverse = function (series) {
    return none$2(series).reverse();
  };

  var constant$11 = function (x) {
    return function () {
      return x;
    };
  };

  function x$4(d) {
    return d[0];
  }

  function y$4(d) {
    return d[1];
  }

  function RedBlackTree() {
    this._ = null; // root node
  }

  function RedBlackNode(node) {
    node.U = // parent node
    node.C = // color - true for red, false for black
    node.L = // left node
    node.R = // right node
    node.P = // previous node
    node.N = null; // next node
  }

  RedBlackTree.prototype = {
    constructor: RedBlackTree,

    insert: function (after, node) {
      var parent, grandpa, uncle;

      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = RedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;

      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              RedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              RedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },

    remove: function (node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;

      var parent = node.U,
          sibling,
          left = node.L,
          right = node.R,
          next,
          red;

      if (!left) next = right;else if (!right) next = left;else next = RedBlackFirst(right);

      if (parent) {
        if (parent.L === node) parent.L = next;else parent.R = next;
      } else {
        this._ = next;
      }

      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }

      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;return;
      }

      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              RedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            RedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              RedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            RedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);

      if (node) node.C = false;
    }
  };

  function RedBlackRotateLeft(tree, node) {
    var p = node,
        q = node.R,
        parent = p.U;

    if (parent) {
      if (parent.L === p) parent.L = q;else parent.R = q;
    } else {
      tree._ = q;
    }

    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }

  function RedBlackRotateRight(tree, node) {
    var p = node,
        q = node.L,
        parent = p.U;

    if (parent) {
      if (parent.L === p) parent.L = q;else parent.R = q;
    } else {
      tree._ = q;
    }

    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }

  function RedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }

  function createEdge(left, right, v0, v1) {
    var edge = [null, null],
        index = edges.push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0) setEdgeEnd(edge, left, right, v0);
    if (v1) setEdgeEnd(edge, right, left, v1);
    cells[left.index].halfedges.push(index);
    cells[right.index].halfedges.push(index);
    return edge;
  }

  function createBorderEdge(left, v0, v1) {
    var edge = [v0, v1];
    edge.left = left;
    return edge;
  }

  function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
      edge[0] = vertex;
      edge.left = left;
      edge.right = right;
    } else if (edge.left === right) {
      edge[1] = vertex;
    } else {
      edge[0] = vertex;
    }
  }

  // Liang–Barsky line clipping.
  function clipEdge(edge, x0, y0, x1, y1) {
    var a = edge[0],
        b = edge[1],
        ax = a[0],
        ay = a[1],
        bx = b[0],
        by = b[1],
        t0 = 0,
        t1 = 1,
        dx = bx - ax,
        dy = by - ay,
        r;

    r = x0 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dx > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = x1 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dx > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    r = y0 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dy > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }

    r = y1 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dy > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }

    if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

    if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
    if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
    return true;
  }

  function connectEdge(edge, x0, y0, x1, y1) {
    var v1 = edge[1];
    if (v1) return true;

    var v0 = edge[0],
        left = edge.left,
        right = edge.right,
        lx = left[0],
        ly = left[1],
        rx = right[0],
        ry = right[1],
        fx = (lx + rx) / 2,
        fy = (ly + ry) / 2,
        fm,
        fb;

    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!v0) v0 = [fx, y0];else if (v0[1] >= y1) return;
        v1 = [fx, y1];
      } else {
        if (!v0) v0 = [fx, y1];else if (v0[1] < y0) return;
        v1 = [fx, y0];
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!v0) v0 = [(y0 - fb) / fm, y0];else if (v0[1] >= y1) return;
          v1 = [(y1 - fb) / fm, y1];
        } else {
          if (!v0) v0 = [(y1 - fb) / fm, y1];else if (v0[1] < y0) return;
          v1 = [(y0 - fb) / fm, y0];
        }
      } else {
        if (ly < ry) {
          if (!v0) v0 = [x0, fm * x0 + fb];else if (v0[0] >= x1) return;
          v1 = [x1, fm * x1 + fb];
        } else {
          if (!v0) v0 = [x1, fm * x1 + fb];else if (v0[0] < x0) return;
          v1 = [x0, fm * x0 + fb];
        }
      }
    }

    edge[0] = v0;
    edge[1] = v1;
    return true;
  }

  function clipEdges(x0, y0, x1, y1) {
    var i = edges.length,
        edge;

    while (i--) {
      if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$4 || Math.abs(edge[0][1] - edge[1][1]) > epsilon$4)) {
        delete edges[i];
      }
    }
  }

  function createCell(site) {
    return cells[site.index] = {
      site: site,
      halfedges: []
    };
  }

  function cellHalfedgeAngle(cell, edge) {
    var site = cell.site,
        va = edge.left,
        vb = edge.right;
    if (site === vb) vb = va, va = site;
    if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
  }

  function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
  }

  function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
  }

  function sortCellHalfedges() {
    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
      if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
        var index = new Array(m),
            array = new Array(m);
        for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
        index.sort(function (i, j) {
          return array[j] - array[i];
        });
        for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
        for (j = 0; j < m; ++j) halfedges[j] = array[j];
      }
    }
  }

  function clipCells(x0, y0, x1, y1) {
    var nCells = cells.length,
        iCell,
        cell,
        site,
        iHalfedge,
        halfedges,
        nHalfedges,
        start,
        startX,
        startY,
        end,
        endX,
        endY,
        cover = true;

    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        halfedges = cell.halfedges;
        iHalfedge = halfedges.length;

        // Remove any dangling clipped edges.
        while (iHalfedge--) {
          if (!edges[halfedges[iHalfedge]]) {
            halfedges.splice(iHalfedge, 1);
          }
        }

        // Insert any border edges as necessary.
        iHalfedge = 0, nHalfedges = halfedges.length;
        while (iHalfedge < nHalfedges) {
          end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
          start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
          if (Math.abs(endX - startX) > epsilon$4 || Math.abs(endY - startY) > epsilon$4) {
            halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon$4 && y1 - endY > epsilon$4 ? [x0, Math.abs(startX - x0) < epsilon$4 ? startY : y1] : Math.abs(endY - y1) < epsilon$4 && x1 - endX > epsilon$4 ? [Math.abs(startY - y1) < epsilon$4 ? startX : x1, y1] : Math.abs(endX - x1) < epsilon$4 && endY - y0 > epsilon$4 ? [x1, Math.abs(startX - x1) < epsilon$4 ? startY : y0] : Math.abs(endY - y0) < epsilon$4 && endX - x0 > epsilon$4 ? [Math.abs(startY - y0) < epsilon$4 ? startX : x0, y0] : null)) - 1);
            ++nHalfedges;
          }
        }

        if (nHalfedges) cover = false;
      }
    }

    // If there weren’t any edges, have the closest site cover the extent.
    // It doesn’t matter which corner of the extent we measure!
    if (cover) {
      var dx,
          dy,
          d2,
          dc = Infinity;

      for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          dx = site[0] - x0;
          dy = site[1] - y0;
          d2 = dx * dx + dy * dy;
          if (d2 < dc) dc = d2, cover = cell;
        }
      }

      if (cover) {
        var v00 = [x0, y0],
            v01 = [x0, y1],
            v11 = [x1, y1],
            v10 = [x1, y0];
        cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
      }
    }

    // Lastly delete any cells with no edges; these were entirely clipped.
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        if (!cell.halfedges.length) {
          delete cells[iCell];
        }
      }
    }
  }

  var circlePool = [];

  var firstCircle;

  function Circle() {
    RedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }

  function attachCircle(arc) {
    var lArc = arc.P,
        rArc = arc.N;

    if (!lArc || !rArc) return;

    var lSite = lArc.site,
        cSite = arc.site,
        rSite = rArc.site;

    if (lSite === rSite) return;

    var bx = cSite[0],
        by = cSite[1],
        ax = lSite[0] - bx,
        ay = lSite[1] - by,
        cx = rSite[0] - bx,
        cy = rSite[1] - by;

    var d = 2 * (ax * cy - ay * cx);
    if (d >= -epsilon2$2) return;

    var ha = ax * ax + ay * ay,
        hc = cx * cx + cy * cy,
        x = (cy * ha - ay * hc) / d,
        y = (ax * hc - cx * ha) / d;

    var circle = circlePool.pop() || new Circle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

    arc.circle = circle;

    var before = null,
        node = circles._;

    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L;else {
          before = node.P;break;
        }
      } else {
        if (node.R) node = node.R;else {
          before = node;break;
        }
      }
    }

    circles.insert(before, circle);
    if (!before) firstCircle = circle;
  }

  function detachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) firstCircle = circle.N;
      circles.remove(circle);
      circlePool.push(circle);
      RedBlackNode(circle);
      arc.circle = null;
    }
  }

  var beachPool = [];

  function Beach() {
    RedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }

  function createBeach(site) {
    var beach = beachPool.pop() || new Beach();
    beach.site = site;
    return beach;
  }

  function detachBeach(beach) {
    detachCircle(beach);
    beaches.remove(beach);
    beachPool.push(beach);
    RedBlackNode(beach);
  }

  function removeBeach(beach) {
    var circle = beach.circle,
        x = circle.x,
        y = circle.cy,
        vertex = [x, y],
        previous = beach.P,
        next = beach.N,
        disappearing = [beach];

    detachBeach(beach);

    var lArc = previous;
    while (lArc.circle && Math.abs(x - lArc.circle.x) < epsilon$4 && Math.abs(y - lArc.circle.cy) < epsilon$4) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      detachBeach(lArc);
      lArc = previous;
    }

    disappearing.unshift(lArc);
    detachCircle(lArc);

    var rArc = next;
    while (rArc.circle && Math.abs(x - rArc.circle.x) < epsilon$4 && Math.abs(y - rArc.circle.cy) < epsilon$4) {
      next = rArc.N;
      disappearing.push(rArc);
      detachBeach(rArc);
      rArc = next;
    }

    disappearing.push(rArc);
    detachCircle(rArc);

    var nArcs = disappearing.length,
        iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }

    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

    attachCircle(lArc);
    attachCircle(rArc);
  }

  function addBeach(site) {
    var x = site[0],
        directrix = site[1],
        lArc,
        rArc,
        dxl,
        dxr,
        node = beaches._;

    while (node) {
      dxl = leftBreakPoint(node, directrix) - x;
      if (dxl > epsilon$4) node = node.L;else {
        dxr = x - rightBreakPoint(node, directrix);
        if (dxr > epsilon$4) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -epsilon$4) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -epsilon$4) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }

    createCell(site);
    var newArc = createBeach(site);
    beaches.insert(lArc, newArc);

    if (!lArc && !rArc) return;

    if (lArc === rArc) {
      detachCircle(lArc);
      rArc = createBeach(lArc.site);
      beaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
      attachCircle(lArc);
      attachCircle(rArc);
      return;
    }

    if (!rArc) {
      // && lArc
      newArc.edge = createEdge(lArc.site, newArc.site);
      return;
    }

    // else lArc !== rArc
    detachCircle(lArc);
    detachCircle(rArc);

    var lSite = lArc.site,
        ax = lSite[0],
        ay = lSite[1],
        bx = site[0] - ax,
        by = site[1] - ay,
        rSite = rArc.site,
        cx = rSite[0] - ax,
        cy = rSite[1] - ay,
        d = 2 * (bx * cy - by * cx),
        hb = bx * bx + by * by,
        hc = cx * cx + cy * cy,
        vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

    setEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = createEdge(lSite, site, null, vertex);
    rArc.edge = createEdge(site, rSite, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }

  function leftBreakPoint(arc, directrix) {
    var site = arc.site,
        rfocx = site[0],
        rfocy = site[1],
        pby2 = rfocy - directrix;

    if (!pby2) return rfocx;

    var lArc = arc.P;
    if (!lArc) return -Infinity;

    site = lArc.site;
    var lfocx = site[0],
        lfocy = site[1],
        plby2 = lfocy - directrix;

    if (!plby2) return lfocx;

    var hl = lfocx - rfocx,
        aby2 = 1 / pby2 - 1 / plby2,
        b = hl / plby2;

    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

    return (rfocx + lfocx) / 2;
  }

  function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
  }

  var epsilon$4 = 1e-6;
  var epsilon2$2 = 1e-12;
  var beaches;
  var cells;
  var circles;
  var edges;

  function triangleArea(a, b, c) {
    return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
  }

  function lexicographic(a, b) {
    return b[1] - a[1] || b[0] - a[0];
  }

  function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(),
        x,
        y,
        circle;

    edges = [];
    cells = new Array(sites.length);
    beaches = new RedBlackTree();
    circles = new RedBlackTree();

    while (true) {
      circle = firstCircle;
      if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
        if (site[0] !== x || site[1] !== y) {
          addBeach(site);
          x = site[0], y = site[1];
        }
        site = sites.pop();
      } else if (circle) {
        removeBeach(circle.arc);
      } else {
        break;
      }
    }

    sortCellHalfedges();

    if (extent) {
      var x0 = +extent[0][0],
          y0 = +extent[0][1],
          x1 = +extent[1][0],
          y1 = +extent[1][1];
      clipEdges(x0, y0, x1, y1);
      clipCells(x0, y0, x1, y1);
    }

    this.edges = edges;
    this.cells = cells;

    beaches = circles = edges = cells = null;
  }

  Diagram.prototype = {
    constructor: Diagram,

    polygons: function () {
      var edges = this.edges;

      return this.cells.map(function (cell) {
        var polygon = cell.halfedges.map(function (i) {
          return cellHalfedgeStart(cell, edges[i]);
        });
        polygon.data = cell.site.data;
        return polygon;
      });
    },

    triangles: function () {
      var triangles = [],
          edges = this.edges;

      this.cells.forEach(function (cell, i) {
        if (!(m = (halfedges = cell.halfedges).length)) return;
        var site = cell.site,
            halfedges,
            j = -1,
            m,
            s0,
            e1 = edges[halfedges[m - 1]],
            s1 = e1.left === site ? e1.right : e1.left;

        while (++j < m) {
          s0 = s1;
          e1 = edges[halfedges[j]];
          s1 = e1.left === site ? e1.right : e1.left;
          if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
            triangles.push([site.data, s0.data, s1.data]);
          }
        }
      });

      return triangles;
    },

    links: function () {
      return this.edges.filter(function (edge) {
        return edge.right;
      }).map(function (edge) {
        return {
          source: edge.left.data,
          target: edge.right.data
        };
      });
    },

    find: function (x, y, radius) {
      var that = this,
          i0,
          i1 = that._found || 0,
          n = that.cells.length,
          cell;

      // Use the previously-found cell, or start with an arbitrary one.
      while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
      var dx = x - cell.site[0],
          dy = y - cell.site[1],
          d2 = dx * dx + dy * dy;

      // Traverse the half-edges to find a closer cell, if any.
      do {
        cell = that.cells[i0 = i1], i1 = null;
        cell.halfedges.forEach(function (e) {
          var edge = that.edges[e],
              v = edge.left;
          if ((v === cell.site || !v) && !(v = edge.right)) return;
          var vx = x - v[0],
              vy = y - v[1],
              v2 = vx * vx + vy * vy;
          if (v2 < d2) d2 = v2, i1 = v.index;
        });
      } while (i1 !== null);

      that._found = i0;

      return radius == null || d2 <= radius * radius ? cell.site : null;
    }
  };

  var voronoi = function () {
    var x$$1 = x$4,
        y$$1 = y$4,
        extent = null;

    function voronoi(data) {
      return new Diagram(data.map(function (d, i) {
        var s = [Math.round(x$$1(d, i, data) / epsilon$4) * epsilon$4, Math.round(y$$1(d, i, data) / epsilon$4) * epsilon$4];
        s.index = i;
        s.data = d;
        return s;
      }), extent);
    }

    voronoi.polygons = function (data) {
      return voronoi(data).polygons();
    };

    voronoi.links = function (data) {
      return voronoi(data).links();
    };

    voronoi.triangles = function (data) {
      return voronoi(data).triangles();
    };

    voronoi.x = function (_) {
      return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$11(+_), voronoi) : x$$1;
    };

    voronoi.y = function (_) {
      return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$11(+_), voronoi) : y$$1;
    };

    voronoi.extent = function (_) {
      return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
    };

    voronoi.size = function (_) {
      return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
    };

    return voronoi;
  };

  var constant$12 = function (x) {
    return function () {
      return x;
    };
  };

  function ZoomEvent(target, type, transform) {
    this.target = target;
    this.type = type;
    this.transform = transform;
  }

  function Transform(k, x, y) {
    this.k = k;
    this.x = x;
    this.y = y;
  }

  Transform.prototype = {
    constructor: Transform,
    scale: function (k) {
      return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
    },
    translate: function (x, y) {
      return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
    },
    apply: function (point) {
      return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function (x) {
      return x * this.k + this.x;
    },
    applyY: function (y) {
      return y * this.k + this.y;
    },
    invert: function (location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function (x) {
      return (x - this.x) / this.k;
    },
    invertY: function (y) {
      return (y - this.y) / this.k;
    },
    rescaleX: function (x) {
      return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
    },
    rescaleY: function (y) {
      return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
    },
    toString: function () {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };

  var identity$8 = new Transform(1, 0, 0);

  transform$1.prototype = Transform.prototype;

  function transform$1(node) {
    return node.__zoom || identity$8;
  }

  function nopropagation$2() {
    exports.event.stopImmediatePropagation();
  }

  var noevent$2 = function () {
    exports.event.preventDefault();
    exports.event.stopImmediatePropagation();
  };

  // Ignore right-click, since that should open the context menu.
  function defaultFilter$2() {
    return !exports.event.button;
  }

  function defaultExtent$1() {
    var e = this,
        w,
        h;
    if (e instanceof SVGElement) {
      e = e.ownerSVGElement || e;
      w = e.width.baseVal.value;
      h = e.height.baseVal.value;
    } else {
      w = e.clientWidth;
      h = e.clientHeight;
    }
    return [[0, 0], [w, h]];
  }

  function defaultTransform() {
    return this.__zoom || identity$8;
  }

  var zoom = function () {
    var filter = defaultFilter$2,
        extent = defaultExtent$1,
        k0 = 0,
        k1 = Infinity,
        x0 = -k1,
        x1 = k1,
        y0 = x0,
        y1 = x1,
        duration = 250,
        interpolate$$1 = interpolateZoom,
        gestures = [],
        listeners = dispatch("start", "zoom", "end"),
        touchstarting,
        touchending,
        touchDelay = 500,
        wheelDelay = 150,
        clickDistance2 = 0;

    function zoom(selection$$1) {
      selection$$1.on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").property("__zoom", defaultTransform);
    }

    zoom.transform = function (collection, transform) {
      var selection$$1 = collection.selection ? collection.selection() : collection;
      selection$$1.property("__zoom", defaultTransform);
      if (collection !== selection$$1) {
        schedule(collection, transform);
      } else {
        selection$$1.interrupt().each(function () {
          gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
        });
      }
    };

    zoom.scaleBy = function (selection$$1, k) {
      zoom.scaleTo(selection$$1, function () {
        var k0 = this.__zoom.k,
            k1 = typeof k === "function" ? k.apply(this, arguments) : k;
        return k0 * k1;
      });
    };

    zoom.scaleTo = function (selection$$1, k) {
      zoom.transform(selection$$1, function () {
        var e = extent.apply(this, arguments),
            t0 = this.__zoom,
            p0 = centroid(e),
            p1 = t0.invert(p0),
            k1 = typeof k === "function" ? k.apply(this, arguments) : k;
        return constrain(translate(scale(t0, k1), p0, p1), e);
      });
    };

    zoom.translateBy = function (selection$$1, x, y) {
      zoom.transform(selection$$1, function () {
        return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments));
      });
    };

    function scale(transform, k) {
      k = Math.max(k0, Math.min(k1, k));
      return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
    }

    function translate(transform, p0, p1) {
      var x = p0[0] - p1[0] * transform.k,
          y = p0[1] - p1[1] * transform.k;
      return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
    }

    function constrain(transform, extent) {
      var dx0 = transform.invertX(extent[0][0]) - x0,
          dx1 = transform.invertX(extent[1][0]) - x1,
          dy0 = transform.invertY(extent[0][1]) - y0,
          dy1 = transform.invertY(extent[1][1]) - y1;
      return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
    }

    function centroid(extent) {
      return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
    }

    function schedule(transition$$1, transform, center) {
      transition$$1.on("start.zoom", function () {
        gesture(this, arguments).start();
      }).on("interrupt.zoom end.zoom", function () {
        gesture(this, arguments).end();
      }).tween("zoom", function () {
        var that = this,
            args = arguments,
            g = gesture(that, args),
            e = extent.apply(that, args),
            p = center || centroid(e),
            w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
            a = that.__zoom,
            b = typeof transform === "function" ? transform.apply(that, args) : transform,
            i = interpolate$$1(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
        return function (t) {
          if (t === 1) t = b; // Avoid rounding error on end.
          else {
              var l = i(t),
                  k = w / l[2];t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
            }
          g.zoom(null, t);
        };
      });
    }

    function gesture(that, args) {
      for (var i = 0, n = gestures.length, g; i < n; ++i) {
        if ((g = gestures[i]).that === that) {
          return g;
        }
      }
      return new Gesture(that, args);
    }

    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.index = -1;
      this.active = 0;
      this.extent = extent.apply(that, args);
    }

    Gesture.prototype = {
      start: function () {
        if (++this.active === 1) {
          this.index = gestures.push(this) - 1;
          this.emit("start");
        }
        return this;
      },
      zoom: function (key, transform) {
        if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
        this.that.__zoom = transform;
        this.emit("zoom");
        return this;
      },
      end: function () {
        if (--this.active === 0) {
          gestures.splice(this.index, 1);
          this.index = -1;
          this.emit("end");
        }
        return this;
      },
      emit: function (type) {
        customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
      }
    };

    function wheeled() {
      if (!filter.apply(this, arguments)) return;
      var g = gesture(this, arguments),
          t = this.__zoom,
          k = Math.max(k0, Math.min(k1, t.k * Math.pow(2, -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500))),
          p = mouse(this);

      // If the mouse is in the same location as before, reuse it.
      // If there were recent wheel events, reset the wheel idle timeout.
      if (g.wheel) {
        if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
          g.mouse[1] = t.invert(g.mouse[0] = p);
        }
        clearTimeout(g.wheel);
      }

      // If this wheel event won’t trigger a transform change, ignore it.
      else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
            g.mouse = [p, t.invert(p)];
            interrupt(this);
            g.start();
          }

      noevent$2();
      g.wheel = setTimeout(wheelidled, wheelDelay);
      g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent));

      function wheelidled() {
        g.wheel = null;
        g.end();
      }
    }

    function mousedowned() {
      if (touchending || !filter.apply(this, arguments)) return;
      var g = gesture(this, arguments),
          v = select(exports.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
          p = mouse(this),
          x0 = exports.event.clientX,
          y0 = exports.event.clientY;

      dragDisable(exports.event.view);
      nopropagation$2();
      g.mouse = [p, this.__zoom.invert(p)];
      interrupt(this);
      g.start();

      function mousemoved() {
        noevent$2();
        if (!g.moved) {
          var dx = exports.event.clientX - x0,
              dy = exports.event.clientY - y0;
          g.moved = dx * dx + dy * dy > clickDistance2;
        }
        g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent));
      }

      function mouseupped() {
        v.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(exports.event.view, g.moved);
        noevent$2();
        g.end();
      }
    }

    function dblclicked() {
      if (!filter.apply(this, arguments)) return;
      var t0 = this.__zoom,
          p0 = mouse(this),
          p1 = t0.invert(p0),
          k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),
          t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments));

      noevent$2();
      if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);else select(this).call(zoom.transform, t1);
    }

    function touchstarted() {
      if (!filter.apply(this, arguments)) return;
      var g = gesture(this, arguments),
          touches$$1 = exports.event.changedTouches,
          started,
          n = touches$$1.length,
          i,
          t,
          p;

      nopropagation$2();
      for (i = 0; i < n; ++i) {
        t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
        p = [p, this.__zoom.invert(p), t.identifier];
        if (!g.touch0) g.touch0 = p, started = true;else if (!g.touch1) g.touch1 = p;
      }

      // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (touchstarting) {
        touchstarting = clearTimeout(touchstarting);
        if (!g.touch1) {
          g.end();
          p = select(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
          return;
        }
      }

      if (started) {
        touchstarting = setTimeout(function () {
          touchstarting = null;
        }, touchDelay);
        interrupt(this);
        g.start();
      }
    }

    function touchmoved() {
      var g = gesture(this, arguments),
          touches$$1 = exports.event.changedTouches,
          n = touches$$1.length,
          i,
          t,
          p,
          l;

      noevent$2();
      if (touchstarting) touchstarting = clearTimeout(touchstarting);
      for (i = 0; i < n; ++i) {
        t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
        if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
      }
      t = g.that.__zoom;
      if (g.touch1) {
        var p0 = g.touch0[0],
            l0 = g.touch0[1],
            p1 = g.touch1[0],
            l1 = g.touch1[1],
            dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
            dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t = scale(t, Math.sqrt(dp / dl));
        p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
        l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;
      g.zoom("touch", constrain(translate(t, p, l), g.extent));
    }

    function touchended() {
      var g = gesture(this, arguments),
          touches$$1 = exports.event.changedTouches,
          n = touches$$1.length,
          i,
          t;

      nopropagation$2();
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function () {
        touchending = null;
      }, touchDelay);
      for (i = 0; i < n; ++i) {
        t = touches$$1[i];
        if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
      }
      if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
      if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else g.end();
    }

    zoom.filter = function (_) {
      return arguments.length ? (filter = typeof _ === "function" ? _ : constant$12(!!_), zoom) : filter;
    };

    zoom.extent = function (_) {
      return arguments.length ? (extent = typeof _ === "function" ? _ : constant$12([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
    };

    zoom.scaleExtent = function (_) {
      return arguments.length ? (k0 = +_[0], k1 = +_[1], zoom) : [k0, k1];
    };

    zoom.translateExtent = function (_) {
      return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], zoom) : [[x0, y0], [x1, y1]];
    };

    zoom.duration = function (_) {
      return arguments.length ? (duration = +_, zoom) : duration;
    };

    zoom.interpolate = function (_) {
      return arguments.length ? (interpolate$$1 = _, zoom) : interpolate$$1;
    };

    zoom.on = function () {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom : value;
    };

    zoom.clickDistance = function (_) {
      return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
    };

    return zoom;
  };

  exports.version = version;
  exports.bisect = bisectRight;
  exports.bisectRight = bisectRight;
  exports.bisectLeft = bisectLeft;
  exports.ascending = ascending;
  exports.bisector = bisector;
  exports.cross = cross;
  exports.descending = descending;
  exports.deviation = deviation;
  exports.extent = extent;
  exports.histogram = histogram;
  exports.thresholdFreedmanDiaconis = freedmanDiaconis;
  exports.thresholdScott = scott;
  exports.thresholdSturges = sturges;
  exports.max = max;
  exports.mean = mean;
  exports.median = median;
  exports.merge = merge;
  exports.min = min;
  exports.pairs = pairs;
  exports.permute = permute;
  exports.quantile = threshold;
  exports.range = sequence;
  exports.scan = scan;
  exports.shuffle = shuffle;
  exports.sum = sum;
  exports.ticks = ticks;
  exports.tickIncrement = tickIncrement;
  exports.tickStep = tickStep;
  exports.transpose = transpose;
  exports.variance = variance;
  exports.zip = zip;
  exports.axisTop = axisTop;
  exports.axisRight = axisRight;
  exports.axisBottom = axisBottom;
  exports.axisLeft = axisLeft;
  exports.brush = brush;
  exports.brushX = brushX;
  exports.brushY = brushY;
  exports.brushSelection = brushSelection;
  exports.chord = chord;
  exports.ribbon = ribbon;
  exports.nest = nest;
  exports.set = set$2;
  exports.map = map$1;
  exports.keys = keys;
  exports.values = values;
  exports.entries = entries;
  exports.color = color;
  exports.rgb = rgb;
  exports.hsl = hsl;
  exports.lab = lab;
  exports.hcl = hcl;
  exports.cubehelix = cubehelix;
  exports.dispatch = dispatch;
  exports.drag = drag;
  exports.dragDisable = dragDisable;
  exports.dragEnable = yesdrag;
  exports.dsvFormat = dsv;
  exports.csvParse = csvParse;
  exports.csvParseRows = csvParseRows;
  exports.csvFormat = csvFormat;
  exports.csvFormatRows = csvFormatRows;
  exports.tsvParse = tsvParse;
  exports.tsvParseRows = tsvParseRows;
  exports.tsvFormat = tsvFormat;
  exports.tsvFormatRows = tsvFormatRows;
  exports.easeLinear = linear$1;
  exports.easeQuad = quadInOut;
  exports.easeQuadIn = quadIn;
  exports.easeQuadOut = quadOut;
  exports.easeQuadInOut = quadInOut;
  exports.easeCubic = cubicInOut;
  exports.easeCubicIn = cubicIn;
  exports.easeCubicOut = cubicOut;
  exports.easeCubicInOut = cubicInOut;
  exports.easePoly = polyInOut;
  exports.easePolyIn = polyIn;
  exports.easePolyOut = polyOut;
  exports.easePolyInOut = polyInOut;
  exports.easeSin = sinInOut;
  exports.easeSinIn = sinIn;
  exports.easeSinOut = sinOut;
  exports.easeSinInOut = sinInOut;
  exports.easeExp = expInOut;
  exports.easeExpIn = expIn;
  exports.easeExpOut = expOut;
  exports.easeExpInOut = expInOut;
  exports.easeCircle = circleInOut;
  exports.easeCircleIn = circleIn;
  exports.easeCircleOut = circleOut;
  exports.easeCircleInOut = circleInOut;
  exports.easeBounce = bounceOut;
  exports.easeBounceIn = bounceIn;
  exports.easeBounceOut = bounceOut;
  exports.easeBounceInOut = bounceInOut;
  exports.easeBack = backInOut;
  exports.easeBackIn = backIn;
  exports.easeBackOut = backOut;
  exports.easeBackInOut = backInOut;
  exports.easeElastic = elasticOut;
  exports.easeElasticIn = elasticIn;
  exports.easeElasticOut = elasticOut;
  exports.easeElasticInOut = elasticInOut;
  exports.forceCenter = center$1;
  exports.forceCollide = collide;
  exports.forceLink = link;
  exports.forceManyBody = manyBody;
  exports.forceSimulation = simulation;
  exports.forceX = x$2;
  exports.forceY = y$2;
  exports.formatDefaultLocale = defaultLocale;
  exports.formatLocale = formatLocale;
  exports.formatSpecifier = formatSpecifier;
  exports.precisionFixed = precisionFixed;
  exports.precisionPrefix = precisionPrefix;
  exports.precisionRound = precisionRound;
  exports.geoArea = area;
  exports.geoBounds = bounds;
  exports.geoCentroid = centroid;
  exports.geoCircle = circle;
  exports.geoClipExtent = extent$1;
  exports.geoContains = contains;
  exports.geoDistance = distance;
  exports.geoGraticule = graticule;
  exports.geoGraticule10 = graticule10;
  exports.geoInterpolate = interpolate$1;
  exports.geoLength = length$1;
  exports.geoPath = index$1;
  exports.geoAlbers = albers;
  exports.geoAlbersUsa = albersUsa;
  exports.geoAzimuthalEqualArea = azimuthalEqualArea;
  exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
  exports.geoAzimuthalEquidistant = azimuthalEquidistant;
  exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
  exports.geoConicConformal = conicConformal;
  exports.geoConicConformalRaw = conicConformalRaw;
  exports.geoConicEqualArea = conicEqualArea;
  exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
  exports.geoConicEquidistant = conicEquidistant;
  exports.geoConicEquidistantRaw = conicEquidistantRaw;
  exports.geoEquirectangular = equirectangular;
  exports.geoEquirectangularRaw = equirectangularRaw;
  exports.geoGnomonic = gnomonic;
  exports.geoGnomonicRaw = gnomonicRaw;
  exports.geoIdentity = identity$5;
  exports.geoProjection = projection;
  exports.geoProjectionMutator = projectionMutator;
  exports.geoMercator = mercator;
  exports.geoMercatorRaw = mercatorRaw;
  exports.geoOrthographic = orthographic;
  exports.geoOrthographicRaw = orthographicRaw;
  exports.geoStereographic = stereographic;
  exports.geoStereographicRaw = stereographicRaw;
  exports.geoTransverseMercator = transverseMercator;
  exports.geoTransverseMercatorRaw = transverseMercatorRaw;
  exports.geoRotation = rotation;
  exports.geoStream = geoStream;
  exports.geoTransform = transform;
  exports.cluster = cluster;
  exports.hierarchy = hierarchy;
  exports.pack = index$2;
  exports.packSiblings = siblings;
  exports.packEnclose = enclose;
  exports.partition = partition;
  exports.stratify = stratify;
  exports.tree = tree;
  exports.treemap = index$3;
  exports.treemapBinary = binary;
  exports.treemapDice = treemapDice;
  exports.treemapSlice = treemapSlice;
  exports.treemapSliceDice = sliceDice;
  exports.treemapSquarify = squarify;
  exports.treemapResquarify = resquarify;
  exports.interpolate = interpolateValue;
  exports.interpolateArray = array$1;
  exports.interpolateBasis = basis$1;
  exports.interpolateBasisClosed = basisClosed;
  exports.interpolateDate = date;
  exports.interpolateNumber = reinterpolate;
  exports.interpolateObject = object;
  exports.interpolateRound = interpolateRound;
  exports.interpolateString = interpolateString;
  exports.interpolateTransformCss = interpolateTransformCss;
  exports.interpolateTransformSvg = interpolateTransformSvg;
  exports.interpolateZoom = interpolateZoom;
  exports.interpolateRgb = interpolateRgb;
  exports.interpolateRgbBasis = rgbBasis;
  exports.interpolateRgbBasisClosed = rgbBasisClosed;
  exports.interpolateHsl = hsl$2;
  exports.interpolateHslLong = hslLong;
  exports.interpolateLab = lab$1;
  exports.interpolateHcl = hcl$2;
  exports.interpolateHclLong = hclLong;
  exports.interpolateCubehelix = cubehelix$2;
  exports.interpolateCubehelixLong = cubehelixLong;
  exports.quantize = quantize;
  exports.path = path;
  exports.polygonArea = area$1;
  exports.polygonCentroid = centroid$1;
  exports.polygonHull = hull;
  exports.polygonContains = contains$1;
  exports.polygonLength = length$2;
  exports.quadtree = quadtree;
  exports.queue = queue;
  exports.randomUniform = uniform;
  exports.randomNormal = normal;
  exports.randomLogNormal = logNormal;
  exports.randomBates = bates;
  exports.randomIrwinHall = irwinHall;
  exports.randomExponential = exponential$1;
  exports.request = request;
  exports.html = html;
  exports.json = json;
  exports.text = text;
  exports.xml = xml;
  exports.csv = csv$1;
  exports.tsv = tsv$1;
  exports.scaleBand = band;
  exports.scalePoint = point$1;
  exports.scaleIdentity = identity$6;
  exports.scaleLinear = linear$2;
  exports.scaleLog = log$1;
  exports.scaleOrdinal = ordinal;
  exports.scaleImplicit = implicit;
  exports.scalePow = pow$1;
  exports.scaleSqrt = sqrt$1;
  exports.scaleQuantile = quantile$$1;
  exports.scaleQuantize = quantize$1;
  exports.scaleThreshold = threshold$1;
  exports.scaleTime = time;
  exports.scaleUtc = utcTime;
  exports.schemeCategory10 = category10;
  exports.schemeCategory20b = category20b;
  exports.schemeCategory20c = category20c;
  exports.schemeCategory20 = category20;
  exports.interpolateCubehelixDefault = cubehelix$3;
  exports.interpolateRainbow = rainbow$1;
  exports.interpolateWarm = warm;
  exports.interpolateCool = cool;
  exports.interpolateViridis = viridis;
  exports.interpolateMagma = magma;
  exports.interpolateInferno = inferno;
  exports.interpolatePlasma = plasma;
  exports.scaleSequential = sequential;
  exports.creator = creator;
  exports.local = local$1;
  exports.matcher = matcher$1;
  exports.mouse = mouse;
  exports.namespace = namespace;
  exports.namespaces = namespaces;
  exports.select = select;
  exports.selectAll = selectAll;
  exports.selection = selection;
  exports.selector = selector;
  exports.selectorAll = selectorAll;
  exports.style = styleValue;
  exports.touch = touch;
  exports.touches = touches;
  exports.window = defaultView;
  exports.customEvent = customEvent;
  exports.arc = arc;
  exports.area = area$2;
  exports.line = line;
  exports.pie = pie;
  exports.radialArea = radialArea;
  exports.radialLine = radialLine$1;
  exports.linkHorizontal = linkHorizontal;
  exports.linkVertical = linkVertical;
  exports.linkRadial = linkRadial;
  exports.symbol = symbol;
  exports.symbols = symbols;
  exports.symbolCircle = circle$2;
  exports.symbolCross = cross$2;
  exports.symbolDiamond = diamond;
  exports.symbolSquare = square;
  exports.symbolStar = star;
  exports.symbolTriangle = triangle;
  exports.symbolWye = wye;
  exports.curveBasisClosed = basisClosed$1;
  exports.curveBasisOpen = basisOpen;
  exports.curveBasis = basis$2;
  exports.curveBundle = bundle;
  exports.curveCardinalClosed = cardinalClosed;
  exports.curveCardinalOpen = cardinalOpen;
  exports.curveCardinal = cardinal;
  exports.curveCatmullRomClosed = catmullRomClosed;
  exports.curveCatmullRomOpen = catmullRomOpen;
  exports.curveCatmullRom = catmullRom;
  exports.curveLinearClosed = linearClosed;
  exports.curveLinear = curveLinear;
  exports.curveMonotoneX = monotoneX;
  exports.curveMonotoneY = monotoneY;
  exports.curveNatural = natural;
  exports.curveStep = step;
  exports.curveStepAfter = stepAfter;
  exports.curveStepBefore = stepBefore;
  exports.stack = stack;
  exports.stackOffsetExpand = expand;
  exports.stackOffsetDiverging = diverging;
  exports.stackOffsetNone = none$1;
  exports.stackOffsetSilhouette = silhouette;
  exports.stackOffsetWiggle = wiggle;
  exports.stackOrderAscending = ascending$2;
  exports.stackOrderDescending = descending$2;
  exports.stackOrderInsideOut = insideOut;
  exports.stackOrderNone = none$2;
  exports.stackOrderReverse = reverse;
  exports.timeInterval = newInterval;
  exports.timeMillisecond = millisecond;
  exports.timeMilliseconds = milliseconds;
  exports.utcMillisecond = millisecond;
  exports.utcMilliseconds = milliseconds;
  exports.timeSecond = second;
  exports.timeSeconds = seconds;
  exports.utcSecond = second;
  exports.utcSeconds = seconds;
  exports.timeMinute = minute;
  exports.timeMinutes = minutes;
  exports.timeHour = hour;
  exports.timeHours = hours;
  exports.timeDay = day;
  exports.timeDays = days;
  exports.timeWeek = sunday;
  exports.timeWeeks = sundays;
  exports.timeSunday = sunday;
  exports.timeSundays = sundays;
  exports.timeMonday = monday;
  exports.timeMondays = mondays;
  exports.timeTuesday = tuesday;
  exports.timeTuesdays = tuesdays;
  exports.timeWednesday = wednesday;
  exports.timeWednesdays = wednesdays;
  exports.timeThursday = thursday;
  exports.timeThursdays = thursdays;
  exports.timeFriday = friday;
  exports.timeFridays = fridays;
  exports.timeSaturday = saturday;
  exports.timeSaturdays = saturdays;
  exports.timeMonth = month;
  exports.timeMonths = months;
  exports.timeYear = year;
  exports.timeYears = years;
  exports.utcMinute = utcMinute;
  exports.utcMinutes = utcMinutes;
  exports.utcHour = utcHour;
  exports.utcHours = utcHours;
  exports.utcDay = utcDay;
  exports.utcDays = utcDays;
  exports.utcWeek = utcSunday;
  exports.utcWeeks = utcSundays;
  exports.utcSunday = utcSunday;
  exports.utcSundays = utcSundays;
  exports.utcMonday = utcMonday;
  exports.utcMondays = utcMondays;
  exports.utcTuesday = utcTuesday;
  exports.utcTuesdays = utcTuesdays;
  exports.utcWednesday = utcWednesday;
  exports.utcWednesdays = utcWednesdays;
  exports.utcThursday = utcThursday;
  exports.utcThursdays = utcThursdays;
  exports.utcFriday = utcFriday;
  exports.utcFridays = utcFridays;
  exports.utcSaturday = utcSaturday;
  exports.utcSaturdays = utcSaturdays;
  exports.utcMonth = utcMonth;
  exports.utcMonths = utcMonths;
  exports.utcYear = utcYear;
  exports.utcYears = utcYears;
  exports.timeFormatDefaultLocale = defaultLocale$1;
  exports.timeFormatLocale = formatLocale$1;
  exports.isoFormat = formatIso;
  exports.isoParse = parseIso;
  exports.now = now;
  exports.timer = timer;
  exports.timerFlush = timerFlush;
  exports.timeout = timeout$1;
  exports.interval = interval$1;
  exports.transition = transition;
  exports.active = active;
  exports.interrupt = interrupt;
  exports.voronoi = voronoi;
  exports.zoom = zoom;
  exports.zoomTransform = transform$1;
  exports.zoomIdentity = identity$8;

  Object.defineProperty(exports, '__esModule', { value: true });
});

/***/ }),
/* 14 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var Hand = __webpack_require__(11),
    Pointable = __webpack_require__(4),
    createGesture = __webpack_require__(25).createGesture,
    glMatrix = __webpack_require__(2),
    mat3 = glMatrix.mat3,
    vec3 = glMatrix.vec3,
    InteractionBox = __webpack_require__(54),
    Finger = __webpack_require__(10),
    _ = __webpack_require__(0);

/**
 * Constructs a Frame object.
 *
 * Frame instances created with this constructor are invalid.
 * Get valid Frame objects by calling the
 * [Controller.frame]{@link Leap.Controller#frame}() function.
 *<C-D-Space>
 * @class Frame
 * @memberof Leap
 * @classdesc
 * The Frame class represents a set of hand and finger tracking data detected
 * in a single frame.
 *
 * The Leap detects hands, fingers and tools within the tracking area, reporting
 * their positions, orientations and motions in frames at the Leap frame rate.
 *
 * Access Frame objects using the [Controller.frame]{@link Leap.Controller#frame}() function.
 */
var Frame = module.exports = function (data) {
  /**
   * Reports whether this Frame instance is valid.
   *
   * A valid Frame is one generated by the Controller object that contains
   * tracking data for all detected entities. An invalid Frame contains no
   * actual tracking data, but you can call its functions without risk of a
   * undefined object exception. The invalid Frame mechanism makes it more
   * convenient to track individual data across the frame history. For example,
   * you can invoke:
   *
   * ```javascript
   * var finger = controller.frame(n).finger(fingerID);
   * ```
   *
   * for an arbitrary Frame history value, "n", without first checking whether
   * frame(n) returned a null object. (You should still check that the
   * returned Finger instance is valid.)
   *
   * @member valid
   * @memberof Leap.Frame.prototype
   * @type {Boolean}
   */
  this.valid = true;
  /**
   * A unique ID for this Frame. Consecutive frames processed by the Leap
   * have consecutive increasing values.
   * @member id
   * @memberof Leap.Frame.prototype
   * @type {String}
   */
  this.id = data.id;
  /**
   * The frame capture time in microseconds elapsed since the Leap started.
   * @member timestamp
   * @memberof Leap.Frame.prototype
   * @type {number}
   */
  this.timestamp = data.timestamp;
  /**
   * The list of Hand objects detected in this frame, given in arbitrary order.
   * The list can be empty if no hands are detected.
   *
   * @member hands[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Hand}
   */
  this.hands = [];
  this.handsMap = {};
  /**
   * The list of Pointable objects (fingers and tools) detected in this frame,
   * given in arbitrary order. The list can be empty if no fingers or tools are
   * detected.
   *
   * @member pointables[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Pointable}
   */
  this.pointables = [];
  /**
   * The list of Tool objects detected in this frame, given in arbitrary order.
   * The list can be empty if no tools are detected.
   *
   * @member tools[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Pointable}
   */
  this.tools = [];
  /**
   * The list of Finger objects detected in this frame, given in arbitrary order.
   * The list can be empty if no fingers are detected.
   * @member fingers[]
   * @memberof Leap.Frame.prototype
   * @type {Leap.Pointable}
   */
  this.fingers = [];

  /**
   * The InteractionBox associated with the current frame.
   *
   * @member interactionBox
   * @memberof Leap.Frame.prototype
   * @type {Leap.InteractionBox}
   */
  if (data.interactionBox) {
    this.interactionBox = new InteractionBox(data.interactionBox);
  }
  this.gestures = [];
  this.pointablesMap = {};
  this._translation = data.t;
  this._rotation = _.flatten(data.r);
  this._scaleFactor = data.s;
  this.data = data;
  this.type = 'frame'; // used by event emitting
  this.currentFrameRate = data.currentFrameRate;

  if (data.gestures) {
    /**
     * The list of Gesture objects detected in this frame, given in arbitrary order.
     * The list can be empty if no gestures are detected.
     *
     * Circle and swipe gestures are updated every frame. Tap gestures
     * only appear in the list for a single frame.
     * @member gestures[]
     * @memberof Leap.Frame.prototype
     * @type {Leap.Gesture}
     */
    for (var gestureIdx = 0, gestureCount = data.gestures.length; gestureIdx != gestureCount; gestureIdx++) {
      this.gestures.push(createGesture(data.gestures[gestureIdx]));
    }
  }
  this.postprocessData(data);
};

Frame.prototype.postprocessData = function (data) {
  if (!data) {
    data = this.data;
  }

  for (var handIdx = 0, handCount = data.hands.length; handIdx != handCount; handIdx++) {
    var hand = new Hand(data.hands[handIdx]);
    hand.frame = this;
    this.hands.push(hand);
    this.handsMap[hand.id] = hand;
  }

  data.pointables = _.sortBy(data.pointables, function (pointable) {
    return pointable.id;
  });

  for (var pointableIdx = 0, pointableCount = data.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
    var pointableData = data.pointables[pointableIdx];
    var pointable = pointableData.dipPosition ? new Finger(pointableData) : new Pointable(pointableData);
    pointable.frame = this;
    this.addPointable(pointable);
  }
};

/**
 * Adds data from a pointable element into the pointablesMap; 
 * also adds the pointable to the frame.handsMap hand to which it belongs,
 * and to the hand's tools or hand's fingers map.
 * 
 * @param pointable {Object} a Pointable
 */
Frame.prototype.addPointable = function (pointable) {
  this.pointables.push(pointable);
  this.pointablesMap[pointable.id] = pointable;
  (pointable.tool ? this.tools : this.fingers).push(pointable);
  if (pointable.handId !== undefined && this.handsMap.hasOwnProperty(pointable.handId)) {
    var hand = this.handsMap[pointable.handId];
    hand.pointables.push(pointable);
    (pointable.tool ? hand.tools : hand.fingers).push(pointable);
    switch (pointable.type) {
      case 0:
        hand.thumb = pointable;
        break;
      case 1:
        hand.indexFinger = pointable;
        break;
      case 2:
        hand.middleFinger = pointable;
        break;
      case 3:
        hand.ringFinger = pointable;
        break;
      case 4:
        hand.pinky = pointable;
        break;
    }
  }
};

/**
 * The tool with the specified ID in this frame.
 *
 * Use the Frame tool() function to retrieve a tool from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no tool
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a tool is lost and subsequently
 * regained, the new Pointable object representing that tool may have a
 * different ID than that representing the tool in an earlier frame.
 *
 * @method tool
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a Tool object from a previous frame.
 * @returns {Leap.Pointable} The tool with the
 * matching ID if one exists in this frame; otherwise, an invalid Pointable object
 * is returned.
 */
Frame.prototype.tool = function (id) {
  var pointable = this.pointable(id);
  return pointable.tool ? pointable : Pointable.Invalid;
};

/**
 * The Pointable object with the specified ID in this frame.
 *
 * Use the Frame pointable() function to retrieve the Pointable object from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no finger or tool
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a finger or tool is lost and subsequently
 * regained, the new Pointable object representing that finger or tool may have
 * a different ID than that representing the finger or tool in an earlier frame.
 *
 * @method pointable
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a Pointable object from a previous frame.
 * @returns {Leap.Pointable} The Pointable object with
 * the matching ID if one exists in this frame;
 * otherwise, an invalid Pointable object is returned.
 */
Frame.prototype.pointable = function (id) {
  return this.pointablesMap[id] || Pointable.Invalid;
};

/**
 * The finger with the specified ID in this frame.
 *
 * Use the Frame finger() function to retrieve the finger from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Finger object, but if no finger
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a finger is lost and subsequently
 * regained, the new Pointable object representing that physical finger may have
 * a different ID than that representing the finger in an earlier frame.
 *
 * @method finger
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a finger from a previous frame.
 * @returns {Leap.Pointable} The finger with the
 * matching ID if one exists in this frame; otherwise, an invalid Pointable
 * object is returned.
 */
Frame.prototype.finger = function (id) {
  var pointable = this.pointable(id);
  return !pointable.tool ? pointable : Pointable.Invalid;
};

/**
 * The Hand object with the specified ID in this frame.
 *
 * Use the Frame hand() function to retrieve the Hand object from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Hand object, but if no hand
 * with the specified ID is present, an invalid Hand object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a hand is lost and subsequently
 * regained, the new Hand object representing that physical hand may have
 * a different ID than that representing the physical hand in an earlier frame.
 *
 * @method hand
 * @memberof Leap.Frame.prototype
 * @param {String} id The ID value of a Hand object from a previous frame.
 * @returns {Leap.Hand} The Hand object with the matching
 * ID if one exists in this frame; otherwise, an invalid Hand object is returned.
 */
Frame.prototype.hand = function (id) {
  return this.handsMap[id] || Hand.Invalid;
};

/**
 * The angle of rotation around the rotation axis derived from the overall
 * rotational motion between the current frame and the specified frame.
 *
 * The returned angle is expressed in radians measured clockwise around
 * the rotation axis (using the right-hand rule) between the start and end frames.
 * The value is always between 0 and pi radians (0 and 180 degrees).
 *
 * The Leap derives frame rotation from the relative change in position and
 * orientation of all objects detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, then the
 * angle of rotation is zero.
 *
 * @method rotationAngle
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @param {number[]} [axis] The axis to measure rotation around.
 * @returns {number} A positive value containing the heuristically determined
 * rotational change between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.rotationAngle = function (sinceFrame, axis) {
  if (!this.valid || !sinceFrame.valid) return 0.0;

  var rot = this.rotationMatrix(sinceFrame);
  var cs = (rot[0] + rot[4] + rot[8] - 1.0) * 0.5;
  var angle = Math.acos(cs);
  angle = isNaN(angle) ? 0.0 : angle;

  if (axis !== undefined) {
    var rotAxis = this.rotationAxis(sinceFrame);
    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));
  }

  return angle;
};

/**
 * The axis of rotation derived from the overall rotational motion between
 * the current frame and the specified frame.
 *
 * The returned direction vector is normalized.
 *
 * The Leap derives frame rotation from the relative change in position and
 * orientation of all objects detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, or if no
 * rotation is detected between the two frames, a zero vector is returned.
 *
 * @method rotationAxis
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A normalized direction vector representing the axis of the heuristically determined
 * rotational change between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.rotationAxis = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  return vec3.normalize(vec3.create(), [this._rotation[7] - sinceFrame._rotation[5], this._rotation[2] - sinceFrame._rotation[6], this._rotation[3] - sinceFrame._rotation[1]]);
};

/**
 * The transform matrix expressing the rotation derived from the overall
 * rotational motion between the current frame and the specified frame.
 *
 * The Leap derives frame rotation from the relative change in position and
 * orientation of all objects detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, then
 * this method returns an identity matrix.
 *
 * @method rotationMatrix
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
 * @returns {number[]} A transformation matrix containing the heuristically determined
 * rotational change between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.rotationMatrix = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return mat3.create();
  var transpose = mat3.transpose(mat3.create(), this._rotation);
  return mat3.multiply(mat3.create(), sinceFrame._rotation, transpose);
};

/**
 * The scale factor derived from the overall motion between the current frame and the specified frame.
 *
 * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
 * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
 *
 * The Leap derives scaling from the relative inward or outward motion of all
 * objects detected in the field of view (independent of translation and rotation).
 *
 * If either this frame or sinceFrame is an invalid Frame object, then this method returns 1.0.
 *
 * @method scaleFactor
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.
 * @returns {number} A positive value representing the heuristically determined
 * scaling change ratio between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.scaleFactor = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return 1.0;
  return Math.exp(this._scaleFactor - sinceFrame._scaleFactor);
};

/**
 * The change of position derived from the overall linear motion between the
 * current frame and the specified frame.
 *
 * The returned translation vector provides the magnitude and direction of the
 * movement in millimeters.
 *
 * The Leap derives frame translation from the linear motion of all objects
 * detected in the field of view.
 *
 * If either this frame or sinceFrame is an invalid Frame object, then this
 * method returns a zero vector.
 *
 * @method translation
 * @memberof Leap.Frame.prototype
 * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.
 * @returns {number[]} A vector representing the heuristically determined change in
 * position of all objects between the current frame and that specified in the sinceFrame parameter.
 */
Frame.prototype.translation = function (sinceFrame) {
  if (!this.valid || !sinceFrame.valid) return vec3.create();
  return vec3.subtract(vec3.create(), this._translation, sinceFrame._translation);
};

/**
 * A string containing a brief, human readable description of the Frame object.
 *
 * @method toString
 * @memberof Leap.Frame.prototype
 * @returns {String} A brief description of this frame.
 */
Frame.prototype.toString = function () {
  var str = "Frame [ id:" + this.id + " | timestamp:" + this.timestamp + " | Hand count:(" + this.hands.length + ") | Pointable count:(" + this.pointables.length + ")";
  if (this.gestures) str += " | Gesture count:(" + this.gestures.length + ")";
  str += " ]";
  return str;
};

/**
 * Returns a JSON-formatted string containing the hands, pointables and gestures
 * in this frame.
 *
 * @method dump
 * @memberof Leap.Frame.prototype
 * @returns {String} A JSON-formatted string.
 */
Frame.prototype.dump = function () {
  var out = '';
  out += "Frame Info:<br/>";
  out += this.toString();
  out += "<br/><br/>Hands:<br/>";
  for (var handIdx = 0, handCount = this.hands.length; handIdx != handCount; handIdx++) {
    out += "  " + this.hands[handIdx].toString() + "<br/>";
  }
  out += "<br/><br/>Pointables:<br/>";
  for (var pointableIdx = 0, pointableCount = this.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
    out += "  " + this.pointables[pointableIdx].toString() + "<br/>";
  }
  if (this.gestures) {
    out += "<br/><br/>Gestures:<br/>";
    for (var gestureIdx = 0, gestureCount = this.gestures.length; gestureIdx != gestureCount; gestureIdx++) {
      out += "  " + this.gestures[gestureIdx].toString() + "<br/>";
    }
  }
  out += "<br/><br/>Raw JSON:<br/>";
  out += JSON.stringify(this.data);
  return out;
};

/**
 * An invalid Frame object.
 *
 * You can use this invalid Frame in comparisons testing
 * whether a given Frame instance is valid or invalid. (You can also check the
 * [Frame.valid]{@link Leap.Frame#valid} property.)
 *
 * @static
 * @type {Leap.Frame}
 * @name Invalid
 * @memberof Leap.Frame
 */
Frame.Invalid = {
  valid: false,
  hands: [],
  fingers: [],
  tools: [],
  gestures: [],
  pointables: [],
  pointable: function () {
    return Pointable.Invalid;
  },
  finger: function () {
    return Pointable.Invalid;
  },
  hand: function () {
    return Hand.Invalid;
  },
  toString: function () {
    return "invalid frame";
  },
  dump: function () {
    return this.toString();
  },
  rotationAngle: function () {
    return 0.0;
  },
  rotationMatrix: function () {
    return mat3.create();
  },
  rotationAxis: function () {
    return vec3.create();
  },
  scaleFactor: function () {
    return 1.0;
  },
  translation: function () {
    return vec3.create();
  }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var glMatrix = __webpack_require__(2),
    vec3 = glMatrix.vec3,
    EventEmitter = __webpack_require__(3).EventEmitter,
    _ = __webpack_require__(0);

/**
 * Constructs a new Gesture object.
 *
 * An uninitialized Gesture object is considered invalid. Get valid instances
 * of the Gesture class, which will be one of the Gesture subclasses, from a
 * Frame object.
 *
 * @class Gesture
 * @abstract
 * @memberof Leap
 * @classdesc
 * The Gesture class represents a recognized movement by the user.
 *
 * The Leap watches the activity within its field of view for certain movement
 * patterns typical of a user gesture or command. For example, a movement from side to
 * side with the hand can indicate a swipe gesture, while a finger poking forward
 * can indicate a screen tap gesture.
 *
 * When the Leap recognizes a gesture, it assigns an ID and adds a
 * Gesture object to the frame gesture list. For continuous gestures, which
 * occur over many frames, the Leap updates the gesture by adding
 * a Gesture object having the same ID and updated properties in each
 * subsequent frame.
 *
 * **Important:** Recognition for each type of gesture must be enabled;
 * otherwise **no gestures are recognized or reported**.
 *
 * Subclasses of Gesture define the properties for the specific movement patterns
 * recognized by the Leap.
 *
 * The Gesture subclasses for include:
 *
 * * CircleGesture -- A circular movement by a finger.
 * * SwipeGesture -- A straight line movement by the hand with fingers extended.
 * * ScreenTapGesture -- A forward tapping movement by a finger.
 * * KeyTapGesture -- A downward tapping movement by a finger.
 *
 * Circle and swipe gestures are continuous and these objects can have a
 * state of start, update, and stop.
 *
 * The screen tap gesture is a discrete gesture. The Leap only creates a single
 * ScreenTapGesture object appears for each tap and it always has a stop state.
 *
 * Get valid Gesture instances from a Frame object. You can get a list of gestures
 * from the Frame gestures array. You can also use the Frame gesture() method
 * to find a gesture in the current frame using an ID value obtained in a
 * previous frame.
 *
 * Gesture objects can be invalid. For example, when you get a gesture by ID
 * using Frame.gesture(), and there is no gesture with that ID in the current
 * frame, then gesture() returns an Invalid Gesture object (rather than a null
 * value). Always check object validity in situations where a gesture might be
 * invalid.
 */
var createGesture = exports.createGesture = function (data) {
  var gesture;
  switch (data.type) {
    case 'circle':
      gesture = new CircleGesture(data);
      break;
    case 'swipe':
      gesture = new SwipeGesture(data);
      break;
    case 'screenTap':
      gesture = new ScreenTapGesture(data);
      break;
    case 'keyTap':
      gesture = new KeyTapGesture(data);
      break;
    default:
      throw "unknown gesture type";
  }

  /**
   * The gesture ID.
   *
   * All Gesture objects belonging to the same recognized movement share the
   * same ID value. Use the ID value with the Frame::gesture() method to
   * find updates related to this Gesture object in subsequent frames.
   *
   * @member id
   * @memberof Leap.Gesture.prototype
   * @type {number}
   */
  gesture.id = data.id;
  /**
   * The list of hands associated with this Gesture, if any.
   *
   * If no hands are related to this gesture, the list is empty.
   *
   * @member handIds
   * @memberof Leap.Gesture.prototype
   * @type {Array}
   */
  gesture.handIds = data.handIds.slice();
  /**
   * The list of fingers and tools associated with this Gesture, if any.
   *
   * If no Pointable objects are related to this gesture, the list is empty.
   *
   * @member pointableIds
   * @memberof Leap.Gesture.prototype
   * @type {Array}
   */
  gesture.pointableIds = data.pointableIds.slice();
  /**
   * The elapsed duration of the recognized movement up to the
   * frame containing this Gesture object, in microseconds.
   *
   * The duration reported for the first Gesture in the sequence (with the
   * start state) will typically be a small positive number since
   * the movement must progress far enough for the Leap to recognize it as
   * an intentional gesture.
   *
   * @member duration
   * @memberof Leap.Gesture.prototype
   * @type {number}
   */
  gesture.duration = data.duration;
  /**
   * The gesture ID.
   *
   * Recognized movements occur over time and have a beginning, a middle,
   * and an end. The 'state()' attribute reports where in that sequence this
   * Gesture object falls.
   *
   * Possible values for the state field are:
   *
   * * start
   * * update
   * * stop
   *
   * @member state
   * @memberof Leap.Gesture.prototype
   * @type {String}
   */
  gesture.state = data.state;
  /**
   * The gesture type.
   *
   * Possible values for the type field are:
   *
   * * circle
   * * swipe
   * * screenTap
   * * keyTap
   *
   * @member type
   * @memberof Leap.Gesture.prototype
   * @type {String}
   */
  gesture.type = data.type;
  return gesture;
};

/*
 * Returns a builder object, which uses method chaining for gesture callback binding.
 */
var gestureListener = exports.gestureListener = function (controller, type) {
  var handlers = {};
  var gestureMap = {};

  controller.on('gesture', function (gesture, frame) {
    if (gesture.type == type) {
      if (gesture.state == "start" || gesture.state == "stop") {
        if (gestureMap[gesture.id] === undefined) {
          var gestureTracker = new Gesture(gesture, frame);
          gestureMap[gesture.id] = gestureTracker;
          _.each(handlers, function (cb, name) {
            gestureTracker.on(name, cb);
          });
        }
      }
      gestureMap[gesture.id].update(gesture, frame);
      if (gesture.state == "stop") {
        delete gestureMap[gesture.id];
      }
    }
  });
  var builder = {
    start: function (cb) {
      handlers['start'] = cb;
      return builder;
    },
    stop: function (cb) {
      handlers['stop'] = cb;
      return builder;
    },
    complete: function (cb) {
      handlers['stop'] = cb;
      return builder;
    },
    update: function (cb) {
      handlers['update'] = cb;
      return builder;
    }
  };
  return builder;
};

var Gesture = exports.Gesture = function (gesture, frame) {
  this.gestures = [gesture];
  this.frames = [frame];
};

Gesture.prototype.update = function (gesture, frame) {
  this.lastGesture = gesture;
  this.lastFrame = frame;
  this.gestures.push(gesture);
  this.frames.push(frame);
  this.emit(gesture.state, this);
};

Gesture.prototype.translation = function () {
  return vec3.subtract(vec3.create(), this.lastGesture.startPosition, this.lastGesture.position);
};

_.extend(Gesture.prototype, EventEmitter.prototype);

/**
 * Constructs a new CircleGesture object.
 *
 * An uninitialized CircleGesture object is considered invalid. Get valid instances
 * of the CircleGesture class from a Frame object.
 *
 * @class CircleGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The CircleGesture classes represents a circular finger movement.
 *
 * A circle movement is recognized when the tip of a finger draws a circle
 * within the Leap field of view.
 *
 * ![CircleGesture](images/Leap_Gesture_Circle.png)
 *
 * Circle gestures are continuous. The CircleGesture objects for the gesture have
 * three possible states:
 *
 * * start -- The circle gesture has just started. The movement has
 *  progressed far enough for the recognizer to classify it as a circle.
 * * update -- The circle gesture is continuing.
 * * stop -- The circle gesture is finished.
 */
var CircleGesture = function (data) {
  /**
   * The center point of the circle within the Leap frame of reference.
   *
   * @member center
   * @memberof Leap.CircleGesture.prototype
   * @type {number[]}
   */
  this.center = data.center;
  /**
   * The normal vector for the circle being traced.
   *
   * If you draw the circle clockwise, the normal vector points in the same
   * general direction as the pointable object drawing the circle. If you draw
   * the circle counterclockwise, the normal points back toward the
   * pointable. If the angle between the normal and the pointable object
   * drawing the circle is less than 90 degrees, then the circle is clockwise.
   *
   * ```javascript
   *    var clockwiseness;
   *    if (circle.pointable.direction.angleTo(circle.normal) <= PI/4) {
   *        clockwiseness = "clockwise";
   *    }
   *    else
   *    {
   *        clockwiseness = "counterclockwise";
   *    }
   * ```
   *
   * @member normal
   * @memberof Leap.CircleGesture.prototype
   * @type {number[]}
   */
  this.normal = data.normal;
  /**
   * The number of times the finger tip has traversed the circle.
   *
   * Progress is reported as a positive number of the number. For example,
   * a progress value of .5 indicates that the finger has gone halfway
   * around, while a value of 3 indicates that the finger has gone around
   * the the circle three times.
   *
   * Progress starts where the circle gesture began. Since the circle
   * must be partially formed before the Leap can recognize it, progress
   * will be greater than zero when a circle gesture first appears in the
   * frame.
   *
   * @member progress
   * @memberof Leap.CircleGesture.prototype
   * @type {number}
   */
  this.progress = data.progress;
  /**
   * The radius of the circle in mm.
   *
   * @member radius
   * @memberof Leap.CircleGesture.prototype
   * @type {number}
   */
  this.radius = data.radius;
};

CircleGesture.prototype.toString = function () {
  return "CircleGesture [" + JSON.stringify(this) + "]";
};

/**
 * Constructs a new SwipeGesture object.
 *
 * An uninitialized SwipeGesture object is considered invalid. Get valid instances
 * of the SwipeGesture class from a Frame object.
 *
 * @class SwipeGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The SwipeGesture class represents a swiping motion of a finger or tool.
 *
 * ![SwipeGesture](images/Leap_Gesture_Swipe.png)
 *
 * Swipe gestures are continuous.
 */
var SwipeGesture = function (data) {
  /**
   * The starting position within the Leap frame of
   * reference, in mm.
   *
   * @member startPosition
   * @memberof Leap.SwipeGesture.prototype
   * @type {number[]}
   */
  this.startPosition = data.startPosition;
  /**
   * The current swipe position within the Leap frame of
   * reference, in mm.
   *
   * @member position
   * @memberof Leap.SwipeGesture.prototype
   * @type {number[]}
   */
  this.position = data.position;
  /**
   * The unit direction vector parallel to the swipe motion.
   *
   * You can compare the components of the vector to classify the swipe as
   * appropriate for your application. For example, if you are using swipes
   * for two dimensional scrolling, you can compare the x and y values to
   * determine if the swipe is primarily horizontal or vertical.
   *
   * @member direction
   * @memberof Leap.SwipeGesture.prototype
   * @type {number[]}
   */
  this.direction = data.direction;
  /**
   * The speed of the finger performing the swipe gesture in
   * millimeters per second.
   *
   * @member speed
   * @memberof Leap.SwipeGesture.prototype
   * @type {number}
   */
  this.speed = data.speed;
};

SwipeGesture.prototype.toString = function () {
  return "SwipeGesture [" + JSON.stringify(this) + "]";
};

/**
 * Constructs a new ScreenTapGesture object.
 *
 * An uninitialized ScreenTapGesture object is considered invalid. Get valid instances
 * of the ScreenTapGesture class from a Frame object.
 *
 * @class ScreenTapGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The ScreenTapGesture class represents a tapping gesture by a finger or tool.
 *
 * A screen tap gesture is recognized when the tip of a finger pokes forward
 * and then springs back to approximately the original postion, as if
 * tapping a vertical screen. The tapping finger must pause briefly before beginning the tap.
 *
 * ![ScreenTap](images/Leap_Gesture_Tap2.png)
 *
 * ScreenTap gestures are discrete. The ScreenTapGesture object representing a tap always
 * has the state, STATE_STOP. Only one ScreenTapGesture object is created for each
 * screen tap gesture recognized.
 */
var ScreenTapGesture = function (data) {
  /**
   * The position where the screen tap is registered.
   *
   * @member position
   * @memberof Leap.ScreenTapGesture.prototype
   * @type {number[]}
   */
  this.position = data.position;
  /**
   * The direction of finger tip motion.
   *
   * @member direction
   * @memberof Leap.ScreenTapGesture.prototype
   * @type {number[]}
   */
  this.direction = data.direction;
  /**
   * The progess value is always 1.0 for a screen tap gesture.
   *
   * @member progress
   * @memberof Leap.ScreenTapGesture.prototype
   * @type {number}
   */
  this.progress = data.progress;
};

ScreenTapGesture.prototype.toString = function () {
  return "ScreenTapGesture [" + JSON.stringify(this) + "]";
};

/**
 * Constructs a new KeyTapGesture object.
 *
 * An uninitialized KeyTapGesture object is considered invalid. Get valid instances
 * of the KeyTapGesture class from a Frame object.
 *
 * @class KeyTapGesture
 * @memberof Leap
 * @augments Leap.Gesture
 * @classdesc
 * The KeyTapGesture class represents a tapping gesture by a finger or tool.
 *
 * A key tap gesture is recognized when the tip of a finger rotates down toward the
 * palm and then springs back to approximately the original postion, as if
 * tapping. The tapping finger must pause briefly before beginning the tap.
 *
 * ![KeyTap](images/Leap_Gesture_Tap.png)
 *
 * Key tap gestures are discrete. The KeyTapGesture object representing a tap always
 * has the state, STATE_STOP. Only one KeyTapGesture object is created for each
 * key tap gesture recognized.
 */
var KeyTapGesture = function (data) {
  /**
   * The position where the key tap is registered.
   *
   * @member position
   * @memberof Leap.KeyTapGesture.prototype
   * @type {number[]}
   */
  this.position = data.position;
  /**
   * The direction of finger tip motion.
   *
   * @member direction
   * @memberof Leap.KeyTapGesture.prototype
   * @type {number[]}
   */
  this.direction = data.direction;
  /**
   * The progess value is always 1.0 for a key tap gesture.
   *
   * @member progress
   * @memberof Leap.KeyTapGesture.prototype
   * @type {number}
   */
  this.progress = data.progress;
};

KeyTapGesture.prototype.toString = function () {
  return "KeyTapGesture [" + JSON.stringify(this) + "]";
};

/***/ }),
/* 26 */
/***/ (function(module, exports) {

/* Zepto v1.1.6 - zepto event ajax form ie - zeptojs.com/license */

var Zepto = module.exports = function () {
  var undefined,
      key,
      $,
      classList,
      emptyArray = [],
      slice = emptyArray.slice,
      filter = emptyArray.filter,
      document = window.document,
      elementDisplay = {},
      classCache = {},
      cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1, 'opacity': 1, 'z-index': 1, 'zoom': 1 },
      fragmentRE = /^\s*<(\w+|!)[^>]*>/,
      singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
      rootNodeRE = /^(?:body|html)$/i,
      capitalRE = /([A-Z])/g,


  // special attributes that should be get/set via method calls
  methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],
      adjacencyOperators = ['after', 'prepend', 'before', 'append'],
      table = document.createElement('table'),
      tableRow = document.createElement('tr'),
      containers = {
    'tr': document.createElement('tbody'),
    'tbody': table, 'thead': table, 'tfoot': table,
    'td': tableRow, 'th': tableRow,
    '*': document.createElement('div')
  },
      readyRE = /complete|loaded|interactive/,
      simpleSelectorRE = /^[\w-]*$/,
      class2type = {},
      toString = class2type.toString,
      zepto = {},
      camelize,
      uniq,
      tempParent = document.createElement('div'),
      propMap = {
    'tabindex': 'tabIndex',
    'readonly': 'readOnly',
    'for': 'htmlFor',
    'class': 'className',
    'maxlength': 'maxLength',
    'cellspacing': 'cellSpacing',
    'cellpadding': 'cellPadding',
    'rowspan': 'rowSpan',
    'colspan': 'colSpan',
    'usemap': 'useMap',
    'frameborder': 'frameBorder',
    'contenteditable': 'contentEditable'
  },
      isArray = Array.isArray || function (object) {
    return object instanceof Array;
  };

  zepto.matches = function (element, selector) {
    if (!selector || !element || element.nodeType !== 1) return false;
    var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;
    if (matchesSelector) return matchesSelector.call(element, selector);
    // fall back to performing a selector:
    var match,
        parent = element.parentNode,
        temp = !parent;
    if (temp) (parent = tempParent).appendChild(element);
    match = ~zepto.qsa(parent, selector).indexOf(element);
    temp && tempParent.removeChild(element);
    return match;
  };

  function type(obj) {
    return obj == null ? String(obj) : class2type[toString.call(obj)] || "object";
  }

  function isFunction(value) {
    return type(value) == "function";
  }
  function isWindow(obj) {
    return obj != null && obj == obj.window;
  }
  function isDocument(obj) {
    return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
  }
  function isObject(obj) {
    return type(obj) == "object";
  }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
  }
  function likeArray(obj) {
    return typeof obj.length == 'number';
  }

  function compact(array) {
    return filter.call(array, function (item) {
      return item != null;
    });
  }
  function flatten(array) {
    return array.length > 0 ? $.fn.concat.apply([], array) : array;
  }
  camelize = function (str) {
    return str.replace(/-+(.)?/g, function (match, chr) {
      return chr ? chr.toUpperCase() : '';
    });
  };
  function dasherize(str) {
    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
  }
  uniq = function (array) {
    return filter.call(array, function (item, idx) {
      return array.indexOf(item) == idx;
    });
  };

  function classRE(name) {
    return name in classCache ? classCache[name] : classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
  }

  function maybeAddPx(name, value) {
    return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
  }

  function defaultDisplay(nodeName) {
    var element, display;
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName);
      document.body.appendChild(element);
      display = getComputedStyle(element, '').getPropertyValue("display");
      element.parentNode.removeChild(element);
      display == "none" && (display = "block");
      elementDisplay[nodeName] = display;
    }
    return elementDisplay[nodeName];
  }

  function children(element) {
    return 'children' in element ? slice.call(element.children) : $.map(element.childNodes, function (node) {
      if (node.nodeType == 1) return node;
    });
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overriden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function (html, name, properties) {
    var dom, nodes, container;

    // A special case optimization for a single tag
    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1));

    if (!dom) {
      if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>");
      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1;
      if (!(name in containers)) name = '*';

      container = containers[name];
      container.innerHTML = '' + html;
      dom = $.each(slice.call(container.childNodes), function () {
        container.removeChild(this);
      });
    }

    if (isPlainObject(properties)) {
      nodes = $(dom);
      $.each(properties, function (key, value) {
        if (methodAttributes.indexOf(key) > -1) nodes[key](value);else nodes.attr(key, value);
      });
    }

    return dom;
  };

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the Zepto functions
  // to the array. Note that `__proto__` is not supported on Internet
  // Explorer. This method can be overriden in plugins.
  zepto.Z = function (dom, selector) {
    dom = dom || [];
    dom.__proto__ = $.fn;
    dom.selector = selector || '';
    return dom;
  };

  // `$.zepto.isZ` should return `true` if the given object is a Zepto
  // collection. This method can be overriden in plugins.
  zepto.isZ = function (object) {
    return object instanceof zepto.Z;
  };

  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overriden in plugins.
  zepto.init = function (selector, context) {
    var dom;
    // If nothing given, return an empty Zepto collection
    if (!selector) return zepto.Z();
    // Optimize for string selectors
    else if (typeof selector == 'string') {
        selector = selector.trim();
        // If it's a html fragment, create nodes from it
        // Note: In both Chrome 21 and Firefox 15, DOM error 12
        // is thrown if the fragment doesn't begin with <
        if (selector[0] == '<' && fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null;
        // If there's a context, create a collection on that context first, and select
        // nodes from there
        else if (context !== undefined) return $(context).find(selector);
          // If it's a CSS selector, use it to select nodes.
          else dom = zepto.qsa(document, selector);
      }
      // If a function is given, call it when the DOM is ready
      else if (isFunction(selector)) return $(document).ready(selector);
        // If a Zepto collection is given, just return it
        else if (zepto.isZ(selector)) return selector;else {
            // normalize array if an array of nodes is given
            if (isArray(selector)) dom = compact(selector);
            // Wrap DOM nodes.
            else if (isObject(selector)) dom = [selector], selector = null;
              // If it's a html fragment, create nodes from it
              else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null;
                // If there's a context, create a collection on that context first, and select
                // nodes from there
                else if (context !== undefined) return $(context).find(selector);
                  // And last but no least, if it's a CSS selector, use it to select nodes.
                  else dom = zepto.qsa(document, selector);
          }
    // create a new Zepto collection from the nodes found
    return zepto.Z(dom, selector);
  };

  // `$` will be the base `Zepto` object. When calling this
  // function just call `$.zepto.init, which makes the implementation
  // details of selecting nodes and creating Zepto collections
  // patchable in plugins.
  $ = function (selector, context) {
    return zepto.init(selector, context);
  };

  function extend(target, source, deep) {
    for (key in source) if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
      if (isPlainObject(source[key]) && !isPlainObject(target[key])) target[key] = {};
      if (isArray(source[key]) && !isArray(target[key])) target[key] = [];
      extend(target[key], source[key], deep);
    } else if (source[key] !== undefined) target[key] = source[key];
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function (target) {
    var deep,
        args = slice.call(arguments, 1);
    if (typeof target == 'boolean') {
      deep = target;
      target = args.shift();
    }
    args.forEach(function (arg) {
      extend(target, arg, deep);
    });
    return target;
  };

  // `$.zepto.qsa` is Zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overriden in plugins.
  zepto.qsa = function (element, selector) {
    var found,
        maybeID = selector[0] == '#',
        maybeClass = !maybeID && selector[0] == '.',
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector,
        // Ensure that a 1 char tag name still gets checked
    isSimple = simpleSelectorRE.test(nameOnly);
    return isDocument(element) && isSimple && maybeID ? (found = element.getElementById(nameOnly)) ? [found] : [] : element.nodeType !== 1 && element.nodeType !== 9 ? [] : slice.call(isSimple && !maybeID ? maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
    element.getElementsByTagName(selector) : // Or a tag
    element.querySelectorAll(selector) // Or it's not simple, and we need to query all
    );
  };

  function filtered(nodes, selector) {
    return selector == null ? $(nodes) : $(nodes).filter(selector);
  }

  $.contains = document.documentElement.contains ? function (parent, node) {
    return parent !== node && parent.contains(node);
  } : function (parent, node) {
    while (node && (node = node.parentNode)) if (node === parent) return true;
    return false;
  };

  function funcArg(context, arg, idx, payload) {
    return isFunction(arg) ? arg.call(context, idx, payload) : arg;
  }

  function setAttribute(node, name, value) {
    value == null ? node.removeAttribute(name) : node.setAttribute(name, value);
  }

  // access className property while respecting SVGAnimatedString
  function className(node, value) {
    var klass = node.className || '',
        svg = klass && klass.baseVal !== undefined;

    if (value === undefined) return svg ? klass.baseVal : klass;
    svg ? klass.baseVal = value : node.className = value;
  }

  // "true"  => true
  // "false" => false
  // "null"  => null
  // "42"    => 42
  // "42.5"  => 42.5
  // "08"    => "08"
  // JSON    => parse if valid
  // String  => self
  function deserializeValue(value) {
    try {
      return value ? value == "true" || (value == "false" ? false : value == "null" ? null : +value + "" == value ? +value : /^[\[\{]/.test(value) ? $.parseJSON(value) : value) : value;
    } catch (e) {
      return value;
    }
  }

  $.type = type;
  $.isFunction = isFunction;
  $.isWindow = isWindow;
  $.isArray = isArray;
  $.isPlainObject = isPlainObject;

  $.isEmptyObject = function (obj) {
    var name;
    for (name in obj) return false;
    return true;
  };

  $.inArray = function (elem, array, i) {
    return emptyArray.indexOf.call(array, elem, i);
  };

  $.camelCase = camelize;
  $.trim = function (str) {
    return str == null ? "" : String.prototype.trim.call(str);
  };

  // plugin compatibility
  $.uuid = 0;
  $.support = {};
  $.expr = {};

  $.map = function (elements, callback) {
    var value,
        values = [],
        i,
        key;
    if (likeArray(elements)) for (i = 0; i < elements.length; i++) {
      value = callback(elements[i], i);
      if (value != null) values.push(value);
    } else for (key in elements) {
      value = callback(elements[key], key);
      if (value != null) values.push(value);
    }
    return flatten(values);
  };

  $.each = function (elements, callback) {
    var i, key;
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements;
    } else {
      for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements;
    }

    return elements;
  };

  $.grep = function (elements, callback) {
    return filter.call(elements, callback);
  };

  if (window.JSON) $.parseJSON = JSON.parse;

  // Populate the class2type map
  $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  // Define methods that will be available on all
  // Zepto collections
  $.fn = {
    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    sort: emptyArray.sort,
    indexOf: emptyArray.indexOf,
    concat: emptyArray.concat,

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function (fn) {
      return $($.map(this, function (el, i) {
        return fn.call(el, i, el);
      }));
    },
    slice: function () {
      return $(slice.apply(this, arguments));
    },

    ready: function (callback) {
      // need to check if document.body exists for IE as that browser reports
      // document ready when it hasn't yet created the body element
      if (readyRE.test(document.readyState) && document.body) callback($);else document.addEventListener('DOMContentLoaded', function () {
        callback($);
      }, false);
      return this;
    },
    get: function (idx) {
      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
    },
    toArray: function () {
      return this.get();
    },
    size: function () {
      return this.length;
    },
    remove: function () {
      return this.each(function () {
        if (this.parentNode != null) this.parentNode.removeChild(this);
      });
    },
    each: function (callback) {
      emptyArray.every.call(this, function (el, idx) {
        return callback.call(el, idx, el) !== false;
      });
      return this;
    },
    filter: function (selector) {
      if (isFunction(selector)) return this.not(this.not(selector));
      return $(filter.call(this, function (element) {
        return zepto.matches(element, selector);
      }));
    },
    add: function (selector, context) {
      return $(uniq(this.concat($(selector, context))));
    },
    is: function (selector) {
      return this.length > 0 && zepto.matches(this[0], selector);
    },
    not: function (selector) {
      var nodes = [];
      if (isFunction(selector) && selector.call !== undefined) this.each(function (idx) {
        if (!selector.call(this, idx)) nodes.push(this);
      });else {
        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? slice.call(selector) : $(selector);
        this.forEach(function (el) {
          if (excludes.indexOf(el) < 0) nodes.push(el);
        });
      }
      return $(nodes);
    },
    has: function (selector) {
      return this.filter(function () {
        return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size();
      });
    },
    eq: function (idx) {
      return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
    },
    first: function () {
      var el = this[0];
      return el && !isObject(el) ? el : $(el);
    },
    last: function () {
      var el = this[this.length - 1];
      return el && !isObject(el) ? el : $(el);
    },
    find: function (selector) {
      var result,
          $this = this;
      if (!selector) result = $();else if (typeof selector == 'object') result = $(selector).filter(function () {
        var node = this;
        return emptyArray.some.call($this, function (parent) {
          return $.contains(parent, node);
        });
      });else if (this.length == 1) result = $(zepto.qsa(this[0], selector));else result = this.map(function () {
        return zepto.qsa(this, selector);
      });
      return result;
    },
    closest: function (selector, context) {
      var node = this[0],
          collection = false;
      if (typeof selector == 'object') collection = $(selector);
      while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector))) node = node !== context && !isDocument(node) && node.parentNode;
      return $(node);
    },
    parents: function (selector) {
      var ancestors = [],
          nodes = this;
      while (nodes.length > 0) nodes = $.map(nodes, function (node) {
        if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
          ancestors.push(node);
          return node;
        }
      });
      return filtered(ancestors, selector);
    },
    parent: function (selector) {
      return filtered(uniq(this.pluck('parentNode')), selector);
    },
    children: function (selector) {
      return filtered(this.map(function () {
        return children(this);
      }), selector);
    },
    contents: function () {
      return this.map(function () {
        return slice.call(this.childNodes);
      });
    },
    siblings: function (selector) {
      return filtered(this.map(function (i, el) {
        return filter.call(children(el.parentNode), function (child) {
          return child !== el;
        });
      }), selector);
    },
    empty: function () {
      return this.each(function () {
        this.innerHTML = '';
      });
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function (property) {
      return $.map(this, function (el) {
        return el[property];
      });
    },
    show: function () {
      return this.each(function () {
        this.style.display == "none" && (this.style.display = '');
        if (getComputedStyle(this, '').getPropertyValue("display") == "none") this.style.display = defaultDisplay(this.nodeName);
      });
    },
    replaceWith: function (newContent) {
      return this.before(newContent).remove();
    },
    wrap: function (structure) {
      var func = isFunction(structure);
      if (this[0] && !func) var dom = $(structure).get(0),
          clone = dom.parentNode || this.length > 1;

      return this.each(function (index) {
        $(this).wrapAll(func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom);
      });
    },
    wrapAll: function (structure) {
      if (this[0]) {
        $(this[0]).before(structure = $(structure));
        var children;
        // drill down to the inmost element
        while ((children = structure.children()).length) structure = children.first();
        $(structure).append(this);
      }
      return this;
    },
    wrapInner: function (structure) {
      var func = isFunction(structure);
      return this.each(function (index) {
        var self = $(this),
            contents = self.contents(),
            dom = func ? structure.call(this, index) : structure;
        contents.length ? contents.wrapAll(dom) : self.append(dom);
      });
    },
    unwrap: function () {
      this.parent().each(function () {
        $(this).replaceWith($(this).children());
      });
      return this;
    },
    clone: function () {
      return this.map(function () {
        return this.cloneNode(true);
      });
    },
    hide: function () {
      return this.css("display", "none");
    },
    toggle: function (setting) {
      return this.each(function () {
        var el = $(this);(setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide();
      });
    },
    prev: function (selector) {
      return $(this.pluck('previousElementSibling')).filter(selector || '*');
    },
    next: function (selector) {
      return $(this.pluck('nextElementSibling')).filter(selector || '*');
    },
    html: function (html) {
      return 0 in arguments ? this.each(function (idx) {
        var originHtml = this.innerHTML;
        $(this).empty().append(funcArg(this, html, idx, originHtml));
      }) : 0 in this ? this[0].innerHTML : null;
    },
    text: function (text) {
      return 0 in arguments ? this.each(function (idx) {
        var newText = funcArg(this, text, idx, this.textContent);
        this.textContent = newText == null ? '' : '' + newText;
      }) : 0 in this ? this[0].textContent : null;
    },
    attr: function (name, value) {
      var result;
      return typeof name == 'string' && !(1 in arguments) ? !this.length || this[0].nodeType !== 1 ? undefined : !(result = this[0].getAttribute(name)) && name in this[0] ? this[0][name] : result : this.each(function (idx) {
        if (this.nodeType !== 1) return;
        if (isObject(name)) for (key in name) setAttribute(this, key, name[key]);else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)));
      });
    },
    removeAttr: function (name) {
      return this.each(function () {
        this.nodeType === 1 && name.split(' ').forEach(function (attribute) {
          setAttribute(this, attribute);
        }, this);
      });
    },
    prop: function (name, value) {
      name = propMap[name] || name;
      return 1 in arguments ? this.each(function (idx) {
        this[name] = funcArg(this, value, idx, this[name]);
      }) : this[0] && this[0][name];
    },
    data: function (name, value) {
      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase();

      var data = 1 in arguments ? this.attr(attrName, value) : this.attr(attrName);

      return data !== null ? deserializeValue(data) : undefined;
    },
    val: function (value) {
      return 0 in arguments ? this.each(function (idx) {
        this.value = funcArg(this, value, idx, this.value);
      }) : this[0] && (this[0].multiple ? $(this[0]).find('option').filter(function () {
        return this.selected;
      }).pluck('value') : this[0].value);
    },
    offset: function (coordinates) {
      if (coordinates) return this.each(function (index) {
        var $this = $(this),
            coords = funcArg(this, coordinates, index, $this.offset()),
            parentOffset = $this.offsetParent().offset(),
            props = {
          top: coords.top - parentOffset.top,
          left: coords.left - parentOffset.left
        };

        if ($this.css('position') == 'static') props['position'] = 'relative';
        $this.css(props);
      });
      if (!this.length) return null;
      var obj = this[0].getBoundingClientRect();
      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
      };
    },
    css: function (property, value) {
      if (arguments.length < 2) {
        var computedStyle,
            element = this[0];
        if (!element) return;
        computedStyle = getComputedStyle(element, '');
        if (typeof property == 'string') return element.style[camelize(property)] || computedStyle.getPropertyValue(property);else if (isArray(property)) {
          var props = {};
          $.each(property, function (_, prop) {
            props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop);
          });
          return props;
        }
      }

      var css = '';
      if (type(property) == 'string') {
        if (!value && value !== 0) this.each(function () {
          this.style.removeProperty(dasherize(property));
        });else css = dasherize(property) + ":" + maybeAddPx(property, value);
      } else {
        for (key in property) if (!property[key] && property[key] !== 0) this.each(function () {
          this.style.removeProperty(dasherize(key));
        });else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
      }

      return this.each(function () {
        this.style.cssText += ';' + css;
      });
    },
    index: function (element) {
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
    },
    hasClass: function (name) {
      if (!name) return false;
      return emptyArray.some.call(this, function (el) {
        return this.test(className(el));
      }, classRE(name));
    },
    addClass: function (name) {
      if (!name) return this;
      return this.each(function (idx) {
        if (!('className' in this)) return;
        classList = [];
        var cls = className(this),
            newName = funcArg(this, name, idx, cls);
        newName.split(/\s+/g).forEach(function (klass) {
          if (!$(this).hasClass(klass)) classList.push(klass);
        }, this);
        classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "));
      });
    },
    removeClass: function (name) {
      return this.each(function (idx) {
        if (!('className' in this)) return;
        if (name === undefined) return className(this, '');
        classList = className(this);
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function (klass) {
          classList = classList.replace(classRE(klass), " ");
        });
        className(this, classList.trim());
      });
    },
    toggleClass: function (name, when) {
      if (!name) return this;
      return this.each(function (idx) {
        var $this = $(this),
            names = funcArg(this, name, idx, className(this));
        names.split(/\s+/g).forEach(function (klass) {
          (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass);
        });
      });
    },
    scrollTop: function (value) {
      if (!this.length) return;
      var hasScrollTop = 'scrollTop' in this[0];
      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
      return this.each(hasScrollTop ? function () {
        this.scrollTop = value;
      } : function () {
        this.scrollTo(this.scrollX, value);
      });
    },
    scrollLeft: function (value) {
      if (!this.length) return;
      var hasScrollLeft = 'scrollLeft' in this[0];
      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
      return this.each(hasScrollLeft ? function () {
        this.scrollLeft = value;
      } : function () {
        this.scrollTo(value, this.scrollY);
      });
    },
    position: function () {
      if (!this.length) return;

      var elem = this[0],

      // Get *real* offsetParent
      offsetParent = this.offsetParent(),

      // Get correct offsets
      offset = this.offset(),
          parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top -= parseFloat($(elem).css('margin-top')) || 0;
      offset.left -= parseFloat($(elem).css('margin-left')) || 0;

      // Add offsetParent borders
      parentOffset.top += parseFloat($(offsetParent[0]).css('border-top-width')) || 0;
      parentOffset.left += parseFloat($(offsetParent[0]).css('border-left-width')) || 0;

      // Subtract the two offsets
      return {
        top: offset.top - parentOffset.top,
        left: offset.left - parentOffset.left
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var parent = this.offsetParent || document.body;
        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static") parent = parent.offsetParent;
        return parent;
      });
    }
  };

  // for now
  $.fn.detach = $.fn.remove

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function (dimension) {
    var dimensionProperty = dimension.replace(/./, function (m) {
      return m[0].toUpperCase();
    });

    $.fn[dimension] = function (value) {
      var offset,
          el = this[0];
      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] : isDocument(el) ? el.documentElement['scroll' + dimensionProperty] : (offset = this.offset()) && offset[dimension];else return this.each(function (idx) {
        el = $(this);
        el.css(dimension, funcArg(this, value, idx, el[dimension]()));
      });
    };
  });

  function traverseNode(node, fun) {
    fun(node);
    for (var i = 0, len = node.childNodes.length; i < len; i++) traverseNode(node.childNodes[i], fun);
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function (operator, operatorIndex) {
    var inside = operatorIndex % 2; //=> prepend, append

    $.fn[operator] = function () {
      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
      var argType,
          nodes = $.map(arguments, function (arg) {
        argType = type(arg);
        return argType == "object" || argType == "array" || arg == null ? arg : zepto.fragment(arg);
      }),
          parent,
          copyByClone = this.length > 1;
      if (nodes.length < 1) return this;

      return this.each(function (_, target) {
        parent = inside ? target : target.parentNode;

        // convert all methods to a "before" operation
        target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null;

        var parentInDocument = $.contains(document.documentElement, parent);

        nodes.forEach(function (node) {
          if (copyByClone) node = node.cloneNode(true);else if (!parent) return $(node).remove();

          parent.insertBefore(node, target);
          if (parentInDocument) traverseNode(node, function (el) {
            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' && (!el.type || el.type === 'text/javascript') && !el.src) window['eval'].call(window, el.innerHTML);
          });
        });
      });
    };

    // after    => insertAfter
    // prepend  => prependTo
    // before   => insertBefore
    // append   => appendTo
    $.fn[inside ? operator + 'To' : 'insert' + (operatorIndex ? 'Before' : 'After')] = function (html) {
      $(html)[operator](this);
      return this;
    };
  });

  zepto.Z.prototype = $.fn;

  // Export internal API functions in the `$.zepto` namespace
  zepto.uniq = uniq;
  zepto.deserializeValue = deserializeValue;
  $.zepto = zepto;

  return $;
}();(function ($) {
  var _zid = 1,
      undefined,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function (obj) {
    return typeof obj == 'string';
  },
      handlers = {},
      specialEvents = {},
      focusinSupported = 'onfocusin' in window,
      focus = { focus: 'focusin', blur: 'focusout' },
      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' };

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents';

  function zid(element) {
    return element._zid || (element._zid = _zid++);
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event);
    if (event.ns) var matcher = matcherFor(event.ns);
    return (handlers[zid(element)] || []).filter(function (handler) {
      return handler && (!event.e || handler.e == event.e) && (!event.ns || matcher.test(handler.ns)) && (!fn || zid(handler.fn) === zid(fn)) && (!selector || handler.sel == selector);
    });
  }
  function parse(event) {
    var parts = ('' + event).split('.');
    return { e: parts[0], ns: parts.slice(1).sort().join(' ') };
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)');
  }

  function eventCapture(handler, captureSetting) {
    return handler.del && !focusinSupported && handler.e in focus || !!captureSetting;
  }

  function realEvent(type) {
    return hover[type] || focusinSupported && focus[type] || type;
  }

  function add(element, events, fn, data, selector, delegator, capture) {
    var id = zid(element),
        set = handlers[id] || (handlers[id] = []);
    events.split(/\s/).forEach(function (event) {
      if (event == 'ready') return $(document).ready(fn);
      var handler = parse(event);
      handler.fn = fn;
      handler.sel = selector;
      // emulate mouseenter, mouseleave
      if (handler.e in hover) fn = function (e) {
        var related = e.relatedTarget;
        if (!related || related !== this && !$.contains(this, related)) return handler.fn.apply(this, arguments);
      };
      handler.del = delegator;
      var callback = delegator || fn;
      handler.proxy = function (e) {
        e = compatible(e);
        if (e.isImmediatePropagationStopped()) return;
        e.data = data;
        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args));
        if (result === false) e.preventDefault(), e.stopPropagation();
        return result;
      };
      handler.i = set.length;
      set.push(handler);
      if ('addEventListener' in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
    });
  }
  function remove(element, events, fn, selector, capture) {
    var id = zid(element);(events || '').split(/\s/).forEach(function (event) {
      findHandlers(element, event, fn, selector).forEach(function (handler) {
        delete handlers[id][handler.i];
        if ('removeEventListener' in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
      });
    });
  }

  $.event = { add: add, remove: remove };

  $.proxy = function (fn, context) {
    var args = 2 in arguments && slice.call(arguments, 2);
    if (isFunction(fn)) {
      var proxyFn = function () {
        return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
      };
      proxyFn._zid = zid(fn);
      return proxyFn;
    } else if (isString(context)) {
      if (args) {
        args.unshift(fn[context], fn);
        return $.proxy.apply(null, args);
      } else {
        return $.proxy(fn[context], fn);
      }
    } else {
      throw new TypeError("expected function");
    }
  };

  $.fn.bind = function (event, data, callback) {
    return this.on(event, data, callback);
  };
  $.fn.unbind = function (event, callback) {
    return this.off(event, callback);
  };
  $.fn.one = function (event, selector, data, callback) {
    return this.on(event, selector, data, callback, 1);
  };

  var returnTrue = function () {
    return true;
  },
      returnFalse = function () {
    return false;
  },
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,
      eventMethods = {
    preventDefault: 'isDefaultPrevented',
    stopImmediatePropagation: 'isImmediatePropagationStopped',
    stopPropagation: 'isPropagationStopped'
  };

  function compatible(event, source) {
    if (source || !event.isDefaultPrevented) {
      source || (source = event);

      $.each(eventMethods, function (name, predicate) {
        var sourceMethod = source[name];
        event[name] = function () {
          this[predicate] = returnTrue;
          return sourceMethod && sourceMethod.apply(source, arguments);
        };
        event[predicate] = returnFalse;
      });

      if (source.defaultPrevented !== undefined ? source.defaultPrevented : 'returnValue' in source ? source.returnValue === false : source.getPreventDefault && source.getPreventDefault()) event.isDefaultPrevented = returnTrue;
    }
    return event;
  }

  function createProxy(event) {
    var key,
        proxy = { originalEvent: event };
    for (key in event) if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key];

    return compatible(proxy, event);
  }

  $.fn.delegate = function (selector, event, callback) {
    return this.on(event, selector, callback);
  };
  $.fn.undelegate = function (selector, event, callback) {
    return this.off(event, selector, callback);
  };

  $.fn.live = function (event, callback) {
    $(document.body).delegate(this.selector, event, callback);
    return this;
  };
  $.fn.die = function (event, callback) {
    $(document.body).undelegate(this.selector, event, callback);
    return this;
  };

  $.fn.on = function (event, selector, data, callback, one) {
    var autoRemove,
        delegator,
        $this = this;
    if (event && !isString(event)) {
      $.each(event, function (type, fn) {
        $this.on(type, selector, data, fn, one);
      });
      return $this;
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = data, data = selector, selector = undefined;
    if (isFunction(data) || data === false) callback = data, data = undefined;

    if (callback === false) callback = returnFalse;

    return $this.each(function (_, element) {
      if (one) autoRemove = function (e) {
        remove(element, e.type, callback);
        return callback.apply(this, arguments);
      };

      if (selector) delegator = function (e) {
        var evt,
            match = $(e.target).closest(selector, element).get(0);
        if (match && match !== element) {
          evt = $.extend(createProxy(e), { currentTarget: match, liveFired: element });
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)));
        }
      };

      add(element, event, callback, data, selector, delegator || autoRemove);
    });
  };
  $.fn.off = function (event, selector, callback) {
    var $this = this;
    if (event && !isString(event)) {
      $.each(event, function (type, fn) {
        $this.off(type, selector, fn);
      });
      return $this;
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = selector, selector = undefined;

    if (callback === false) callback = returnFalse;

    return $this.each(function () {
      remove(this, event, callback, selector);
    });
  };

  $.fn.trigger = function (event, args) {
    event = isString(event) || $.isPlainObject(event) ? $.Event(event) : compatible(event);
    event._args = args;
    return this.each(function () {
      // handle focus(), blur() by calling them directly
      if (event.type in focus && typeof this[event.type] == "function") this[event.type]();
      // items in the collection might not be DOM elements
      else if ('dispatchEvent' in this) this.dispatchEvent(event);else $(this).triggerHandler(event, args);
    });
  };

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function (event, args) {
    var e, result;
    this.each(function (i, element) {
      e = createProxy(isString(event) ? $.Event(event) : event);
      e._args = args;
      e.target = element;
      $.each(findHandlers(element, event.type || event), function (i, handler) {
        result = handler.proxy(e);
        if (e.isImmediatePropagationStopped()) return false;
      });
    });
    return result;
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout focus blur load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select keydown keypress keyup error').split(' ').forEach(function (event) {
    $.fn[event] = function (callback) {
      return 0 in arguments ? this.bind(event, callback) : this.trigger(event);
    };
  });

  $.Event = function (type, props) {
    if (!isString(type)) props = type, type = props.type;
    var event = document.createEvent(specialEvents[type] || 'Events'),
        bubbles = true;
    if (props) for (var name in props) name == 'bubbles' ? bubbles = !!props[name] : event[name] = props[name];
    event.initEvent(type, bubbles, true);
    return compatible(event);
  };
})(Zepto);(function ($) {
  var jsonpID = 0,
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = 'application/json',
      htmlType = 'text/html',
      blankRE = /^\s*$/,
      originAnchor = document.createElement('a');

  originAnchor.href = window.location.href;

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName);
    $(context).trigger(event, data);
    return !event.isDefaultPrevented();
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) return triggerAndReturn(context || document, eventName, data);
  }

  // Number of active Ajax requests
  $.active = 0;

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart');
  }
  function ajaxStop(settings) {
    if (settings.global && ! --$.active) triggerGlobal(settings, null, 'ajaxStop');
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context;
    if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false) return false;

    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]);
  }
  function ajaxSuccess(data, xhr, settings, deferred) {
    var context = settings.context,
        status = 'success';
    settings.success.call(context, data, status, xhr);
    if (deferred) deferred.resolveWith(context, [data, status, xhr]);
    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]);
    ajaxComplete(status, xhr, settings);
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings, deferred) {
    var context = settings.context;
    settings.error.call(context, xhr, type, error);
    if (deferred) deferred.rejectWith(context, [xhr, type, error]);
    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]);
    ajaxComplete(type, xhr, settings);
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context;
    settings.complete.call(context, xhr, status);
    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]);
    ajaxStop(settings);
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function (options, deferred) {
    if (!('type' in options)) return $.ajax(options);

    var _callbackName = options.jsonpCallback,
        callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || 'jsonp' + ++jsonpID,
        script = document.createElement('script'),
        originalCallback = window[callbackName],
        responseData,
        abort = function (errorType) {
      $(script).triggerHandler('error', errorType || 'abort');
    },
        xhr = { abort: abort },
        abortTimeout;

    if (deferred) deferred.promise(xhr);

    $(script).on('load error', function (e, errorType) {
      clearTimeout(abortTimeout);
      $(script).off().remove();

      if (e.type == 'error' || !responseData) {
        ajaxError(null, errorType || 'error', xhr, options, deferred);
      } else {
        ajaxSuccess(responseData[0], xhr, options, deferred);
      }

      window[callbackName] = originalCallback;
      if (responseData && $.isFunction(originalCallback)) originalCallback(responseData[0]);

      originalCallback = responseData = undefined;
    });

    if (ajaxBeforeSend(xhr, options) === false) {
      abort('abort');
      return xhr;
    }

    window[callbackName] = function () {
      responseData = arguments;
    };

    script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName);
    document.head.appendChild(script);

    if (options.timeout > 0) abortTimeout = setTimeout(function () {
      abort('timeout');
    }, options.timeout);

    return xhr;
  };

  $.ajaxSettings = {
    // Default type of request
    type: 'GET',
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function () {
      return new window.XMLHttpRequest();
    },
    // MIME types mapping
    // IIS returns Javascript as "application/x-javascript"
    accepts: {
      script: 'text/javascript, application/javascript, application/x-javascript',
      json: jsonType,
      xml: 'application/xml, text/xml',
      html: htmlType,
      text: 'text/plain'
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0,
    // Whether data should be serialized to string
    processData: true,
    // Whether the browser should be allowed to cache GET responses
    cache: true
  };

  function mimeToDataType(mime) {
    if (mime) mime = mime.split(';', 2)[0];
    return mime && (mime == htmlType ? 'html' : mime == jsonType ? 'json' : scriptTypeRE.test(mime) ? 'script' : xmlTypeRE.test(mime) && 'xml') || 'text';
  }

  function appendQuery(url, query) {
    if (query == '') return url;
    return (url + '&' + query).replace(/[&?]{1,2}/, '?');
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (options.processData && options.data && $.type(options.data) != "string") options.data = $.param(options.data, options.traditional);
    if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) options.url = appendQuery(options.url, options.data), options.data = undefined;
  }

  $.ajax = function (options) {
    var settings = $.extend({}, options || {}),
        deferred = $.Deferred && $.Deferred(),
        urlAnchor;
    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key];

    ajaxStart(settings);

    if (!settings.crossDomain) {
      urlAnchor = document.createElement('a');
      urlAnchor.href = settings.url;
      urlAnchor.href = urlAnchor.href;
      settings.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
    }

    if (!settings.url) settings.url = window.location.toString();
    serializeData(settings);

    var dataType = settings.dataType,
        hasPlaceholder = /\?.+=\?/.test(settings.url);
    if (hasPlaceholder) dataType = 'jsonp';

    if (settings.cache === false || (!options || options.cache !== true) && ('script' == dataType || 'jsonp' == dataType)) settings.url = appendQuery(settings.url, '_=' + Date.now());

    if ('jsonp' == dataType) {
      if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? settings.jsonp + '=?' : settings.jsonp === false ? '' : 'callback=?');
      return $.ajaxJSONP(settings, deferred);
    }

    var mime = settings.accepts[dataType],
        headers = {},
        setHeader = function (name, value) {
      headers[name.toLowerCase()] = [name, value];
    },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = settings.xhr(),
        nativeSetHeader = xhr.setRequestHeader,
        abortTimeout;

    if (deferred) deferred.promise(xhr);

    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest');
    setHeader('Accept', mime || '*/*');
    if (mime = settings.mimeType || mime) {
      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0];
      xhr.overrideMimeType && xhr.overrideMimeType(mime);
    }
    if (settings.contentType || settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET') setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded');

    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name]);
    xhr.setRequestHeader = setHeader;

    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        xhr.onreadystatechange = empty;
        clearTimeout(abortTimeout);
        var result,
            error = false;
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && protocol == 'file:') {
          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'));
          result = xhr.responseText;

          try {
            // http://perfectionkills.com/global-eval-what-are-the-options/
            if (dataType == 'script') (1, eval)(result);else if (dataType == 'xml') result = xhr.responseXML;else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result);
          } catch (e) {
            error = e;
          }

          if (error) ajaxError(error, 'parsererror', xhr, settings, deferred);else ajaxSuccess(result, xhr, settings, deferred);
        } else {
          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred);
        }
      }
    };

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort();
      ajaxError(null, 'abort', xhr, settings, deferred);
      return xhr;
    }

    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name];

    var async = 'async' in settings ? settings.async : true;
    xhr.open(settings.type, settings.url, async, settings.username, settings.password);

    for (name in headers) nativeSetHeader.apply(xhr, headers[name]);

    if (settings.timeout > 0) abortTimeout = setTimeout(function () {
      xhr.onreadystatechange = empty;
      xhr.abort();
      ajaxError(null, 'timeout', xhr, settings, deferred);
    }, settings.timeout);

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null);
    return xhr;
  };

  // handle optional data/success arguments
  function parseArguments(url, data, success, dataType) {
    if ($.isFunction(data)) dataType = success, success = data, data = undefined;
    if (!$.isFunction(success)) dataType = success, success = undefined;
    return {
      url: url,
      data: data,
      success: success,
      dataType: dataType
    };
  }

  $.get = function () /* url, data, success, dataType */{
    return $.ajax(parseArguments.apply(null, arguments));
  };

  $.post = function () /* url, data, success, dataType */{
    var options = parseArguments.apply(null, arguments);
    options.type = 'POST';
    return $.ajax(options);
  };

  $.getJSON = function () /* url, data, success */{
    var options = parseArguments.apply(null, arguments);
    options.dataType = 'json';
    return $.ajax(options);
  };

  $.fn.load = function (url, data, success) {
    if (!this.length) return this;
    var self = this,
        parts = url.split(/\s/),
        selector,
        options = parseArguments(url, data, success),
        callback = options.success;
    if (parts.length > 1) options.url = parts[0], selector = parts[1];
    options.success = function (response) {
      self.html(selector ? $('<div>').html(response.replace(rscript, "")).find(selector) : response);
      callback && callback.apply(self, arguments);
    };
    $.ajax(options);
    return this;
  };

  var escape = encodeURIComponent;

  function serialize(params, obj, traditional, scope) {
    var type,
        array = $.isArray(obj),
        hash = $.isPlainObject(obj);
    $.each(obj, function (key, value) {
      type = $.type(value);
      if (scope) key = traditional ? scope : scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']';
      // handle data in serializeArray() format
      if (!scope && array) params.add(value.name, value.value);
      // recurse into nested objects
      else if (type == "array" || !traditional && type == "object") serialize(params, value, traditional, key);else params.add(key, value);
    });
  }

  $.param = function (obj, traditional) {
    var params = [];
    params.add = function (key, value) {
      if ($.isFunction(value)) value = value();
      if (value == null) value = "";
      this.push(escape(key) + '=' + escape(value));
    };
    serialize(params, obj, traditional);
    return params.join('&').replace(/%20/g, '+');
  };
})(Zepto);(function ($) {
  $.fn.serializeArray = function () {
    var name,
        type,
        result = [],
        add = function (value) {
      if (value.forEach) return value.forEach(add);
      result.push({ name: name, value: value });
    };
    if (this[0]) $.each(this[0].elements, function (_, field) {
      type = field.type, name = field.name;
      if (name && field.nodeName.toLowerCase() != 'fieldset' && !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' && (type != 'radio' && type != 'checkbox' || field.checked)) add($(field).val());
    });
    return result;
  };

  $.fn.serialize = function () {
    var result = [];
    this.serializeArray().forEach(function (elm) {
      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value));
    });
    return result.join('&');
  };

  $.fn.submit = function (callback) {
    if (0 in arguments) this.bind('submit', callback);else if (this.length) {
      var event = $.Event('submit');
      this.eq(0).trigger(event);
      if (!event.isDefaultPrevented()) this.get(0).submit();
    }
    return this;
  };
})(Zepto);(function ($) {
  // __proto__ doesn't exist on IE<11, so redefine
  // the Z function to use object extension instead
  if (!('__proto__' in {})) {
    $.extend($.zepto, {
      Z: function (dom, selector) {
        dom = dom || [];
        $.extend(dom, $.fn);
        dom.selector = selector || '';
        dom.__Z = true;
        return dom;
      },
      // this is a kludge but works
      isZ: function (object) {
        return $.type(object) === 'array' && '__Z' in object;
      }
    });
  }

  // getComputedStyle shouldn't freak out when called
  // without a valid element as argument
  try {
    getComputedStyle(undefined);
  } catch (e) {
    var nativeGetComputedStyle = getComputedStyle;
    window.getComputedStyle = function (element) {
      try {
        return nativeGetComputedStyle(element);
      } catch (e) {
        return null;
      }
    };
  }
})(Zepto);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(119);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);

	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export WebGLRenderTargetCube */
/* unused harmony export WebGLRenderTarget */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return WebGLRenderer; });
/* unused harmony export ShaderLib */
/* unused harmony export UniformsLib */
/* unused harmony export UniformsUtils */
/* unused harmony export ShaderChunk */
/* unused harmony export FogExp2 */
/* unused harmony export Fog */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Scene; });
/* unused harmony export LensFlare */
/* unused harmony export Sprite */
/* unused harmony export LOD */
/* unused harmony export SkinnedMesh */
/* unused harmony export Skeleton */
/* unused harmony export Bone */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return Mesh; });
/* unused harmony export LineSegments */
/* unused harmony export LineLoop */
/* unused harmony export Line */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return Points; });
/* unused harmony export Group */
/* unused harmony export VideoTexture */
/* unused harmony export DataTexture */
/* unused harmony export CompressedTexture */
/* unused harmony export CubeTexture */
/* unused harmony export CanvasTexture */
/* unused harmony export DepthTexture */
/* unused harmony export Texture */
/* unused harmony export CompressedTextureLoader */
/* unused harmony export DataTextureLoader */
/* unused harmony export CubeTextureLoader */
/* unused harmony export TextureLoader */
/* unused harmony export ObjectLoader */
/* unused harmony export MaterialLoader */
/* unused harmony export BufferGeometryLoader */
/* unused harmony export DefaultLoadingManager */
/* unused harmony export LoadingManager */
/* unused harmony export JSONLoader */
/* unused harmony export ImageLoader */
/* unused harmony export FontLoader */
/* unused harmony export FileLoader */
/* unused harmony export Loader */
/* unused harmony export Cache */
/* unused harmony export AudioLoader */
/* unused harmony export SpotLightShadow */
/* unused harmony export SpotLight */
/* unused harmony export PointLight */
/* unused harmony export RectAreaLight */
/* unused harmony export HemisphereLight */
/* unused harmony export DirectionalLightShadow */
/* unused harmony export DirectionalLight */
/* unused harmony export AmbientLight */
/* unused harmony export LightShadow */
/* unused harmony export Light */
/* unused harmony export StereoCamera */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PerspectiveCamera; });
/* unused harmony export OrthographicCamera */
/* unused harmony export CubeCamera */
/* unused harmony export ArrayCamera */
/* unused harmony export Camera */
/* unused harmony export AudioListener */
/* unused harmony export PositionalAudio */
/* unused harmony export AudioContext */
/* unused harmony export AudioAnalyser */
/* unused harmony export Audio */
/* unused harmony export VectorKeyframeTrack */
/* unused harmony export StringKeyframeTrack */
/* unused harmony export QuaternionKeyframeTrack */
/* unused harmony export NumberKeyframeTrack */
/* unused harmony export ColorKeyframeTrack */
/* unused harmony export BooleanKeyframeTrack */
/* unused harmony export PropertyMixer */
/* unused harmony export PropertyBinding */
/* unused harmony export KeyframeTrack */
/* unused harmony export AnimationUtils */
/* unused harmony export AnimationObjectGroup */
/* unused harmony export AnimationMixer */
/* unused harmony export AnimationClip */
/* unused harmony export Uniform */
/* unused harmony export InstancedBufferGeometry */
/* unused harmony export BufferGeometry */
/* unused harmony export GeometryIdCount */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return Geometry; });
/* unused harmony export InterleavedBufferAttribute */
/* unused harmony export InstancedInterleavedBuffer */
/* unused harmony export InterleavedBuffer */
/* unused harmony export InstancedBufferAttribute */
/* unused harmony export Face3 */
/* unused harmony export Object3D */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Raycaster; });
/* unused harmony export Layers */
/* unused harmony export EventDispatcher */
/* unused harmony export Clock */
/* unused harmony export QuaternionLinearInterpolant */
/* unused harmony export LinearInterpolant */
/* unused harmony export DiscreteInterpolant */
/* unused harmony export CubicInterpolant */
/* unused harmony export Interpolant */
/* unused harmony export Triangle */
/* unused harmony export Math */
/* unused harmony export Spherical */
/* unused harmony export Cylindrical */
/* unused harmony export Plane */
/* unused harmony export Frustum */
/* unused harmony export Sphere */
/* unused harmony export Ray */
/* unused harmony export Matrix4 */
/* unused harmony export Matrix3 */
/* unused harmony export Box3 */
/* unused harmony export Box2 */
/* unused harmony export Line3 */
/* unused harmony export Euler */
/* unused harmony export Vector4 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return Vector2; });
/* unused harmony export Quaternion */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return Color; });
/* unused harmony export MorphBlendMesh */
/* unused harmony export ImmediateRenderObject */
/* unused harmony export VertexNormalsHelper */
/* unused harmony export SpotLightHelper */
/* unused harmony export SkeletonHelper */
/* unused harmony export PointLightHelper */
/* unused harmony export RectAreaLightHelper */
/* unused harmony export HemisphereLightHelper */
/* unused harmony export GridHelper */
/* unused harmony export PolarGridHelper */
/* unused harmony export FaceNormalsHelper */
/* unused harmony export DirectionalLightHelper */
/* unused harmony export CameraHelper */
/* unused harmony export BoxHelper */
/* unused harmony export ArrowHelper */
/* unused harmony export AxisHelper */
/* unused harmony export CatmullRomCurve3 */
/* unused harmony export CubicBezierCurve3 */
/* unused harmony export QuadraticBezierCurve3 */
/* unused harmony export LineCurve3 */
/* unused harmony export ArcCurve */
/* unused harmony export EllipseCurve */
/* unused harmony export SplineCurve */
/* unused harmony export CubicBezierCurve */
/* unused harmony export QuadraticBezierCurve */
/* unused harmony export LineCurve */
/* unused harmony export Shape */
/* unused harmony export Path */
/* unused harmony export ShapePath */
/* unused harmony export Font */
/* unused harmony export CurvePath */
/* unused harmony export Curve */
/* unused harmony export ShapeUtils */
/* unused harmony export SceneUtils */
/* unused harmony export WireframeGeometry */
/* unused harmony export ParametricGeometry */
/* unused harmony export ParametricBufferGeometry */
/* unused harmony export TetrahedronGeometry */
/* unused harmony export TetrahedronBufferGeometry */
/* unused harmony export OctahedronGeometry */
/* unused harmony export OctahedronBufferGeometry */
/* unused harmony export IcosahedronGeometry */
/* unused harmony export IcosahedronBufferGeometry */
/* unused harmony export DodecahedronGeometry */
/* unused harmony export DodecahedronBufferGeometry */
/* unused harmony export PolyhedronGeometry */
/* unused harmony export PolyhedronBufferGeometry */
/* unused harmony export TubeGeometry */
/* unused harmony export TubeBufferGeometry */
/* unused harmony export TorusKnotGeometry */
/* unused harmony export TorusKnotBufferGeometry */
/* unused harmony export TorusGeometry */
/* unused harmony export TorusBufferGeometry */
/* unused harmony export TextGeometry */
/* unused harmony export TextBufferGeometry */
/* unused harmony export SphereGeometry */
/* unused harmony export SphereBufferGeometry */
/* unused harmony export RingGeometry */
/* unused harmony export RingBufferGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return PlaneGeometry; });
/* unused harmony export PlaneBufferGeometry */
/* unused harmony export LatheGeometry */
/* unused harmony export LatheBufferGeometry */
/* unused harmony export ShapeGeometry */
/* unused harmony export ShapeBufferGeometry */
/* unused harmony export ExtrudeGeometry */
/* unused harmony export ExtrudeBufferGeometry */
/* unused harmony export EdgesGeometry */
/* unused harmony export ConeGeometry */
/* unused harmony export ConeBufferGeometry */
/* unused harmony export CylinderGeometry */
/* unused harmony export CylinderBufferGeometry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return CircleGeometry; });
/* unused harmony export CircleBufferGeometry */
/* unused harmony export BoxGeometry */
/* unused harmony export BoxBufferGeometry */
/* unused harmony export ShadowMaterial */
/* unused harmony export SpriteMaterial */
/* unused harmony export RawShaderMaterial */
/* unused harmony export ShaderMaterial */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return PointsMaterial; });
/* unused harmony export MeshPhysicalMaterial */
/* unused harmony export MeshStandardMaterial */
/* unused harmony export MeshPhongMaterial */
/* unused harmony export MeshToonMaterial */
/* unused harmony export MeshNormalMaterial */
/* unused harmony export MeshLambertMaterial */
/* unused harmony export MeshDepthMaterial */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return MeshBasicMaterial; });
/* unused harmony export LineDashedMaterial */
/* unused harmony export LineBasicMaterial */
/* unused harmony export Material */
/* unused harmony export Float64BufferAttribute */
/* unused harmony export Float32BufferAttribute */
/* unused harmony export Uint32BufferAttribute */
/* unused harmony export Int32BufferAttribute */
/* unused harmony export Uint16BufferAttribute */
/* unused harmony export Int16BufferAttribute */
/* unused harmony export Uint8ClampedBufferAttribute */
/* unused harmony export Uint8BufferAttribute */
/* unused harmony export Int8BufferAttribute */
/* unused harmony export BufferAttribute */
/* unused harmony export REVISION */
/* unused harmony export MOUSE */
/* unused harmony export CullFaceNone */
/* unused harmony export CullFaceBack */
/* unused harmony export CullFaceFront */
/* unused harmony export CullFaceFrontBack */
/* unused harmony export FrontFaceDirectionCW */
/* unused harmony export FrontFaceDirectionCCW */
/* unused harmony export BasicShadowMap */
/* unused harmony export PCFShadowMap */
/* unused harmony export PCFSoftShadowMap */
/* unused harmony export FrontSide */
/* unused harmony export BackSide */
/* unused harmony export DoubleSide */
/* unused harmony export FlatShading */
/* unused harmony export SmoothShading */
/* unused harmony export NoColors */
/* unused harmony export FaceColors */
/* unused harmony export VertexColors */
/* unused harmony export NoBlending */
/* unused harmony export NormalBlending */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return AdditiveBlending; });
/* unused harmony export SubtractiveBlending */
/* unused harmony export MultiplyBlending */
/* unused harmony export CustomBlending */
/* unused harmony export AddEquation */
/* unused harmony export SubtractEquation */
/* unused harmony export ReverseSubtractEquation */
/* unused harmony export MinEquation */
/* unused harmony export MaxEquation */
/* unused harmony export ZeroFactor */
/* unused harmony export OneFactor */
/* unused harmony export SrcColorFactor */
/* unused harmony export OneMinusSrcColorFactor */
/* unused harmony export SrcAlphaFactor */
/* unused harmony export OneMinusSrcAlphaFactor */
/* unused harmony export DstAlphaFactor */
/* unused harmony export OneMinusDstAlphaFactor */
/* unused harmony export DstColorFactor */
/* unused harmony export OneMinusDstColorFactor */
/* unused harmony export SrcAlphaSaturateFactor */
/* unused harmony export NeverDepth */
/* unused harmony export AlwaysDepth */
/* unused harmony export LessDepth */
/* unused harmony export LessEqualDepth */
/* unused harmony export EqualDepth */
/* unused harmony export GreaterEqualDepth */
/* unused harmony export GreaterDepth */
/* unused harmony export NotEqualDepth */
/* unused harmony export MultiplyOperation */
/* unused harmony export MixOperation */
/* unused harmony export AddOperation */
/* unused harmony export NoToneMapping */
/* unused harmony export LinearToneMapping */
/* unused harmony export ReinhardToneMapping */
/* unused harmony export Uncharted2ToneMapping */
/* unused harmony export CineonToneMapping */
/* unused harmony export UVMapping */
/* unused harmony export CubeReflectionMapping */
/* unused harmony export CubeRefractionMapping */
/* unused harmony export EquirectangularReflectionMapping */
/* unused harmony export EquirectangularRefractionMapping */
/* unused harmony export SphericalReflectionMapping */
/* unused harmony export CubeUVReflectionMapping */
/* unused harmony export CubeUVRefractionMapping */
/* unused harmony export RepeatWrapping */
/* unused harmony export ClampToEdgeWrapping */
/* unused harmony export MirroredRepeatWrapping */
/* unused harmony export NearestFilter */
/* unused harmony export NearestMipMapNearestFilter */
/* unused harmony export NearestMipMapLinearFilter */
/* unused harmony export LinearFilter */
/* unused harmony export LinearMipMapNearestFilter */
/* unused harmony export LinearMipMapLinearFilter */
/* unused harmony export UnsignedByteType */
/* unused harmony export ByteType */
/* unused harmony export ShortType */
/* unused harmony export UnsignedShortType */
/* unused harmony export IntType */
/* unused harmony export UnsignedIntType */
/* unused harmony export FloatType */
/* unused harmony export HalfFloatType */
/* unused harmony export UnsignedShort4444Type */
/* unused harmony export UnsignedShort5551Type */
/* unused harmony export UnsignedShort565Type */
/* unused harmony export UnsignedInt248Type */
/* unused harmony export AlphaFormat */
/* unused harmony export RGBFormat */
/* unused harmony export RGBAFormat */
/* unused harmony export LuminanceFormat */
/* unused harmony export LuminanceAlphaFormat */
/* unused harmony export RGBEFormat */
/* unused harmony export DepthFormat */
/* unused harmony export DepthStencilFormat */
/* unused harmony export RGB_S3TC_DXT1_Format */
/* unused harmony export RGBA_S3TC_DXT1_Format */
/* unused harmony export RGBA_S3TC_DXT3_Format */
/* unused harmony export RGBA_S3TC_DXT5_Format */
/* unused harmony export RGB_PVRTC_4BPPV1_Format */
/* unused harmony export RGB_PVRTC_2BPPV1_Format */
/* unused harmony export RGBA_PVRTC_4BPPV1_Format */
/* unused harmony export RGBA_PVRTC_2BPPV1_Format */
/* unused harmony export RGB_ETC1_Format */
/* unused harmony export LoopOnce */
/* unused harmony export LoopRepeat */
/* unused harmony export LoopPingPong */
/* unused harmony export InterpolateDiscrete */
/* unused harmony export InterpolateLinear */
/* unused harmony export InterpolateSmooth */
/* unused harmony export ZeroCurvatureEnding */
/* unused harmony export ZeroSlopeEnding */
/* unused harmony export WrapAroundEnding */
/* unused harmony export TrianglesDrawMode */
/* unused harmony export TriangleStripDrawMode */
/* unused harmony export TriangleFanDrawMode */
/* unused harmony export LinearEncoding */
/* unused harmony export sRGBEncoding */
/* unused harmony export GammaEncoding */
/* unused harmony export RGBEEncoding */
/* unused harmony export LogLuvEncoding */
/* unused harmony export RGBM7Encoding */
/* unused harmony export RGBM16Encoding */
/* unused harmony export RGBDEncoding */
/* unused harmony export BasicDepthPacking */
/* unused harmony export RGBADepthPacking */
/* unused harmony export CubeGeometry */
/* unused harmony export Face4 */
/* unused harmony export LineStrip */
/* unused harmony export LinePieces */
/* unused harmony export MeshFaceMaterial */
/* unused harmony export MultiMaterial */
/* unused harmony export PointCloud */
/* unused harmony export Particle */
/* unused harmony export ParticleSystem */
/* unused harmony export PointCloudMaterial */
/* unused harmony export ParticleBasicMaterial */
/* unused harmony export ParticleSystemMaterial */
/* unused harmony export Vertex */
/* unused harmony export DynamicBufferAttribute */
/* unused harmony export Int8Attribute */
/* unused harmony export Uint8Attribute */
/* unused harmony export Uint8ClampedAttribute */
/* unused harmony export Int16Attribute */
/* unused harmony export Uint16Attribute */
/* unused harmony export Int32Attribute */
/* unused harmony export Uint32Attribute */
/* unused harmony export Float32Attribute */
/* unused harmony export Float64Attribute */
/* unused harmony export ClosedSplineCurve3 */
/* unused harmony export SplineCurve3 */
/* unused harmony export Spline */
/* unused harmony export BoundingBoxHelper */
/* unused harmony export EdgesHelper */
/* unused harmony export WireframeHelper */
/* unused harmony export XHRLoader */
/* unused harmony export BinaryTextureLoader */
/* unused harmony export GeometryUtils */
/* unused harmony export ImageUtils */
/* unused harmony export Projector */
/* unused harmony export CanvasRenderer */
// Polyfills
if(Number.EPSILON===undefined){Number.EPSILON=Math.pow(2,-52);}if(Number.isInteger===undefined){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger=function(value){return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;};}//
if(Math.sign===undefined){// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
Math.sign=function(x){return x<0?-1:x>0?1:+x;};}if(Function.prototype.name===undefined){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
Object.defineProperty(Function.prototype,'name',{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];}});}if(Object.assign===undefined){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
(function(){Object.assign=function(target){'use strict';if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(Object.prototype.hasOwnProperty.call(source,nextKey)){output[nextKey]=source[nextKey];}}}}return output;};})();}/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */function EventDispatcher(){}Object.assign(EventDispatcher.prototype,{addEventListener:function(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}},hasEventListener:function(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;},removeEventListener:function(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}},dispatchEvent:function(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;var array=[],i=0;var length=listenerArray.length;for(i=0;i<length;i++){array[i]=listenerArray[i];}for(i=0;i<length;i++){array[i].call(this,event);}}}});var REVISION='85';var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var CullFaceFrontBack=3;var FrontFaceDirectionCW=0;var FrontFaceDirectionCCW=1;var BasicShadowMap=0;var PCFShadowMap=1;var PCFSoftShadowMap=2;var FrontSide=0;var BackSide=1;var DoubleSide=2;var FlatShading=1;var SmoothShading=2;var NoColors=0;var FaceColors=1;var VertexColors=2;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var Uncharted2ToneMapping=3;var CineonToneMapping=4;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var SphericalReflectionMapping=305;var CubeUVReflectionMapping=306;var CubeUVRefractionMapping=307;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipMapNearestFilter=1004;var NearestMipMapLinearFilter=1005;var LinearFilter=1006;var LinearMipMapNearestFilter=1007;var LinearMipMapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedShort565Type=1019;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var RGBEFormat=RGBAFormat;var DepthFormat=1026;var DepthStencilFormat=1027;var RGB_S3TC_DXT1_Format=2001;var RGBA_S3TC_DXT1_Format=2002;var RGBA_S3TC_DXT3_Format=2003;var RGBA_S3TC_DXT5_Format=2004;var RGB_PVRTC_4BPPV1_Format=2100;var RGB_PVRTC_2BPPV1_Format=2101;var RGBA_PVRTC_4BPPV1_Format=2102;var RGBA_PVRTC_2BPPV1_Format=2103;var RGB_ETC1_Format=2151;var LoopOnce=2200;var LoopRepeat=2201;var LoopPingPong=2202;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var TrianglesDrawMode=0;var TriangleStripDrawMode=1;var TriangleFanDrawMode=2;var LinearEncoding=3000;var sRGBEncoding=3001;var GammaEncoding=3007;var RGBEEncoding=3002;var LogLuvEncoding=3003;var RGBM7Encoding=3004;var RGBM16Encoding=3005;var RGBDEncoding=3006;var BasicDepthPacking=3200;var RGBADepthPacking=3201;/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */var _Math={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){// http://www.broofa.com/Tools/Math.uuid.htm
var chars='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');var uuid=new Array(36);var rnd=0,r;return function generateUUID(){for(var i=0;i<36;i++){if(i===8||i===13||i===18||i===23){uuid[i]='-';}else if(i===14){uuid[i]='4';}else{if(rnd<=0x02)rnd=0x2000000+Math.random()*0x1000000|0;r=rnd&0xf;rnd=rnd>>4;uuid[i]=chars[i===19?r&0x3|0x8:r];}}return uuid.join('');};}(),clamp:function(value,min,max){return Math.max(min,Math.min(max,value));},// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
euclideanModulo:function(n,m){return(n%m+m)%m;},// Linear mapping from range <a1, a2> to range <b1, b2>
mapLinear:function(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);},// https://en.wikipedia.org/wiki/Linear_interpolation
lerp:function(x,y,t){return(1-t)*x+t*y;},// http://en.wikipedia.org/wiki/Smoothstep
smoothstep:function(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);},smootherstep:function(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);},// Random integer from <low, high> interval
randInt:function(low,high){return low+Math.floor(Math.random()*(high-low+1));},// Random float from <low, high> interval
randFloat:function(low,high){return low+Math.random()*(high-low);},// Random float from <-range/2, range/2> interval
randFloatSpread:function(range){return range*(0.5-Math.random());},degToRad:function(degrees){return degrees*_Math.DEG2RAD;},radToDeg:function(radians){return radians*_Math.RAD2DEG;},isPowerOfTwo:function(value){return(value&value-1)===0&&value!==0;},nearestPowerOfTwo:function(value){return Math.pow(2,Math.round(Math.log(value)/Math.LN2));},nextPowerOfTwo:function(value){value--;value|=value>>1;value|=value>>2;value|=value>>4;value|=value>>8;value|=value>>16;value++;return value;}};/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */function Vector2(x,y){this.x=x||0;this.y=y||0;}Object.defineProperties(Vector2.prototype,{"width":{get:function(){return this.x;},set:function(value){this.x=value;}},"height":{get:function(){return this.y;},set:function(value){this.y=value;}}});Object.assign(Vector2.prototype,{isVector2:true,set:function(x,y){this.x=x;this.y=y;return this;},setScalar:function(scalar){this.x=scalar;this.y=scalar;return this;},setX:function(x){this.x=x;return this;},setY:function(y){this.y=y;return this;},setComponent:function(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}},clone:function(){return new this.constructor(this.x,this.y);},copy:function(v){this.x=v.x;this.y=v.y;return this;},add:function(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;},addScalar:function(s){this.x+=s;this.y+=s;return this;},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;},addScaledVector:function(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;},sub:function(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;},subScalar:function(s){this.x-=s;this.y-=s;return this;},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;},multiply:function(v){this.x*=v.x;this.y*=v.y;return this;},multiplyScalar:function(scalar){this.x*=scalar;this.y*=scalar;return this;},divide:function(v){this.x/=v.x;this.y/=v.y;return this;},divideScalar:function(scalar){return this.multiplyScalar(1/scalar);},min:function(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;},max:function(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;},clamp:function(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;},clampScalar:function(){var min=new Vector2();var max=new Vector2();return function clampScalar(minVal,maxVal){min.set(minVal,minVal);max.set(maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function(min,max){var length=this.length();return this.multiplyScalar(Math.max(min,Math.min(max,length))/length);},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;},roundToZero:function(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;},negate:function(){this.x=-this.x;this.y=-this.y;return this;},dot:function(v){return this.x*v.x+this.y*v.y;},lengthSq:function(){return this.x*this.x+this.y*this.y;},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y);},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y);},normalize:function(){return this.divideScalar(this.length());},angle:function(){// computes the angle in radians with respect to the positive x-axis
var angle=Math.atan2(this.y,this.x);if(angle<0)angle+=2*Math.PI;return angle;},distanceTo:function(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;},distanceToManhattan:function(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);},setLength:function(length){return this.multiplyScalar(length/this.length());},lerp:function(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;},lerpVectors:function(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function(v){return v.x===this.x&&v.y===this.y;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;return array;},fromBufferAttribute:function(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;},rotateAround:function(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */var textureId=0;function Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){Object.defineProperty(this,'id',{value:textureId++});this.uuid=_Math.generateUUID();this.name='';this.image=image!==undefined?image:Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;this.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;this.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.minFilter=minFilter!==undefined?minFilter:LinearMipMapLinearFilter;this.anisotropy=anisotropy!==undefined?anisotropy:1;this.format=format!==undefined?format:RGBAFormat;this.type=type!==undefined?type:UnsignedByteType;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=encoding!==undefined?encoding:LinearEncoding;this.version=0;this.onUpdate=null;}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Object.defineProperty(Texture.prototype,"needsUpdate",{set:function(value){if(value===true)this.version++;}});Object.assign(Texture.prototype,EventDispatcher.prototype,{constructor:Texture,isTexture:true,clone:function(){return new this.constructor().copy(this);},copy:function(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;},toJSON:function(meta){if(meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}function getDataURL(image){var canvas;if(image.toDataURL!==undefined){canvas=image;}else{canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=image.width;canvas.height=image.height;canvas.getContext('2d').drawImage(image,0,0,image.width,image.height);}if(canvas.width>2048||canvas.height>2048){return canvas.toDataURL('image/jpeg',0.6);}else{return canvas.toDataURL('image/png');}}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],wrap:[this.wrapS,this.wrapT],minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(this.image!==undefined){// TODO: Move to THREE.Image
var image=this.image;if(image.uuid===undefined){image.uuid=_Math.generateUUID();// UGH
}if(meta.images[image.uuid]===undefined){meta.images[image.uuid]={uuid:image.uuid,url:getDataURL(image)};}output.image=image.uuid;}meta.textures[this.uuid]=output;return output;},dispose:function(){this.dispatchEvent({type:'dispose'});},transformUv:function(uv){if(this.mapping!==UVMapping)return;uv.multiply(this.repeat);uv.add(this.offset);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else{uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else{uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}}});/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */function Vector4(x,y,z,w){this.x=x||0;this.y=y||0;this.z=z||0;this.w=w!==undefined?w:1;}Object.assign(Vector4.prototype,{isVector4:true,set:function(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;},setScalar:function(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;},setX:function(x){this.x=x;return this;},setY:function(y){this.y=y;return this;},setZ:function(z){this.z=z;return this;},setW:function(w){this.w=w;return this;},setComponent:function(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w);},copy:function(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;},add:function(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;},addScalar:function(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;},addScaledVector:function(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;},sub:function(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;},subScalar:function(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;},multiplyScalar:function(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;},applyMatrix4:function(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;},divideScalar:function(scalar){return this.multiplyScalar(1/scalar);},setAxisAngleFromQuaternion:function(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else{this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;},setAxisAngleFromRotationMatrix:function(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var angle,x,y,z,// variables for result
epsilon=0.01,// margin to allow for rounding errors
epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
this.set(1,0,0,0);return this;// zero angle, arbitrary axis
}// otherwise this singularity is angle = 180
angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else{x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else{y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else{// m33 is the largest diagonal term so base result on this
if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else{z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;},min:function(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;},max:function(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;},clamp:function(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;},clampScalar:function(){var min=new Vector4();var max=new Vector4();return function clampScalar(minVal,maxVal){min.set(minVal,minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;},roundToZero:function(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;},dot:function(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);},normalize:function(){return this.divideScalar(this.length());},setLength:function(length){return this.multiplyScalar(length/this.length());},lerp:function(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;},lerpVectors:function(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;},fromBufferAttribute:function(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}});/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 *//*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/function WebGLRenderTarget(width,height,options){this.uuid=_Math.generateUUID();this.width=width;this.height=height;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);options=options||{};if(options.minFilter===undefined)options.minFilter=LinearFilter;this.texture=new Texture(undefined,undefined,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;}Object.assign(WebGLRenderTarget.prototype,EventDispatcher.prototype,{isWebGLRenderTarget:true,setSize:function(width,height){if(this.width!==width||this.height!==height){this.width=width;this.height=height;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);},clone:function(){return new this.constructor().copy(this);},copy:function(source){this.width=source.width;this.height=source.height;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
 * @author alteredq / http://alteredqualia.com
 */function WebGLRenderTargetCube(width,height,options){WebGLRenderTarget.call(this,width,height,options);this.activeCubeFace=0;// PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
this.activeMipMapLevel=0;}WebGLRenderTargetCube.prototype=Object.create(WebGLRenderTarget.prototype);WebGLRenderTargetCube.prototype.constructor=WebGLRenderTargetCube;WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube=true;/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */function Quaternion(x,y,z,w){this._x=x||0;this._y=y||0;this._z=z||0;this._w=w!==undefined?w:1;}Object.assign(Quaternion,{slerp:function(qa,qb,qm,t){return qm.copy(qa).slerp(qb,t);},slerpFlat:function(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t,cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
if(sqrSin>Number.EPSILON){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}});Object.defineProperties(Quaternion.prototype,{x:{get:function(){return this._x;},set:function(value){this._x=value;this.onChangeCallback();}},y:{get:function(){return this._y;},set:function(value){this._y=value;this.onChangeCallback();}},z:{get:function(){return this._z;},set:function(value){this._z=value;this.onChangeCallback();}},w:{get:function(){return this._w;},set:function(value){this._w=value;this.onChangeCallback();}}});Object.assign(Quaternion.prototype,{set:function(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this.onChangeCallback();return this;},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w);},copy:function(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this.onChangeCallback();return this;},setFromEuler:function(euler,update){if((euler&&euler.isEuler)===false){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}var x=euler._x,y=euler._y,z=euler._z,order=euler.order;// http://www.mathworks.com/matlabcentral/fileexchange/
// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
//	content/SpinCalc.m
var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);if(order==='XYZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='YXZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='ZXY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='ZYX'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='YZX'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='XZY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}if(update!==false)this.onChangeCallback();return this;},setFromAxisAngle:function(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this.onChangeCallback();return this;},setFromRotationMatrix:function(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33,s;if(trace>0){s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this.onChangeCallback();return this;},setFromUnitVectors:function(){// assumes direction vectors vFrom and vTo are normalized
var v1=new Vector3();var r;var EPS=0.000001;return function setFromUnitVectors(vFrom,vTo){if(v1===undefined)v1=new Vector3();r=vFrom.dot(vTo)+1;if(r<EPS){r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){v1.set(-vFrom.y,vFrom.x,0);}else{v1.set(0,-vFrom.z,vFrom.y);}}else{v1.crossVectors(vFrom,vTo);}this._x=v1.x;this._y=v1.y;this._z=v1.z;this._w=r;return this.normalize();};}(),inverse:function(){return this.conjugate().normalize();},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this;},dot:function(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);},normalize:function(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else{l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this.onChangeCallback();return this;},multiply:function(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);},premultiply:function(q){return this.multiplyQuaternions(q,this);},multiplyQuaternions:function(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this.onChangeCallback();return this;},slerp:function(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else{this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sinHalfTheta=Math.sqrt(1.0-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<0.001){this._w=0.5*(w+this._w);this._x=0.5*(x+this._x);this._y=0.5*(y+this._y);this._z=0.5*(z+this._z);return this;}var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this.onChangeCallback();return this;},equals:function(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;},fromArray:function(array,offset){if(offset===undefined)offset=0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this.onChangeCallback();return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;},onChange:function(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function(){}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */function Vector3(x,y,z){this.x=x||0;this.y=y||0;this.z=z||0;}Object.assign(Vector3.prototype,{isVector3:true,set:function(x,y,z){this.x=x;this.y=y;this.z=z;return this;},setScalar:function(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;},setX:function(x){this.x=x;return this;},setY:function(y){this.y=y;return this;},setZ:function(z){this.z=z;return this;},setComponent:function(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}},clone:function(){return new this.constructor(this.x,this.y,this.z);},copy:function(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;},add:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;},addScalar:function(s){this.x+=s;this.y+=s;this.z+=s;return this;},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;},addScaledVector:function(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;},sub:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;},subScalar:function(s){this.x-=s;this.y-=s;this.z-=s;return this;},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;},multiply:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;},multiplyScalar:function(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;},applyEuler:function(){var quaternion=new Quaternion();return function applyEuler(euler){if((euler&&euler.isEuler)===false){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(quaternion.setFromEuler(euler));};}(),applyAxisAngle:function(){var quaternion=new Quaternion();return function applyAxisAngle(axis,angle){return this.applyQuaternion(quaternion.setFromAxisAngle(axis,angle));};}(),applyMatrix3:function(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;},applyMatrix4:function(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12];this.y=e[1]*x+e[5]*y+e[9]*z+e[13];this.z=e[2]*x+e[6]*y+e[10]*z+e[14];var w=e[3]*x+e[7]*y+e[11]*z+e[15];return this.divideScalar(w);},applyQuaternion:function(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},project:function(){var matrix=new Matrix4();return function project(camera){matrix.multiplyMatrices(camera.projectionMatrix,matrix.getInverse(camera.matrixWorld));return this.applyMatrix4(matrix);};}(),unproject:function(){var matrix=new Matrix4();return function unproject(camera){matrix.multiplyMatrices(camera.matrixWorld,matrix.getInverse(camera.projectionMatrix));return this.applyMatrix4(matrix);};}(),transformDirection:function(m){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();},divide:function(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;},divideScalar:function(scalar){return this.multiplyScalar(1/scalar);},min:function(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;},max:function(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;},clamp:function(min,max){// This function assumes min < max, if this assumption isn't true it will not operate correctly
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;},clampScalar:function(){var min=new Vector3();var max=new Vector3();return function clampScalar(minVal,maxVal){min.set(minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function(min,max){var length=this.length();return this.multiplyScalar(Math.max(min,Math.min(max,length))/length);},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;},roundToZero:function(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},dot:function(v){return this.x*v.x+this.y*v.y+this.z*v.z;},// TODO lengthSquared?
lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z;},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);},normalize:function(){return this.divideScalar(this.length());},setLength:function(length){return this.multiplyScalar(length/this.length());},lerp:function(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;},lerpVectors:function(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},cross:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}var x=this.x,y=this.y,z=this.z;this.x=y*v.z-z*v.y;this.y=z*v.x-x*v.z;this.z=x*v.y-y*v.x;return this;},crossVectors:function(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},projectOnVector:function(vector){var scalar=vector.dot(this)/vector.lengthSq();return this.copy(vector).multiplyScalar(scalar);},projectOnPlane:function(){var v1=new Vector3();return function projectOnPlane(planeNormal){v1.copy(this).projectOnVector(planeNormal);return this.sub(v1);};}(),reflect:function(){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
var v1=new Vector3();return function reflect(normal){return this.sub(v1.copy(normal).multiplyScalar(2*this.dot(normal)));};}(),angleTo:function(v){var theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());// clamp, to handle numerical problems
return Math.acos(_Math.clamp(theta,-1,1));},distanceTo:function(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;},distanceToManhattan:function(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);},setFromSpherical:function(s){var sinPhiRadius=Math.sin(s.phi)*s.radius;this.x=sinPhiRadius*Math.sin(s.theta);this.y=Math.cos(s.phi)*s.radius;this.z=sinPhiRadius*Math.cos(s.theta);return this;},setFromCylindrical:function(c){this.x=c.radius*Math.sin(c.theta);this.y=c.y;this.z=c.radius*Math.cos(c.theta);return this;},setFromMatrixPosition:function(m){return this.setFromMatrixColumn(m,3);},setFromMatrixScale:function(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;},setFromMatrixColumn:function(m,index){return this.fromArray(m.elements,index*4);},equals:function(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;},fromBufferAttribute:function(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */function Matrix4(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}Object.assign(Matrix4.prototype,{isMatrix4:true,set:function(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;},clone:function(){return new Matrix4().fromArray(this.elements);},copy:function(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;},copyPosition:function(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;},extractBasis:function(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;},makeBasis:function(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;},extractRotation:function(){var v1=new Vector3();return function extractRotation(m){var te=this.elements;var me=m.elements;var scaleX=1/v1.setFromMatrixColumn(m,0).length();var scaleY=1/v1.setFromMatrixColumn(m,1).length();var scaleZ=1/v1.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;return this;};}(),makeRotationFromEuler:function(euler){if((euler&&euler.isEuler)===false){console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// last column
te[3]=0;te[7]=0;te[11]=0;// bottom row
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},makeRotationFromQuaternion:function(q){var te=this.elements;var x=q._x,y=q._y,z=q._z,w=q._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;te[0]=1-(yy+zz);te[4]=xy-wz;te[8]=xz+wy;te[1]=xy+wz;te[5]=1-(xx+zz);te[9]=yz-wx;te[2]=xz-wy;te[6]=yz+wx;te[10]=1-(xx+yy);// last column
te[3]=0;te[7]=0;te[11]=0;// bottom row
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},lookAt:function(){var x=new Vector3();var y=new Vector3();var z=new Vector3();return function lookAt(eye,target,up){var te=this.elements;z.subVectors(eye,target);if(z.lengthSq()===0){// eye and target are in the same position
z.z=1;}z.normalize();x.crossVectors(up,z);if(x.lengthSq()===0){// eye and target are in the same vertical
z.z+=0.0001;x.crossVectors(up,z);}x.normalize();y.crossVectors(z,x);te[0]=x.x;te[4]=y.x;te[8]=z.x;te[1]=x.y;te[5]=y.y;te[9]=z.y;te[2]=x.z;te[6]=y.z;te[10]=z.z;return this;};}(),multiply:function(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);},premultiply:function(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;},multiplyScalar:function(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix4(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),determinant:function(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);},transpose:function(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;},setPosition:function(v){var te=this.elements;te[12]=v.x;te[13]=v.y;te[14]=v.z;return this;},getInverse:function(m,throwOnDegenerate){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
var te=this.elements,me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){var msg="THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;},scale:function(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;},getMaxScaleOnAxis:function(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));},makeTranslation:function(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;},makeRotationX:function(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;},makeRotationY:function(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;},makeRotationZ:function(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;},makeRotationAxis:function(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;},makeScale:function(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;},makeShear:function(x,y,z){this.set(1,y,z,0,x,1,z,0,x,y,1,0,0,0,0,1);return this;},compose:function(position,quaternion,scale){this.makeRotationFromQuaternion(quaternion);this.scale(scale);this.setPosition(position);return this;},decompose:function(){var vector=new Vector3();var matrix=new Matrix4();return function decompose(position,quaternion,scale){var te=this.elements;var sx=vector.set(te[0],te[1],te[2]).length();var sy=vector.set(te[4],te[5],te[6]).length();var sz=vector.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
matrix.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;matrix.elements[0]*=invSX;matrix.elements[1]*=invSX;matrix.elements[2]*=invSX;matrix.elements[4]*=invSY;matrix.elements[5]*=invSY;matrix.elements[6]*=invSY;matrix.elements[8]*=invSZ;matrix.elements[9]*=invSZ;matrix.elements[10]*=invSZ;quaternion.setFromRotationMatrix(matrix);scale.x=sx;scale.y=sy;scale.z=sz;return this;};}(),makePerspective:function(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;},makeOrthographic:function(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;},equals:function(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function(array,offset){if(offset===undefined)offset=0;for(var i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}});/**
 * @author alteredq / http://alteredqualia.com/
 */function DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data,width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;}DataTexture.prototype=Object.create(Texture.prototype);DataTexture.prototype.constructor=DataTexture;DataTexture.prototype.isDataTexture=true;/**
 * @author mrdoob / http://mrdoob.com/
 */function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;Texture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}CubeTexture.prototype=Object.create(Texture.prototype);CubeTexture.prototype.constructor=CubeTexture;CubeTexture.prototype.isCubeTexture=true;Object.defineProperty(CubeTexture.prototype,'images',{get:function(){return this.image;},set:function(value){this.image=value;}});/**
 * @author tschw
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */var emptyTexture=new Texture();var emptyCubeTexture=new CubeTexture();// --- Base for inner nodes (including the root) ---
function UniformContainer(){this.seq=[];this.map={};}// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);// Flattening for arrays of vectors and matrices
function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
var n=nBlocks*blockSize,r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}// Texture unit allocation
function allocTexUnits(renderer,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var i=0;i!==n;++i)r[i]=renderer.allocTextureUnit();return r;}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValue1f(gl,v){gl.uniform1f(this.addr,v);}function setValue1i(gl,v){gl.uniform1i(this.addr,v);}// Single float vector (from flat array or THREE.VectorN)
function setValue2fv(gl,v){if(v.x===undefined)gl.uniform2fv(this.addr,v);else gl.uniform2f(this.addr,v.x,v.y);}function setValue3fv(gl,v){if(v.x!==undefined)gl.uniform3f(this.addr,v.x,v.y,v.z);else if(v.r!==undefined)gl.uniform3f(this.addr,v.r,v.g,v.b);else gl.uniform3fv(this.addr,v);}function setValue4fv(gl,v){if(v.x===undefined)gl.uniform4fv(this.addr,v);else gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);}// Single matrix (from flat array or MatrixN)
function setValue2fm(gl,v){gl.uniformMatrix2fv(this.addr,false,v.elements||v);}function setValue3fm(gl,v){if(v.elements===undefined){gl.uniformMatrix3fv(this.addr,false,v);}else{mat3array.set(v.elements);gl.uniformMatrix3fv(this.addr,false,mat3array);}}function setValue4fm(gl,v){if(v.elements===undefined){gl.uniformMatrix4fv(this.addr,false,v);}else{mat4array.set(v.elements);gl.uniformMatrix4fv(this.addr,false,mat4array);}}// Single texture (2D / Cube)
function setValueT1(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTexture2D(v||emptyTexture,unit);}function setValueT6(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTextureCube(v||emptyCubeTexture,unit);}// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValue2iv(gl,v){gl.uniform2iv(this.addr,v);}function setValue3iv(gl,v){gl.uniform3iv(this.addr,v);}function setValue4iv(gl,v){gl.uniform4iv(this.addr,v);}// Helper to pick the right setter for the singular case
function getSingularSetter(type){switch(type){case 0x1406:return setValue1f;// FLOAT
case 0x8b50:return setValue2fv;// _VEC2
case 0x8b51:return setValue3fv;// _VEC3
case 0x8b52:return setValue4fv;// _VEC4
case 0x8b5a:return setValue2fm;// _MAT2
case 0x8b5b:return setValue3fm;// _MAT3
case 0x8b5c:return setValue4fm;// _MAT4
case 0x8b5e:return setValueT1;// SAMPLER_2D
case 0x8b60:return setValueT6;// SAMPLER_CUBE
case 0x1404:case 0x8b56:return setValue1i;// INT, BOOL
case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
}}// Array of scalars
function setValue1fv(gl,v){gl.uniform1fv(this.addr,v);}function setValue1iv(gl,v){gl.uniform1iv(this.addr,v);}// Array of vectors (flat or from THREE classes)
function setValueV2a(gl,v){gl.uniform2fv(this.addr,flatten(v,this.size,2));}function setValueV3a(gl,v){gl.uniform3fv(this.addr,flatten(v,this.size,3));}function setValueV4a(gl,v){gl.uniform4fv(this.addr,flatten(v,this.size,4));}// Array of matrices (flat or from THREE clases)
function setValueM2a(gl,v){gl.uniformMatrix2fv(this.addr,false,flatten(v,this.size,4));}function setValueM3a(gl,v){gl.uniformMatrix3fv(this.addr,false,flatten(v,this.size,9));}function setValueM4a(gl,v){gl.uniformMatrix4fv(this.addr,false,flatten(v,this.size,16));}// Array of textures (2D / Cube)
function setValueT1a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT6a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type){switch(type){case 0x1406:return setValue1fv;// FLOAT
case 0x8b50:return setValueV2a;// _VEC2
case 0x8b51:return setValueV3a;// _VEC3
case 0x8b52:return setValueV4a;// _VEC4
case 0x8b5a:return setValueM2a;// _MAT2
case 0x8b5b:return setValueM3a;// _MAT3
case 0x8b5c:return setValueM4a;// _MAT4
case 0x8b5e:return setValueT1a;// SAMPLER_2D
case 0x8b60:return setValueT6a;// SAMPLER_CUBE
case 0x1404:case 0x8b56:return setValue1iv;// INT, BOOL
case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
}}// --- Uniform Classes ---
function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function StructuredUniform(id){this.id=id;UniformContainer.call(this);// mix-in
}StructuredUniform.prototype.setValue=function(gl,value){// Note: Don't need an extra 'renderer' parameter, since samplers
// are not allowed in structured uniforms.
var seq=this.seq;for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];u.setValue(gl,value[u.id]);}};// --- Top-level ---
// Parser - builds up the property tree from the path strings
var RePathPart=/([\w\d_]+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
RePathPart.lastIndex=0;for(;;){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex,id=match[1],idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else{// step into inner node / create it in case it doesn't exist
var map=container.map,next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
function WebGLUniforms(gl,program,renderer){UniformContainer.call(this);this.renderer=renderer;var n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(var i=0;i<n;++i){var info=gl.getActiveUniform(program,i),path=info.name,addr=gl.getUniformLocation(program,path);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,this.renderer);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
WebGLUniforms.upload=function(gl,seq,values,renderer){for(var i=0,n=seq.length;i!==n;++i){var u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
u.setValue(gl,v.value,renderer);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];if(u.id in values)r.push(u);}return r;};/**
 * @author mrdoob / http://mrdoob.com/
 */var ColorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};function Color(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
return this.set(r);}return this.setRGB(r,g,b);}Object.assign(Color.prototype,{isColor:true,r:1,g:1,b:1,set:function(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;},setScalar:function(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;},setHex:function(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;},setRGB:function(r,g,b){this.r=r;this.g=g;this.b=b;return this;},setHSL:function(){function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}return function setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
h=_Math.euclideanModulo(h,1);s=_Math.clamp(s,0,1);l=_Math.clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else{var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;};}(),setStyle:function(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)){// rgb / hsl
var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[5]);return this;}if(color=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[5]);return this;}break;case'hsl':case'hsla':if(color=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
var h=parseFloat(color[1])/360;var s=parseInt(color[2],10)/100;var l=parseInt(color[3],10)/100;handleAlpha(color[5]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f0-9]+)$/.exec(style)){// hex color
var hex=m[1];var size=hex.length;if(size===3){// #ff0
this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){// color keywords
var hex=ColorKeywords[style];if(hex!==undefined){// red
this.setHex(hex);}else{// unknown color
console.warn('THREE.Color: Unknown color '+style);}}return this;},clone:function(){return new this.constructor(this.r,this.g,this.b);},copy:function(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;},copyGammaToLinear:function(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;},copyLinearToGamma:function(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;},convertGammaToLinear:function(){var r=this.r,g=this.g,b=this.b;this.r=r*r;this.g=g*g;this.b=b*b;return this;},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this;},getHex:function(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;},getHexString:function(){return('000000'+this.getHex().toString(16)).slice(-6);},getHSL:function(optionalTarget){// h,s,l ranges are in 0.0 - 1.0
var hsl=optionalTarget||{h:0,s:0,l:0};var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else{var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}hsl.h=hue;hsl.s=saturation;hsl.l=lightness;return hsl;},getStyle:function(){return'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';},offsetHSL:function(h,s,l){var hsl=this.getHSL();hsl.h+=h;hsl.s+=s;hsl.l+=l;this.setHSL(hsl.h,hsl.s,hsl.l);return this;},add:function(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;},addColors:function(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;},addScalar:function(s){this.r+=s;this.g+=s;this.b+=s;return this;},sub:function(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;},multiply:function(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;},multiplyScalar:function(s){this.r*=s;this.g*=s;this.b*=s;return this;},lerp:function(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;},equals:function(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;},toJSON:function(){return this.getHex();}});/**
 * Uniforms library for shared webgl shaders
 */var UniformsLib={common:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},map:{value:null},offsetRepeat:{value:new Vector4(0,0,1,1)},specularMap:{value:null},alphaMap:{value:null},envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},refractionRatio:{value:0.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},offsetRepeat:{value:new Vector4(0,0,1,1)}}};/**
 * Uniform Utilities
 */var UniformsUtils={merge:function(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var tmp=this.clone(uniforms[u]);for(var p in tmp){merged[p]=tmp[p];}}return merged;},clone:function(uniforms_src){var uniforms_dst={};for(var u in uniforms_src){uniforms_dst[u]={};for(var p in uniforms_src[u]){var parameter_src=uniforms_src[u][p];if(parameter_src&&(parameter_src.isColor||parameter_src.isMatrix3||parameter_src.isMatrix4||parameter_src.isVector2||parameter_src.isVector3||parameter_src.isVector4||parameter_src.isTexture)){uniforms_dst[u][p]=parameter_src.clone();}else if(Array.isArray(parameter_src)){uniforms_dst[u][p]=parameter_src.slice();}else{uniforms_dst[u][p]=parameter_src;}}}return uniforms_dst;}};var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="\nvec3 transformed = vec3( position );\n";var beginnormal_vertex="\nvec3 objectNormal = vec3( normal );\n";var bsdfs="float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";var color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";var color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";var color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";var common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";var defaultnormal_vertex="#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";var encodings_fragment="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";var envmap_fragment="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";var envmap_pars_fragment="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";var envmap_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";var fog_vertex="\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";var gradientmap_pars_fragment="#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";var lights_pars="uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";var lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";var lights_template="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";var logdepthbuf_fragment="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";var map_particle_fragment="#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";var map_particle_pars_fragment="#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";var normal_flip="#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";var normal_fragment="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";var project_vertex="#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";var dithering_fragment="#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";var dithering_pars_fragment="#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";var tonemapping_pars_fragment="#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";var uv_pars_fragment="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";var uv_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";var cube_frag="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";var cube_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";var distanceRGBA_frag="uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";var distanceRGBA_vert="varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";var equirect_frag="uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";var equirect_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphysical_frag="#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshphysical_vert="#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var shadow_frag="uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";var shadow_vert="#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars:lights_pars,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_template:lights_template,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_flip:normal_flip,normal_fragment:normal_fragment,normalmap_pars_fragment:normalmap_pars_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,cube_frag:cube_frag,cube_vert:cube_vert,depth_frag:depth_frag,depth_vert:depth_vert,distanceRGBA_frag:distanceRGBA_frag,distanceRGBA_vert:distanceRGBA_vert,equirect_frag:equirect_frag,equirect_vert:equirect_vert,linedashed_frag:linedashed_frag,linedashed_vert:linedashed_vert,meshbasic_frag:meshbasic_frag,meshbasic_vert:meshbasic_vert,meshlambert_frag:meshlambert_frag,meshlambert_vert:meshlambert_vert,meshphong_frag:meshphong_frag,meshphong_vert:meshphong_vert,meshphysical_frag:meshphysical_frag,meshphysical_vert:meshphysical_vert,normal_frag:normal_frag,normal_vert:normal_vert,points_frag:points_frag,points_vert:points_vert,shadow_frag:shadow_frag,shadow_vert:shadow_vert};/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */var ShaderLib={basic:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},roughness:{value:0.5},metalness:{value:0.5},envMapIntensity:{value:1}// temporary
}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},points:{uniforms:UniformsUtils.merge([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.normal_vert,fragmentShader:ShaderChunk.normal_frag},/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1.0}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */equirect:{uniforms:{tEquirect:{value:null},tFlip:{value:-1}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:{lightPos:{value:new Vector3()}},vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag}};ShaderLib.physical={uniforms:UniformsUtils.merge([ShaderLib.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};/**
 * @author bhouston / http://clara.io
 */function Box2(min,max){this.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);this.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);}Object.assign(Box2.prototype,{set:function(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromPoints:function(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector2();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),clone:function(){return new this.constructor().copy(this);},copy:function(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;},isEmpty:function(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y;},getCenter:function(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.subVectors(this.max,this.min);},expandByPoint:function(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},containsPoint:function(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;},containsBox:function(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;},getParameter:function(point,optionalTarget){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
var result=optionalTarget||new Vector2();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));},intersectsBox:function(box){// using 4 splitting planes to rule out intersections
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;},clampPoint:function(point,optionalTarget){var result=optionalTarget||new Vector2();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector2();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),intersect:function(box){this.min.max(box.min);this.max.min(box.max);return this;},union:function(box){this.min.min(box.min);this.max.max(box.max);return this;},translate:function(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */function LensFlarePlugin(renderer,flares){var gl=renderer.context;var state=renderer.state;var vertexBuffer,elementBuffer;var shader,program,attributes,uniforms;var tempTexture,occlusionTexture;function init(){var vertices=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]);var faces=new Uint16Array([0,1,2,0,2,3]);// buffers
vertexBuffer=gl.createBuffer();elementBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);// textures
tempTexture=gl.createTexture();occlusionTexture=gl.createTexture();state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGB,16,16,0,gl.RGB,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);state.bindTexture(gl.TEXTURE_2D,occlusionTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,16,16,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);shader={vertexShader:["uniform lowp int renderType;","uniform vec3 screenPosition;","uniform vec2 scale;","uniform float rotation;","uniform sampler2D occlusionMap;","attribute vec2 position;","attribute vec2 uv;","varying vec2 vUV;","varying float vVisibility;","void main() {","vUV = uv;","vec2 pos = position;","if ( renderType == 2 ) {","vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );","visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );","visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );","visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );","visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );","visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );","visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );","visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );","visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );","vVisibility =        visibility.r / 9.0;","vVisibility *= 1.0 - visibility.g / 9.0;","vVisibility *=       visibility.b / 9.0;","vVisibility *= 1.0 - visibility.a / 9.0;","pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;","pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;","}","gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );","}"].join("\n"),fragmentShader:["uniform lowp int renderType;","uniform sampler2D map;","uniform float opacity;","uniform vec3 color;","varying vec2 vUV;","varying float vVisibility;","void main() {",// pink square
"if ( renderType == 0 ) {","gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",// restore
"} else if ( renderType == 1 ) {","gl_FragColor = texture2D( map, vUV );",// flare
"} else {","vec4 texture = texture2D( map, vUV );","texture.a *= opacity * vVisibility;","gl_FragColor = texture;","gl_FragColor.rgb *= color;","}","}"].join("\n")};program=createProgram(shader);attributes={vertex:gl.getAttribLocation(program,"position"),uv:gl.getAttribLocation(program,"uv")};uniforms={renderType:gl.getUniformLocation(program,"renderType"),map:gl.getUniformLocation(program,"map"),occlusionMap:gl.getUniformLocation(program,"occlusionMap"),opacity:gl.getUniformLocation(program,"opacity"),color:gl.getUniformLocation(program,"color"),scale:gl.getUniformLocation(program,"scale"),rotation:gl.getUniformLocation(program,"rotation"),screenPosition:gl.getUniformLocation(program,"screenPosition")};}/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */this.render=function(scene,camera,viewport){if(flares.length===0)return;var tempPosition=new Vector3();var invAspect=viewport.w/viewport.z,halfViewportWidth=viewport.z*0.5,halfViewportHeight=viewport.w*0.5;var size=16/viewport.w,scale=new Vector2(size*invAspect,size);var screenPosition=new Vector3(1,1,0),screenPositionPixels=new Vector2(1,1);var validArea=new Box2();validArea.min.set(viewport.x,viewport.y);validArea.max.set(viewport.x+(viewport.z-16),viewport.y+(viewport.w-16));if(program===undefined){init();}gl.useProgram(program);state.initAttributes();state.enableAttribute(attributes.vertex);state.enableAttribute(attributes.uv);state.disableUnusedAttributes();// loop through all lens flares to update their occlusion and positions
// setup gl and common used attribs/uniforms
gl.uniform1i(uniforms.occlusionMap,0);gl.uniform1i(uniforms.map,1);gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.vertexAttribPointer(attributes.vertex,2,gl.FLOAT,false,2*8,0);gl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);state.disable(gl.CULL_FACE);state.buffers.depth.setMask(false);for(var i=0,l=flares.length;i<l;i++){size=16/viewport.w;scale.set(size*invAspect,size);// calc object screen position
var flare=flares[i];tempPosition.set(flare.matrixWorld.elements[12],flare.matrixWorld.elements[13],flare.matrixWorld.elements[14]);tempPosition.applyMatrix4(camera.matrixWorldInverse);tempPosition.applyMatrix4(camera.projectionMatrix);// setup arrays for gl programs
screenPosition.copy(tempPosition);// horizontal and vertical coordinate of the lower left corner of the pixels to copy
screenPositionPixels.x=viewport.x+screenPosition.x*halfViewportWidth+halfViewportWidth-8;screenPositionPixels.y=viewport.y+screenPosition.y*halfViewportHeight+halfViewportHeight-8;// screen cull
if(validArea.containsPoint(screenPositionPixels)===true){// save current RGB to temp texture
state.activeTexture(gl.TEXTURE0);state.bindTexture(gl.TEXTURE_2D,null);state.activeTexture(gl.TEXTURE1);state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGB,screenPositionPixels.x,screenPositionPixels.y,16,16,0);// render pink quad
gl.uniform1i(uniforms.renderType,0);gl.uniform2f(uniforms.scale,scale.x,scale.y);gl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);state.disable(gl.BLEND);state.enable(gl.DEPTH_TEST);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);// copy result to occlusionMap
state.activeTexture(gl.TEXTURE0);state.bindTexture(gl.TEXTURE_2D,occlusionTexture);gl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGBA,screenPositionPixels.x,screenPositionPixels.y,16,16,0);// restore graphics
gl.uniform1i(uniforms.renderType,1);state.disable(gl.DEPTH_TEST);state.activeTexture(gl.TEXTURE1);state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);// update object positions
flare.positionScreen.copy(screenPosition);if(flare.customUpdateCallback){flare.customUpdateCallback(flare);}else{flare.updateLensFlares();}// render flares
gl.uniform1i(uniforms.renderType,2);state.enable(gl.BLEND);for(var j=0,jl=flare.lensFlares.length;j<jl;j++){var sprite=flare.lensFlares[j];if(sprite.opacity>0.001&&sprite.scale>0.001){screenPosition.x=sprite.x;screenPosition.y=sprite.y;screenPosition.z=sprite.z;size=sprite.size*sprite.scale/viewport.w;scale.x=size*invAspect;scale.y=size;gl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);gl.uniform2f(uniforms.scale,scale.x,scale.y);gl.uniform1f(uniforms.rotation,sprite.rotation);gl.uniform1f(uniforms.opacity,sprite.opacity);gl.uniform3f(uniforms.color,sprite.color.r,sprite.color.g,sprite.color.b);state.setBlending(sprite.blending,sprite.blendEquation,sprite.blendSrc,sprite.blendDst);renderer.setTexture2D(sprite.texture,1);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);}}}}// restore gl
state.enable(gl.CULL_FACE);state.enable(gl.DEPTH_TEST);state.buffers.depth.setMask(true);renderer.resetGLState();};function createProgram(shader){var program=gl.createProgram();var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);var vertexShader=gl.createShader(gl.VERTEX_SHADER);var prefix="precision "+renderer.getPrecision()+" float;\n";gl.shaderSource(fragmentShader,prefix+shader.fragmentShader);gl.shaderSource(vertexShader,prefix+shader.vertexShader);gl.compileShader(fragmentShader);gl.compileShader(vertexShader);gl.attachShader(program,fragmentShader);gl.attachShader(program,vertexShader);gl.linkProgram(program);return program;}}/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */function SpritePlugin(renderer,sprites){var gl=renderer.context;var state=renderer.state;var vertexBuffer,elementBuffer;var program,attributes,uniforms;var texture;// decompose matrixWorld
var spritePosition=new Vector3();var spriteRotation=new Quaternion();var spriteScale=new Vector3();function init(){var vertices=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]);var faces=new Uint16Array([0,1,2,0,2,3]);vertexBuffer=gl.createBuffer();elementBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);program=createProgram();attributes={position:gl.getAttribLocation(program,'position'),uv:gl.getAttribLocation(program,'uv')};uniforms={uvOffset:gl.getUniformLocation(program,'uvOffset'),uvScale:gl.getUniformLocation(program,'uvScale'),rotation:gl.getUniformLocation(program,'rotation'),scale:gl.getUniformLocation(program,'scale'),color:gl.getUniformLocation(program,'color'),map:gl.getUniformLocation(program,'map'),opacity:gl.getUniformLocation(program,'opacity'),modelViewMatrix:gl.getUniformLocation(program,'modelViewMatrix'),projectionMatrix:gl.getUniformLocation(program,'projectionMatrix'),fogType:gl.getUniformLocation(program,'fogType'),fogDensity:gl.getUniformLocation(program,'fogDensity'),fogNear:gl.getUniformLocation(program,'fogNear'),fogFar:gl.getUniformLocation(program,'fogFar'),fogColor:gl.getUniformLocation(program,'fogColor'),alphaTest:gl.getUniformLocation(program,'alphaTest')};var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=8;canvas.height=8;var context=canvas.getContext('2d');context.fillStyle='white';context.fillRect(0,0,8,8);texture=new Texture(canvas);texture.needsUpdate=true;}this.render=function(scene,camera){if(sprites.length===0)return;// setup gl
if(program===undefined){init();}gl.useProgram(program);state.initAttributes();state.enableAttribute(attributes.position);state.enableAttribute(attributes.uv);state.disableUnusedAttributes();state.disable(gl.CULL_FACE);state.enable(gl.BLEND);gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.vertexAttribPointer(attributes.position,2,gl.FLOAT,false,2*8,0);gl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.uniformMatrix4fv(uniforms.projectionMatrix,false,camera.projectionMatrix.elements);state.activeTexture(gl.TEXTURE0);gl.uniform1i(uniforms.map,0);var oldFogType=0;var sceneFogType=0;var fog=scene.fog;if(fog){gl.uniform3f(uniforms.fogColor,fog.color.r,fog.color.g,fog.color.b);if(fog.isFog){gl.uniform1f(uniforms.fogNear,fog.near);gl.uniform1f(uniforms.fogFar,fog.far);gl.uniform1i(uniforms.fogType,1);oldFogType=1;sceneFogType=1;}else if(fog.isFogExp2){gl.uniform1f(uniforms.fogDensity,fog.density);gl.uniform1i(uniforms.fogType,2);oldFogType=2;sceneFogType=2;}}else{gl.uniform1i(uniforms.fogType,0);oldFogType=0;sceneFogType=0;}// update positions and sort
for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,sprite.matrixWorld);sprite.z=-sprite.modelViewMatrix.elements[14];}sprites.sort(painterSortStable);// render all sprites
var scale=[];for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];var material=sprite.material;if(material.visible===false)continue;gl.uniform1f(uniforms.alphaTest,material.alphaTest);gl.uniformMatrix4fv(uniforms.modelViewMatrix,false,sprite.modelViewMatrix.elements);sprite.matrixWorld.decompose(spritePosition,spriteRotation,spriteScale);scale[0]=spriteScale.x;scale[1]=spriteScale.y;var fogType=0;if(scene.fog&&material.fog){fogType=sceneFogType;}if(oldFogType!==fogType){gl.uniform1i(uniforms.fogType,fogType);oldFogType=fogType;}if(material.map!==null){gl.uniform2f(uniforms.uvOffset,material.map.offset.x,material.map.offset.y);gl.uniform2f(uniforms.uvScale,material.map.repeat.x,material.map.repeat.y);}else{gl.uniform2f(uniforms.uvOffset,0,0);gl.uniform2f(uniforms.uvScale,1,1);}gl.uniform1f(uniforms.opacity,material.opacity);gl.uniform3f(uniforms.color,material.color.r,material.color.g,material.color.b);gl.uniform1f(uniforms.rotation,material.rotation);gl.uniform2fv(uniforms.scale,scale);state.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst);state.buffers.depth.setTest(material.depthTest);state.buffers.depth.setMask(material.depthWrite);if(material.map){renderer.setTexture2D(material.map,0);}else{renderer.setTexture2D(texture,0);}gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);}// restore gl
state.enable(gl.CULL_FACE);renderer.resetGLState();};function createProgram(){var program=gl.createProgram();var vertexShader=gl.createShader(gl.VERTEX_SHADER);var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(vertexShader,['precision '+renderer.getPrecision()+' float;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform float rotation;','uniform vec2 scale;','uniform vec2 uvOffset;','uniform vec2 uvScale;','attribute vec2 position;','attribute vec2 uv;','varying vec2 vUV;','void main() {','vUV = uvOffset + uv * uvScale;','vec2 alignedPosition = position * scale;','vec2 rotatedPosition;','rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;','rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;','vec4 finalPosition;','finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );','finalPosition.xy += rotatedPosition;','finalPosition = projectionMatrix * finalPosition;','gl_Position = finalPosition;','}'].join('\n'));gl.shaderSource(fragmentShader,['precision '+renderer.getPrecision()+' float;','uniform vec3 color;','uniform sampler2D map;','uniform float opacity;','uniform int fogType;','uniform vec3 fogColor;','uniform float fogDensity;','uniform float fogNear;','uniform float fogFar;','uniform float alphaTest;','varying vec2 vUV;','void main() {','vec4 texture = texture2D( map, vUV );','if ( texture.a < alphaTest ) discard;','gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );','if ( fogType > 0 ) {','float depth = gl_FragCoord.z / gl_FragCoord.w;','float fogFactor = 0.0;','if ( fogType == 1 ) {','fogFactor = smoothstep( fogNear, fogFar, depth );','} else {','const float LOG2 = 1.442695;','fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );','fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );','}','gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );','}','}'].join('\n'));gl.compileShader(vertexShader);gl.compileShader(fragmentShader);gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);gl.linkProgram(program);return program;}function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else{return b.id-a.id;}}}/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */var materialId=0;function Material(){Object.defineProperty(this,'id',{value:materialId++});this.uuid=_Math.generateUUID();this.name='';this.type='Material';this.fog=true;this.lights=true;this.blending=NormalBlending;this.side=FrontSide;this.shading=SmoothShading;// THREE.FlatShading, THREE.SmoothShading
this.vertexColors=NoColors;// THREE.NoColors, THREE.VertexColors, THREE.FaceColors
this.opacity=1;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaTest=0;this.premultipliedAlpha=false;this.overdraw=0;// Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
this.visible=true;this.needsUpdate=true;}Object.assign(Material.prototype,EventDispatcher.prototype,{isMaterial:true,setValues:function(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn("THREE.Material: '"+key+"' parameter is undefined.");continue;}var currentValue=this[key];if(currentValue===undefined){console.warn("THREE."+this.type+": '"+key+"' is not a property of this material.");continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else if(key==='overdraw'){// ensure overdraw is backwards-compatible with legacy boolean type
this[key]=Number(newValue);}else{this[key]=newValue;}}},toJSON:function(meta){var isRoot=meta===undefined;if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearCoat!==undefined)data.clearCoat=this.clearCoat;if(this.clearCoatRoughness!==undefined)data.clearCoatRoughness=this.clearCoatRoughness;if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;data.reflectivity=this.reflectivity;// Scale behind envMap
}if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.size!==undefined)data.size=this.size;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.shading!==SmoothShading)data.shading=this.shading;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors!==NoColors)data.vertexColors=this.vertexColors;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;data.skinning=this.skinning;data.morphTargets=this.morphTargets;data.dithering=this.dithering;// TODO: Copied from Object3D.toJSON
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;},clone:function(){return new this.constructor().copy(this);},copy:function(source){this.name=source.name;this.fog=source.fog;this.lights=source.lights;this.blending=source.blending;this.side=source.side;this.shading=source.shading;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.premultipliedAlpha=source.premultipliedAlpha;this.overdraw=source.overdraw;this.visible=source.visible;this.clipShadows=source.clipShadows;this.clipIntersection=source.clipIntersection;var srcPlanes=source.clippingPlanes,dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var i=0;i!==n;++i)dstPlanes[i]=srcPlanes[i].clone();}this.clippingPlanes=dstPlanes;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function ShaderMaterial(parameters){Material.call(this);this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader='void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';this.fragmentShader='void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
this.lights=false;// set to use scene lights
this.clipping=false;// set to use user-defined clipping planes
this.skinning=false;// set to use skinning attribute streams
this.morphTargets=false;// set to use morph targets
this.morphNormals=false;// set to use morph normals
this.extensions={derivatives:false,// set to use derivatives
fragDepth:false,// set to use fragment depth values
drawBuffers:false,// set to use draw buffers
shaderTextureLOD:false// set to use shader texture LOD
};// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}ShaderMaterial.prototype=Object.create(Material.prototype);ShaderMaterial.prototype.constructor=ShaderMaterial;ShaderMaterial.prototype.isShaderMaterial=true;ShaderMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=UniformsUtils.clone(source.uniforms);this.defines=source.defines;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;this.extensions=source.extensions;return this;};ShaderMaterial.prototype.toJSON=function(meta){var data=Material.prototype.toJSON.call(this,meta);data.uniforms=this.uniforms;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;return data;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */function MeshDepthMaterial(parameters){Material.call(this);this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.setValues(parameters);}MeshDepthMaterial.prototype=Object.create(Material.prototype);MeshDepthMaterial.prototype.constructor=MeshDepthMaterial;MeshDepthMaterial.prototype.isMeshDepthMaterial=true;MeshDepthMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.depthPacking=source.depthPacking;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;};/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */function Box3(min,max){this.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);this.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);}Object.assign(Box3.prototype,{isBox3:true,set:function(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromArray:function(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=array.length;i<l;i+=3){var x=array[i];var y=array[i+1];var z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromBufferAttribute:function(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=attribute.count;i<l;i++){var x=attribute.getX(i);var y=attribute.getY(i);var z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromPoints:function(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector3();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),setFromObject:function(object){this.makeEmpty();return this.expandByObject(object);},clone:function(){return new this.constructor().copy(this);},copy:function(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;},isEmpty:function(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;},getCenter:function(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.subVectors(this.max,this.min);},expandByPoint:function(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},expandByObject:function(){// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
var v1=new Vector3();return function expandByObject(object){var scope=this;object.updateMatrixWorld(true);object.traverse(function(node){var i,l;var geometry=node.geometry;if(geometry!==undefined){if(geometry.isGeometry){var vertices=geometry.vertices;for(i=0,l=vertices.length;i<l;i++){v1.copy(vertices[i]);v1.applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}else if(geometry.isBufferGeometry){var attribute=geometry.attributes.position;if(attribute!==undefined){for(i=0,l=attribute.count;i<l;i++){v1.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}}}});return this;};}(),containsPoint:function(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;},containsBox:function(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;},getParameter:function(point,optionalTarget){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
var result=optionalTarget||new Vector3();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));},intersectsBox:function(box){// using 6 splitting planes to rule out intersections.
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;},intersectsSphere:function(){var closestPoint=new Vector3();return function intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
this.clampPoint(sphere.center,closestPoint);// If that point is inside the sphere, the AABB and sphere intersect.
return closestPoint.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;};}(),intersectsPlane:function(plane){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else{min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else{min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else{min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=plane.constant&&max>=plane.constant;},clampPoint:function(point,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector3();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),getBoundingSphere:function(){var v1=new Vector3();return function getBoundingSphere(optionalTarget){var result=optionalTarget||new Sphere();this.getCenter(result.center);result.radius=this.getSize(v1).length()*0.5;return result;};}(),intersect:function(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
if(this.isEmpty())this.makeEmpty();return this;},union:function(box){this.min.min(box.min);this.max.max(box.max);return this;},applyMatrix4:function(){var points=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];return function applyMatrix4(matrix){// transform of empty box is an empty box.
if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
this.setFromPoints(points);return this;};}(),translate:function(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */function Sphere(center,radius){this.center=center!==undefined?center:new Vector3();this.radius=radius!==undefined?radius:0;}Object.assign(Sphere.prototype,{set:function(center,radius){this.center.copy(center);this.radius=radius;return this;},setFromPoints:function(){var box=new Box3();return function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else{box.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;};}(),clone:function(){return new this.constructor().copy(this);},copy:function(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;},empty:function(){return this.radius<=0;},containsPoint:function(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;},distanceToPoint:function(point){return point.distanceTo(this.center)-this.radius;},intersectsSphere:function(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;},intersectsBox:function(box){return box.intersectsSphere(this);},intersectsPlane:function(plane){// We use the following equation to compute the signed distance from
// the center of the sphere to the plane.
//
// distance = q * n - d
//
// If this distance is greater than the radius of the sphere,
// then there is no intersection.
return Math.abs(this.center.dot(plane.normal)-plane.constant)<=this.radius;},clampPoint:function(point,optionalTarget){var deltaLengthSq=this.center.distanceToSquared(point);var result=optionalTarget||new Vector3();result.copy(point);if(deltaLengthSq>this.radius*this.radius){result.sub(this.center).normalize();result.multiplyScalar(this.radius).add(this.center);}return result;},getBoundingBox:function(optionalTarget){var box=optionalTarget||new Box3();box.set(this.center,this.center);box.expandByScalar(this.radius);return box;},applyMatrix4:function(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;},translate:function(offset){this.center.add(offset);return this;},equals:function(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}});/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */function Matrix3(){this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}Object.assign(Matrix3.prototype,{isMatrix3:true,set:function(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this;},clone:function(){return new this.constructor().fromArray(this.elements);},copy:function(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;},setFromMatrix4:function(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix3(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),multiply:function(m){return this.multiplyMatrices(this,m);},premultiply:function(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;},multiplyScalar:function(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;},determinant:function(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;},getInverse:function(matrix,throwOnDegenerate){if(matrix&&matrix.isMatrix4){console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");}var me=matrix.elements,te=this.elements,n11=me[0],n21=me[1],n31=me[2],n12=me[3],n22=me[4],n32=me[5],n13=me[6],n23=me[7],n33=me[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0){var msg="THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;},transpose:function(){var tmp,m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;},getNormalMatrix:function(matrix4){return this.setFromMatrix4(matrix4).getInverse(this).transpose();},transposeIntoArray:function(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;},equals:function(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function(array,offset){if(offset===undefined)offset=0;for(var i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}});/**
 * @author bhouston / http://clara.io
 */function Plane(normal,constant){this.normal=normal!==undefined?normal:new Vector3(1,0,0);this.constant=constant!==undefined?constant:0;}Object.assign(Plane.prototype,{set:function(normal,constant){this.normal.copy(normal);this.constant=constant;return this;},setComponents:function(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;},setFromNormalAndCoplanarPoint:function(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);// must be this.normal, not normal, as this.normal is normalized
return this;},setFromCoplanarPoints:function(){var v1=new Vector3();var v2=new Vector3();return function setFromCoplanarPoints(a,b,c){var normal=v1.subVectors(c,b).cross(v2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(normal,a);return this;};}(),clone:function(){return new this.constructor().copy(this);},copy:function(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;},normalize:function(){// Note: will lead to a divide by zero if the plane is invalid.
var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;},negate:function(){this.constant*=-1;this.normal.negate();return this;},distanceToPoint:function(point){return this.normal.dot(point)+this.constant;},distanceToSphere:function(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;},projectPoint:function(point,optionalTarget){return this.orthoPoint(point,optionalTarget).sub(point).negate();},orthoPoint:function(point,optionalTarget){var perpendicularMagnitude=this.distanceToPoint(point);var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);},intersectLine:function(){var v1=new Vector3();return function intersectLine(line,optionalTarget){var result=optionalTarget||new Vector3();var direction=line.delta(v1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
if(this.distanceToPoint(line.start)===0){return result.copy(line.start);}// Unsure if this is the correct method to handle this case.
return undefined;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return undefined;}return result.copy(direction).multiplyScalar(t).add(line.start);};}(),intersectsLine:function(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;},intersectsBox:function(box){return box.intersectsPlane(this);},intersectsSphere:function(sphere){return sphere.intersectsPlane(this);},coplanarPoint:function(optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(-this.constant);},applyMatrix4:function(){var v1=new Vector3();var m1=new Matrix3();return function applyMatrix4(matrix,optionalNormalMatrix){var referencePoint=this.coplanarPoint(v1).applyMatrix4(matrix);// transform normal based on theory here:
// http://www.songho.ca/opengl/gl_normaltransform.html
var normalMatrix=optionalNormalMatrix||m1.getNormalMatrix(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();// recalculate constant (like in setFromNormalAndCoplanarPoint)
this.constant=-referencePoint.dot(normal);return this;};}(),translate:function(offset){this.constant=this.constant-offset.dot(this.normal);return this;},equals:function(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */function Frustum(p0,p1,p2,p3,p4,p5){this.planes=[p0!==undefined?p0:new Plane(),p1!==undefined?p1:new Plane(),p2!==undefined?p2:new Plane(),p3!==undefined?p3:new Plane(),p4!==undefined?p4:new Plane(),p5!==undefined?p5:new Plane()];}Object.assign(Frustum.prototype,{set:function(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(frustum){var planes=this.planes;for(var i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;},setFromMatrix:function(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;},intersectsObject:function(){var sphere=new Sphere();return function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSprite:function(){var sphere=new Sphere();return function intersectsSprite(sprite){sphere.center.set(0,0,0);sphere.radius=0.7071067811865476;sphere.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSphere:function(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;},intersectsBox:function(){var p1=new Vector3(),p2=new Vector3();return function intersectsBox(box){var planes=this.planes;for(var i=0;i<6;i++){var plane=planes[i];p1.x=plane.normal.x>0?box.min.x:box.max.x;p2.x=plane.normal.x>0?box.max.x:box.min.x;p1.y=plane.normal.y>0?box.min.y:box.max.y;p2.y=plane.normal.y>0?box.max.y:box.min.y;p1.z=plane.normal.z>0?box.min.z:box.max.z;p2.z=plane.normal.z>0?box.max.z:box.min.z;var d1=plane.distanceToPoint(p1);var d2=plane.distanceToPoint(p2);// if both outside plane, no intersection
if(d1<0&&d2<0){return false;}}return true;};}(),containsPoint:function(point){var planes=this.planes;for(var i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}});/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */function WebGLShadowMap(_renderer,_lights,_objects,capabilities){var _gl=_renderer.context,_state=_renderer.state,_frustum=new Frustum(),_projScreenMatrix=new Matrix4(),_lightShadows=_lights.shadows,_shadowMapSize=new Vector2(),_maxShadowMapSize=new Vector2(capabilities.maxTextureSize,capabilities.maxTextureSize),_lookTarget=new Vector3(),_lightPositionWorld=new Vector3(),_MorphingFlag=1,_SkinningFlag=2,_NumberOfMaterialVariants=(_MorphingFlag|_SkinningFlag)+1,_depthMaterials=new Array(_NumberOfMaterialVariants),_distanceMaterials=new Array(_NumberOfMaterialVariants),_materialCache={};var cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];var cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];var cube2DViewPorts=[new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4()];// init
var depthMaterialTemplate=new MeshDepthMaterial();depthMaterialTemplate.depthPacking=RGBADepthPacking;depthMaterialTemplate.clipping=true;var distanceShader=ShaderLib["distanceRGBA"];var distanceUniforms=UniformsUtils.clone(distanceShader.uniforms);for(var i=0;i!==_NumberOfMaterialVariants;++i){var useMorphing=(i&_MorphingFlag)!==0;var useSkinning=(i&_SkinningFlag)!==0;var depthMaterial=depthMaterialTemplate.clone();depthMaterial.morphTargets=useMorphing;depthMaterial.skinning=useSkinning;_depthMaterials[i]=depthMaterial;var distanceMaterial=new ShaderMaterial({defines:{'USE_SHADOWMAP':''},uniforms:distanceUniforms,vertexShader:distanceShader.vertexShader,fragmentShader:distanceShader.fragmentShader,morphTargets:useMorphing,skinning:useSkinning,clipping:true});_distanceMaterials[i]=distanceMaterial;}//
var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.renderReverseSided=true;this.renderSingleSided=true;this.render=function(scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(_lightShadows.length===0)return;// Set GL state for depth map.
_state.disable(_gl.BLEND);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
var faceCount,isPointLight;for(var i=0,il=_lightShadows.length;i<il;i++){var light=_lightShadows[i];var shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}var shadowCamera=shadow.camera;var shadowMatrix=shadow.matrix;_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld);_shadowMapSize.copy(shadow.mapSize);_shadowMapSize.min(_maxShadowMapSize);if(light&&light.isPointLight){faceCount=6;isPointLight=true;var vpWidth=_shadowMapSize.x;var vpHeight=_shadowMapSize.y;// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
cube2DViewPorts[0].set(vpWidth*2,vpHeight,vpWidth,vpHeight);// negative X
cube2DViewPorts[1].set(0,vpHeight,vpWidth,vpHeight);// positive Z
cube2DViewPorts[2].set(vpWidth*3,vpHeight,vpWidth,vpHeight);// negative Z
cube2DViewPorts[3].set(vpWidth,vpHeight,vpWidth,vpHeight);// positive Y
cube2DViewPorts[4].set(vpWidth*3,0,vpWidth,vpHeight);// negative Y
cube2DViewPorts[5].set(vpWidth,0,vpWidth,vpHeight);_shadowMapSize.x*=4.0;_shadowMapSize.y*=2.0;// for point lights we set the shadow matrix to be a translation-only matrix
// equal to inverse of the light's position
shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);}else{faceCount=1;isPointLight=false;_lookTarget.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget);shadowCamera.updateMatrixWorld();shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);// compute shadow matrix
shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);}if(shadow.map===null){var pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+".shadowMap";shadowCamera.updateProjectionMatrix();}if(shadow.isSpotLightShadow){shadow.update(light);}var shadowMap=shadow.map;_renderer.setRenderTarget(shadowMap);_renderer.clear();// render shadow map for each cube face (if omni-directional) or
// run a single pass if not
for(var face=0;face<faceCount;face++){if(isPointLight){_lookTarget.copy(shadowCamera.position);_lookTarget.add(cubeDirections[face]);shadowCamera.up.copy(cubeUps[face]);shadowCamera.lookAt(_lookTarget);shadowCamera.updateMatrixWorld();shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);var vpDimensions=cube2DViewPorts[face];_state.viewport(vpDimensions);}// update camera matrices and frustum
_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);// set object matrices & frustum culling
renderObject(scene,camera,shadowCamera,isPointLight);}}// Restore GL state.
var clearColor=_renderer.getClearColor();var clearAlpha=_renderer.getClearAlpha();_renderer.setClearColor(clearColor,clearAlpha);scope.needsUpdate=false;};function getDepthMaterial(object,material,isPointLight,lightPositionWorld){var geometry=object.geometry;var result=null;var materialVariants=_depthMaterials;var customMaterial=object.customDepthMaterial;if(isPointLight){materialVariants=_distanceMaterials;customMaterial=object.customDistanceMaterial;}if(!customMaterial){var useMorphing=false;if(material.morphTargets){if(geometry&&geometry.isBufferGeometry){useMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;}else if(geometry&&geometry.isGeometry){useMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;}}if(object.isSkinnedMesh&&material.skinning===false){console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',object);}var useSkinning=object.isSkinnedMesh&&material.skinning;var variantIndex=0;if(useMorphing)variantIndex|=_MorphingFlag;if(useSkinning)variantIndex|=_SkinningFlag;result=materialVariants[variantIndex];}else{result=customMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0){// in this case we need a unique material instance reflecting the
// appropriate state
var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;var side=material.side;if(scope.renderSingleSided&&side==DoubleSide){side=FrontSide;}if(scope.renderReverseSided){if(side===FrontSide)side=BackSide;else if(side===BackSide)side=FrontSide;}result.side=side;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(isPointLight&&result.uniforms.lightPos!==undefined){result.uniforms.lightPos.value.copy(lightPositionWorld);}return result;}function renderObject(object,camera,shadowCamera,isPointLight){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if(object.castShadow&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,groupMaterial,isPointLight,_lightPositionWorld);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var depthMaterial=getDepthMaterial(object,material,isPointLight,_lightPositionWorld);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,isPointLight);}}}/**
 * @author bhouston / http://clara.io
 */function Ray(origin,direction){this.origin=origin!==undefined?origin:new Vector3();this.direction=direction!==undefined?direction:new Vector3();}Object.assign(Ray.prototype,{set:function(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;},at:function(t,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.direction).multiplyScalar(t).add(this.origin);},lookAt:function(v){this.direction.copy(v).sub(this.origin).normalize();return this;},recast:function(){var v1=new Vector3();return function recast(t){this.origin.copy(this.at(t,v1));return this;};}(),closestPointToPoint:function(point,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(point,this.origin);var directionDistance=result.dot(this.direction);if(directionDistance<0){return result.copy(this.origin);}return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);},distanceToPoint:function(point){return Math.sqrt(this.distanceSqToPoint(point));},distanceSqToPoint:function(){var v1=new Vector3();return function distanceSqToPoint(point){var directionDistance=v1.subVectors(point,this.origin).dot(this.direction);// point behind the ray
if(directionDistance<0){return this.origin.distanceToSquared(point);}v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return v1.distanceToSquared(point);};}(),distanceSqToSegment:function(){var segCenter=new Vector3();var segDir=new Vector3();var diff=new Vector3();return function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
segCenter.copy(v0).add(v1).multiplyScalar(0.5);segDir.copy(v1).sub(v0).normalize();diff.copy(this.origin).sub(segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(segDir);var b0=diff.dot(this.direction);var b1=-diff.dot(segDir);var c=diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
// Minimum at interior points of ray and segment.
var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else{// region 1
s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{// region 5
s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{if(s1<=-extDet){// region 4
s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else{// region 2
s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else{// Ray and segment are parallel.
s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);}return sqrDist;};}(),intersectSphere:function(){var v1=new Vector3();return function intersectSphere(sphere,optionalTarget){v1.subVectors(sphere.center,this.origin);var tca=v1.dot(this.direction);var d2=v1.dot(v1)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
// in order to always return an intersect point that is in front of the ray.
if(t0<0)return this.at(t1,optionalTarget);// else t0 is in front of the ray, so return the first collision point scaled by t0
return this.at(t0,optionalTarget);};}(),intersectsSphere:function(sphere){return this.distanceToPoint(sphere.center)<=sphere.radius;},distanceToPlane:function(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
return t>=0?t:null;},intersectPlane:function(plane,optionalTarget){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,optionalTarget);},intersectsPlane:function(plane){// check if the ray lies on the plane first
var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
return false;},intersectBox:function(box,optionalTarget){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else{tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else{tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
// (result of 0 * Infinity). x !== x returns true if x is NaN
if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else{tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,optionalTarget);},intersectsBox:function(){var v=new Vector3();return function intersectsBox(box){return this.intersectBox(box,v)!==null;};}(),intersectTriangle:function(){// Compute the offset origin, edges, and normal.
var diff=new Vector3();var edge1=new Vector3();var edge2=new Vector3();var normal=new Vector3();return function intersectTriangle(a,b,c,backfaceCulling,optionalTarget){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
edge1.subVectors(b,a);edge2.subVectors(c,a);normal.crossVectors(edge1,edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
var DdN=this.direction.dot(normal);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else{return null;}diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(edge2.crossVectors(diff,edge2));// b1 < 0, no intersection
if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(edge1.cross(diff));// b2 < 0, no intersection
if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
var QdN=-sign*diff.dot(normal);// t < 0, no intersection
if(QdN<0){return null;}// Ray intersects triangle.
return this.at(QdN/DdN,optionalTarget);};}(),applyMatrix4:function(matrix4){this.direction.add(this.origin).applyMatrix4(matrix4);this.origin.applyMatrix4(matrix4);this.direction.sub(this.origin);this.direction.normalize();return this;},equals:function(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */function Euler(x,y,z,order){this._x=x||0;this._y=y||0;this._z=z||0;this._order=order||Euler.DefaultOrder;}Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];Euler.DefaultOrder='XYZ';Object.defineProperties(Euler.prototype,{x:{get:function(){return this._x;},set:function(value){this._x=value;this.onChangeCallback();}},y:{get:function(){return this._y;},set:function(value){this._y=value;this.onChangeCallback();}},z:{get:function(){return this._z;},set:function(value){this._z=value;this.onChangeCallback();}},order:{get:function(){return this._order;},set:function(value){this._order=value;this.onChangeCallback();}}});Object.assign(Euler.prototype,{isEuler:true,set:function(x,y,z,order){this._x=x;this._y=y;this._z=z;this._order=order||this._order;this.onChangeCallback();return this;},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order);},copy:function(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this.onChangeCallback();return this;},setFromRotationMatrix:function(m,order,update){var clamp=_Math.clamp;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];order=order||this._order;if(order==='XYZ'){this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.99999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else{this._x=Math.atan2(m32,m22);this._z=0;}}else if(order==='YXZ'){this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.99999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else{this._y=Math.atan2(-m31,m11);this._z=0;}}else if(order==='ZXY'){this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.99999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else{this._y=0;this._z=Math.atan2(m21,m11);}}else if(order==='ZYX'){this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.99999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else{this._x=0;this._z=Math.atan2(-m12,m22);}}else if(order==='YZX'){this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.99999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else{this._x=0;this._y=Math.atan2(m13,m33);}}else if(order==='XZY'){this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.99999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else{this._x=Math.atan2(-m23,m33);this._y=0;}}else{console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);}this._order=order;if(update!==false)this.onChangeCallback();return this;},setFromQuaternion:function(){var matrix=new Matrix4();return function setFromQuaternion(q,order,update){matrix.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(matrix,order,update);};}(),setFromVector3:function(v,order){return this.set(v.x,v.y,v.z,order||this._order);},reorder:function(){// WARNING: this discards revolution information -bhouston
var q=new Quaternion();return function reorder(newOrder){q.setFromEuler(this);return this.setFromQuaternion(q,newOrder);};}(),equals:function(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;},fromArray:function(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this.onChangeCallback();return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;},toVector3:function(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else{return new Vector3(this._x,this._y,this._z);}},onChange:function(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function(){}});/**
 * @author mrdoob / http://mrdoob.com/
 */function Layers(){this.mask=1|0;}Object.assign(Layers.prototype,{set:function(channel){this.mask=1<<channel|0;},enable:function(channel){this.mask|=1<<channel|0;},toggle:function(channel){this.mask^=1<<channel|0;},disable:function(channel){this.mask&=~(1<<channel|0);},test:function(layers){return(this.mask&layers.mask)!==0;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */var object3DId=0;function Object3D(){Object.defineProperty(this,'id',{value:object3DId++});this.uuid=_Math.generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation.onChange(onRotationChange);quaternion.onChange(onQuaternionChange);Object.defineProperties(this,{position:{enumerable:true,value:position},rotation:{enumerable:true,value:rotation},quaternion:{enumerable:true,value:quaternion},scale:{enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.userData={};this.onBeforeRender=function(){};this.onAfterRender=function(){};}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object.assign(Object3D.prototype,EventDispatcher.prototype,{isObject3D:true,applyMatrix:function(matrix){this.matrix.multiplyMatrices(matrix,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);},setRotationFromAxisAngle:function(axis,angle){// assumes axis is normalized
this.quaternion.setFromAxisAngle(axis,angle);},setRotationFromEuler:function(euler){this.quaternion.setFromEuler(euler,true);},setRotationFromMatrix:function(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(m);},setRotationFromQuaternion:function(q){// assumes q is normalized
this.quaternion.copy(q);},rotateOnAxis:function(){// rotate object on axis in object space
// axis is assumed to be normalized
var q1=new Quaternion();return function rotateOnAxis(axis,angle){q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(q1);return this;};}(),rotateX:function(){var v1=new Vector3(1,0,0);return function rotateX(angle){return this.rotateOnAxis(v1,angle);};}(),rotateY:function(){var v1=new Vector3(0,1,0);return function rotateY(angle){return this.rotateOnAxis(v1,angle);};}(),rotateZ:function(){var v1=new Vector3(0,0,1);return function rotateZ(angle){return this.rotateOnAxis(v1,angle);};}(),translateOnAxis:function(){// translate object by distance along axis in object space
// axis is assumed to be normalized
var v1=new Vector3();return function translateOnAxis(axis,distance){v1.copy(axis).applyQuaternion(this.quaternion);this.position.add(v1.multiplyScalar(distance));return this;};}(),translateX:function(){var v1=new Vector3(1,0,0);return function translateX(distance){return this.translateOnAxis(v1,distance);};}(),translateY:function(){var v1=new Vector3(0,1,0);return function translateY(distance){return this.translateOnAxis(v1,distance);};}(),translateZ:function(){var v1=new Vector3(0,0,1);return function translateZ(distance){return this.translateOnAxis(v1,distance);};}(),localToWorld:function(vector){return vector.applyMatrix4(this.matrixWorld);},worldToLocal:function(){var m1=new Matrix4();return function worldToLocal(vector){return vector.applyMatrix4(m1.getInverse(this.matrixWorld));};}(),lookAt:function(){// This routine does not support objects with rotated and/or translated parent(s)
var m1=new Matrix4();return function lookAt(vector){if(this.isCamera){m1.lookAt(this.position,vector,this.up);}else{m1.lookAt(vector,this.position,this.up);}this.quaternion.setFromRotationMatrix(m1);};}(),add:function(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error("THREE.Object3D.add: object can't be added as a child of itself.",object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;object.dispatchEvent({type:'added'});this.children.push(object);}else{console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);}return this;},remove:function(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.remove(arguments[i]);}}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;object.dispatchEvent({type:'removed'});this.children.splice(index,1);}},getObjectById:function(id){return this.getObjectByProperty('id',id);},getObjectByName:function(name){return this.getObjectByProperty('name',name);},getObjectByProperty:function(name,value){if(this[name]===value)return this;for(var i=0,l=this.children.length;i<l;i++){var child=this.children[i];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;},getWorldPosition:function(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);return result.setFromMatrixPosition(this.matrixWorld);},getWorldQuaternion:function(){var position=new Vector3();var scale=new Vector3();return function getWorldQuaternion(optionalTarget){var result=optionalTarget||new Quaternion();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,result,scale);return result;};}(),getWorldRotation:function(){var quaternion=new Quaternion();return function getWorldRotation(optionalTarget){var result=optionalTarget||new Euler();this.getWorldQuaternion(quaternion);return result.setFromQuaternion(quaternion,this.rotation.order,false);};}(),getWorldScale:function(){var position=new Vector3();var quaternion=new Quaternion();return function getWorldScale(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,quaternion,result);return result;};}(),getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,1).applyQuaternion(quaternion);};}(),raycast:function(){},traverse:function(callback){callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverse(callback);}},traverseVisible:function(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}},traverseAncestors:function(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;},updateMatrixWorld:function(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force);}},toJSON:function(meta){// meta is '' when called from JSON.stringify
var isRootObject=meta===undefined||meta==='';var output={};// meta is a hash used to collect geometries, materials.
// not providing it implies that this is the root object
// being serialized.
if(isRootObject){// initialize meta obj
meta={geometries:{},materials:{},textures:{},images:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;object.matrix=this.matrix.toArray();//
function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.geometry!==undefined){object.geometry=serialize(meta.geometries,this.geometry);}if(this.material!==undefined){if(Array.isArray(this.material)){var uuids=[];for(var i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else{object.material=serialize(meta.materials,this.material);}}//
if(this.children.length>0){object.children=[];for(var i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;}output.object=object;return output;// extract data from the cache hash
// remove metadata on each item
// and return as array
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}},clone:function(recursive){return new this.constructor().copy(this,recursive);},copy:function(source,recursive){if(recursive===undefined)recursive=true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(var i=0;i<source.children.length;i++){var child=source.children[i];this.add(child.clone());}}return this;}});/**
 * @author bhouston / http://clara.io
 */function Line3(start,end){this.start=start!==undefined?start:new Vector3();this.end=end!==undefined?end:new Vector3();}Object.assign(Line3.prototype,{set:function(start,end){this.start.copy(start);this.end.copy(end);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(line){this.start.copy(line.start);this.end.copy(line.end);return this;},getCenter:function(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.start,this.end).multiplyScalar(0.5);},delta:function(optionalTarget){var result=optionalTarget||new Vector3();return result.subVectors(this.end,this.start);},distanceSq:function(){return this.start.distanceToSquared(this.end);},distance:function(){return this.start.distanceTo(this.end);},at:function(t,optionalTarget){var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},closestPointToPointParameter:function(){var startP=new Vector3();var startEnd=new Vector3();return function closestPointToPointParameter(point,clampToLine){startP.subVectors(point,this.start);startEnd.subVectors(this.end,this.start);var startEnd2=startEnd.dot(startEnd);var startEnd_startP=startEnd.dot(startP);var t=startEnd_startP/startEnd2;if(clampToLine){t=_Math.clamp(t,0,1);}return t;};}(),closestPointToPoint:function(point,clampToLine,optionalTarget){var t=this.closestPointToPointParameter(point,clampToLine);var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},applyMatrix4:function(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;},equals:function(line){return line.start.equals(this.start)&&line.end.equals(this.end);}});/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */function Triangle(a,b,c){this.a=a!==undefined?a:new Vector3();this.b=b!==undefined?b:new Vector3();this.c=c!==undefined?c:new Vector3();}Object.assign(Triangle,{normal:function(){var v0=new Vector3();return function normal(a,b,c,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(c,b);v0.subVectors(a,b);result.cross(v0);var resultLengthSq=result.lengthSq();if(resultLengthSq>0){return result.multiplyScalar(1/Math.sqrt(resultLengthSq));}return result.set(0,0,0);};}(),// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
barycoordFromPoint:function(){var v0=new Vector3();var v1=new Vector3();var v2=new Vector3();return function barycoordFromPoint(point,a,b,c,optionalTarget){v0.subVectors(c,a);v1.subVectors(b,a);v2.subVectors(point,a);var dot00=v0.dot(v0);var dot01=v0.dot(v1);var dot02=v0.dot(v2);var dot11=v1.dot(v1);var dot12=v1.dot(v2);var denom=dot00*dot11-dot01*dot01;var result=optionalTarget||new Vector3();// collinear or singular triangle
if(denom===0){// arbitrary location outside of triangle?
// not sure if this is the best idea, maybe should be returning undefined
return result.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
return result.set(1-u-v,v,u);};}(),containsPoint:function(){var v1=new Vector3();return function containsPoint(point,a,b,c){var result=Triangle.barycoordFromPoint(point,a,b,c,v1);return result.x>=0&&result.y>=0&&result.x+result.y<=1;};}()});Object.assign(Triangle.prototype,{set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;},setFromPointsAndIndices:function(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;},area:function(){var v0=new Vector3();var v1=new Vector3();return function area(){v0.subVectors(this.c,this.b);v1.subVectors(this.a,this.b);return v0.cross(v1).length()*0.5;};}(),midpoint:function(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);},normal:function(optionalTarget){return Triangle.normal(this.a,this.b,this.c,optionalTarget);},plane:function(optionalTarget){var result=optionalTarget||new Plane();return result.setFromCoplanarPoints(this.a,this.b,this.c);},barycoordFromPoint:function(point,optionalTarget){return Triangle.barycoordFromPoint(point,this.a,this.b,this.c,optionalTarget);},containsPoint:function(point){return Triangle.containsPoint(point,this.a,this.b,this.c);},closestPointToPoint:function(){var plane=new Plane();var edgeList=[new Line3(),new Line3(),new Line3()];var projectedPoint=new Vector3();var closestPoint=new Vector3();return function closestPointToPoint(point,optionalTarget){var result=optionalTarget||new Vector3();var minDistance=Infinity;// project the point onto the plane of the triangle
plane.setFromCoplanarPoints(this.a,this.b,this.c);plane.projectPoint(point,projectedPoint);// check if the projection lies within the triangle
if(this.containsPoint(projectedPoint)===true){// if so, this is the closest point
result.copy(projectedPoint);}else{// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
edgeList[0].set(this.a,this.b);edgeList[1].set(this.b,this.c);edgeList[2].set(this.c,this.a);for(var i=0;i<edgeList.length;i++){edgeList[i].closestPointToPoint(projectedPoint,true,closestPoint);var distance=projectedPoint.distanceToSquared(closestPoint);if(distance<minDistance){minDistance=distance;result.copy(closestPoint);}}}return result;};}(),equals:function(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function Face3(a,b,c,normal,color,materialIndex){this.a=a;this.b=b;this.c=c;this.normal=normal&&normal.isVector3?normal:new Vector3();this.vertexNormals=Array.isArray(normal)?normal:[];this.color=color&&color.isColor?color:new Color();this.vertexColors=Array.isArray(color)?color:[];this.materialIndex=materialIndex!==undefined?materialIndex:0;}Object.assign(Face3.prototype,{clone:function(){return new this.constructor().copy(this);},copy:function(source){this.a=source.a;this.b=source.b;this.c=source.c;this.normal.copy(source.normal);this.color.copy(source.color);this.materialIndex=source.materialIndex;for(var i=0,il=source.vertexNormals.length;i<il;i++){this.vertexNormals[i]=source.vertexNormals[i].clone();}for(var i=0,il=source.vertexColors.length;i<il;i++){this.vertexColors[i]=source.vertexColors[i].clone();}return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */function MeshBasicMaterial(parameters){Material.call(this);this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.lights=false;this.setValues(parameters);}MeshBasicMaterial.prototype=Object.create(Material.prototype);MeshBasicMaterial.prototype.constructor=MeshBasicMaterial;MeshBasicMaterial.prototype.isMeshBasicMaterial=true;MeshBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 */function BufferAttribute(array,itemSize,normalized){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.uuid=_Math.generateUUID();this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.dynamic=false;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0;}Object.defineProperty(BufferAttribute.prototype,'needsUpdate',{set:function(value){if(value===true)this.version++;}});Object.assign(BufferAttribute.prototype,{isBufferAttribute:true,setArray:function(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.itemSize:0;this.array=array;},setDynamic:function(value){this.dynamic=value;return this;},copy:function(source){this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.dynamic=source.dynamic;return this;},copyAt:function(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},copyArray:function(array){this.array.set(array);return this;},copyColorsArray:function(colors){var array=this.array,offset=0;for(var i=0,l=colors.length;i<l;i++){var color=colors[i];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;},copyIndicesArray:function(indices){var array=this.array,offset=0;for(var i=0,l=indices.length;i<l;i++){var index=indices[i];array[offset++]=index.a;array[offset++]=index.b;array[offset++]=index.c;}return this;},copyVector2sArray:function(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;},copyVector3sArray:function(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;},copyVector4sArray:function(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;},set:function(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},getX:function(index){return this.array[index*this.itemSize];},setX:function(index,x){this.array[index*this.itemSize]=x;return this;},getY:function(index){return this.array[index*this.itemSize+1];},setY:function(index,y){this.array[index*this.itemSize+1]=y;return this;},getZ:function(index){return this.array[index*this.itemSize+2];},setZ:function(index,z){this.array[index*this.itemSize+2]=z;return this;},getW:function(index){return this.array[index*this.itemSize+3];},setW:function(index,w){this.array[index*this.itemSize+3]=w;return this;},setXY:function(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;},setXYZ:function(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;},setXYZW:function(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;},onUpload:function(callback){this.onUploadCallback=callback;return this;},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this);}});//
function Int8BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int8Array(array),itemSize);}Int8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int8BufferAttribute.prototype.constructor=Int8BufferAttribute;function Uint8BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint8Array(array),itemSize);}Uint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;function Uint8ClampedBufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint8ClampedArray(array),itemSize);}Uint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;function Int16BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int16Array(array),itemSize);}Int16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int16BufferAttribute.prototype.constructor=Int16BufferAttribute;function Uint16BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint16Array(array),itemSize);}Uint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;function Int32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Int32Array(array),itemSize);}Int32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int32BufferAttribute.prototype.constructor=Int32BufferAttribute;function Uint32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Uint32Array(array),itemSize);}Uint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;function Float32BufferAttribute(array,itemSize){BufferAttribute.call(this,new Float32Array(array),itemSize);}Float32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float32BufferAttribute.prototype.constructor=Float32BufferAttribute;function Float64BufferAttribute(array,itemSize){BufferAttribute.call(this,new Float64Array(array),itemSize);}Float64BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;/**
 * @author mrdoob / http://mrdoob.com/
 */function DirectGeometry(){this.indices=[];this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];// this.lineDistances = [];
this.boundingBox=null;this.boundingSphere=null;// update flags
this.verticesNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.uvsNeedUpdate=false;this.groupsNeedUpdate=false;}Object.assign(DirectGeometry.prototype,{computeGroups:function(geometry){var group;var groups=[];var materialIndex=undefined;var faces=geometry.faces;for(var i=0;i<faces.length;i++){var face=faces[i];// materials
if(face.materialIndex!==materialIndex){materialIndex=face.materialIndex;if(group!==undefined){group.count=i*3-group.start;groups.push(group);}group={start:i*3,materialIndex:materialIndex};}}if(group!==undefined){group.count=i*3-group.start;groups.push(group);}this.groups=groups;},fromGeometry:function(geometry){var faces=geometry.faces;var vertices=geometry.vertices;var faceVertexUvs=geometry.faceVertexUvs;var hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;var hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;// morphs
var morphTargets=geometry.morphTargets;var morphTargetsLength=morphTargets.length;var morphTargetsPosition;if(morphTargetsLength>0){morphTargetsPosition=[];for(var i=0;i<morphTargetsLength;i++){morphTargetsPosition[i]=[];}this.morphTargets.position=morphTargetsPosition;}var morphNormals=geometry.morphNormals;var morphNormalsLength=morphNormals.length;var morphTargetsNormal;if(morphNormalsLength>0){morphTargetsNormal=[];for(var i=0;i<morphNormalsLength;i++){morphTargetsNormal[i]=[];}this.morphTargets.normal=morphTargetsNormal;}// skins
var skinIndices=geometry.skinIndices;var skinWeights=geometry.skinWeights;var hasSkinIndices=skinIndices.length===vertices.length;var hasSkinWeights=skinWeights.length===vertices.length;//
for(var i=0;i<faces.length;i++){var face=faces[i];this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);}else{var normal=face.normal;this.normals.push(normal,normal,normal);}var vertexColors=face.vertexColors;if(vertexColors.length===3){this.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);}else{var color=face.color;this.colors.push(color,color,color);}if(hasFaceVertexUv===true){var vertexUvs=faceVertexUvs[0][i];if(vertexUvs!==undefined){this.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);this.uvs.push(new Vector2(),new Vector2(),new Vector2());}}if(hasFaceVertexUv2===true){var vertexUvs=faceVertexUvs[1][i];if(vertexUvs!==undefined){this.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);this.uvs2.push(new Vector2(),new Vector2(),new Vector2());}}// morphs
for(var j=0;j<morphTargetsLength;j++){var morphTarget=morphTargets[j].vertices;morphTargetsPosition[j].push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);}for(var j=0;j<morphNormalsLength;j++){var morphNormal=morphNormals[j].vertexNormals[i];morphTargetsNormal[j].push(morphNormal.a,morphNormal.b,morphNormal.c);}// skins
if(hasSkinIndices){this.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);}if(hasSkinWeights){this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);}}this.computeGroups(geometry);this.verticesNeedUpdate=geometry.verticesNeedUpdate;this.normalsNeedUpdate=geometry.normalsNeedUpdate;this.colorsNeedUpdate=geometry.colorsNeedUpdate;this.uvsNeedUpdate=geometry.uvsNeedUpdate;this.groupsNeedUpdate=geometry.groupsNeedUpdate;return this;}});function arrayMax(array){if(array.length===0)return-Infinity;var max=array[0];for(var i=1,l=array.length;i<l;++i){if(array[i]>max)max=array[i];}return max;}/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */var count=0;function GeometryIdCount(){return count++;}function Geometry(){Object.defineProperty(this,'id',{value:GeometryIdCount()});this.uuid=_Math.generateUUID();this.name='';this.type='Geometry';this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// update flags
this.elementsNeedUpdate=false;this.verticesNeedUpdate=false;this.uvsNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.lineDistancesNeedUpdate=false;this.groupsNeedUpdate=false;}Object.assign(Geometry.prototype,EventDispatcher.prototype,{isGeometry:true,applyMatrix:function(matrix){var normalMatrix=new Matrix3().getNormalMatrix(matrix);for(var i=0,il=this.vertices.length;i<il;i++){var vertex=this.vertices[i];vertex.applyMatrix4(matrix);}for(var i=0,il=this.faces.length;i<il;i++){var face=this.faces[i];face.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=face.vertexNormals.length;j<jl;j++){face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();}}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}this.verticesNeedUpdate=true;this.normalsNeedUpdate=true;return this;},rotateX:function(){// rotate geometry around world x-axis
var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),fromBufferGeometry:function(geometry){var scope=this;var indices=geometry.index!==null?geometry.index.array:undefined;var attributes=geometry.attributes;var positions=attributes.position.array;var normals=attributes.normal!==undefined?attributes.normal.array:undefined;var colors=attributes.color!==undefined?attributes.color.array:undefined;var uvs=attributes.uv!==undefined?attributes.uv.array:undefined;var uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;if(uvs2!==undefined)this.faceVertexUvs[1]=[];var tempNormals=[];var tempUVs=[];var tempUVs2=[];for(var i=0,j=0;i<positions.length;i+=3,j+=2){scope.vertices.push(new Vector3(positions[i],positions[i+1],positions[i+2]));if(normals!==undefined){tempNormals.push(new Vector3(normals[i],normals[i+1],normals[i+2]));}if(colors!==undefined){scope.colors.push(new Color(colors[i],colors[i+1],colors[i+2]));}if(uvs!==undefined){tempUVs.push(new Vector2(uvs[j],uvs[j+1]));}if(uvs2!==undefined){tempUVs2.push(new Vector2(uvs2[j],uvs2[j+1]));}}function addFace(a,b,c,materialIndex){var vertexNormals=normals!==undefined?[tempNormals[a].clone(),tempNormals[b].clone(),tempNormals[c].clone()]:[];var vertexColors=colors!==undefined?[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()]:[];var face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);scope.faces.push(face);if(uvs!==undefined){scope.faceVertexUvs[0].push([tempUVs[a].clone(),tempUVs[b].clone(),tempUVs[c].clone()]);}if(uvs2!==undefined){scope.faceVertexUvs[1].push([tempUVs2[a].clone(),tempUVs2[b].clone(),tempUVs2[c].clone()]);}}var groups=geometry.groups;if(groups.length>0){for(var i=0;i<groups.length;i++){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){if(indices!==undefined){addFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);}else{addFace(j,j+1,j+2,group.materialIndex);}}}}else{if(indices!==undefined){for(var i=0;i<indices.length;i+=3){addFace(indices[i],indices[i+1],indices[i+2]);}}else{for(var i=0;i<positions.length/3;i+=3){addFace(i,i+1,i+2);}}}this.computeFaceNormals();if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}return this;},center:function(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},normalize:function(){this.computeBoundingSphere();var center=this.boundingSphere.center;var radius=this.boundingSphere.radius;var s=radius===0?1:1.0/radius;var matrix=new Matrix4();matrix.set(s,0,0,-s*center.x,0,s,0,-s*center.y,0,0,s,-s*center.z,0,0,0,1);this.applyMatrix(matrix);return this;},computeFaceNormals:function(){var cb=new Vector3(),ab=new Vector3();for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f];var vA=this.vertices[face.a];var vB=this.vertices[face.b];var vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb);}},computeVertexNormals:function(areaWeighted){if(areaWeighted===undefined)areaWeighted=true;var v,vl,f,fl,face,vertices;vertices=new Array(this.vertices.length);for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v]=new Vector3();}if(areaWeighted){// vertex normals weighted by triangle areas
// http://www.iquilezles.org/www/articles/normals/normals.htm
var vA,vB,vC;var cb=new Vector3(),ab=new Vector3();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vA=this.vertices[face.a];vB=this.vertices[face.b];vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);vertices[face.a].add(cb);vertices[face.b].add(cb);vertices[face.c].add(cb);}}else{this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vertices[face.a].add(face.normal);vertices[face.b].add(face.normal);vertices[face.c].add(face.normal);}}for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v].normalize();}for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(vertices[face.a]);vertexNormals[1].copy(vertices[face.b]);vertexNormals[2].copy(vertices[face.c]);}else{vertexNormals[0]=vertices[face.a].clone();vertexNormals[1]=vertices[face.b].clone();vertexNormals[2]=vertices[face.c].clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeFlatVertexNormals:function(){var f,fl,face;this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(face.normal);vertexNormals[1].copy(face.normal);vertexNormals[2].copy(face.normal);}else{vertexNormals[0]=face.normal.clone();vertexNormals[1]=face.normal.clone();vertexNormals[2]=face.normal.clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeMorphNormals:function(){var i,il,f,fl,face;// save original normals
// - create temp variables on first access
//   otherwise just copy (for faster repeated calls)
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];if(!face.__originalFaceNormal){face.__originalFaceNormal=face.normal.clone();}else{face.__originalFaceNormal.copy(face.normal);}if(!face.__originalVertexNormals)face.__originalVertexNormals=[];for(i=0,il=face.vertexNormals.length;i<il;i++){if(!face.__originalVertexNormals[i]){face.__originalVertexNormals[i]=face.vertexNormals[i].clone();}else{face.__originalVertexNormals[i].copy(face.vertexNormals[i]);}}}// use temp geometry to compute face and vertex normals for each morph
var tmpGeo=new Geometry();tmpGeo.faces=this.faces;for(i=0,il=this.morphTargets.length;i<il;i++){// create on first access
if(!this.morphNormals[i]){this.morphNormals[i]={};this.morphNormals[i].faceNormals=[];this.morphNormals[i].vertexNormals=[];var dstNormalsFace=this.morphNormals[i].faceNormals;var dstNormalsVertex=this.morphNormals[i].vertexNormals;var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){faceNormal=new Vector3();vertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};dstNormalsFace.push(faceNormal);dstNormalsVertex.push(vertexNormals);}}var morphNormals=this.morphNormals[i];// set vertices to morph target
tmpGeo.vertices=this.morphTargets[i].vertices;// compute morph normals
tmpGeo.computeFaceNormals();tmpGeo.computeVertexNormals();// store morph normals
var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];faceNormal=morphNormals.faceNormals[f];vertexNormals=morphNormals.vertexNormals[f];faceNormal.copy(face.normal);vertexNormals.a.copy(face.vertexNormals[0]);vertexNormals.b.copy(face.vertexNormals[1]);vertexNormals.c.copy(face.vertexNormals[2]);}}// restore original normals
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];face.normal=face.__originalFaceNormal;face.vertexNormals=face.__originalVertexNormals;}},computeLineDistances:function(){var d=0;var vertices=this.vertices;for(var i=0,il=vertices.length;i<il;i++){if(i>0){d+=vertices[i].distanceTo(vertices[i-1]);}this.lineDistances[i]=d;}},computeBoundingBox:function(){if(this.boundingBox===null){this.boundingBox=new Box3();}this.boundingBox.setFromPoints(this.vertices);},computeBoundingSphere:function(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}this.boundingSphere.setFromPoints(this.vertices);},merge:function(geometry,matrix,materialIndexOffset){if((geometry&&geometry.isGeometry)===false){console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);return;}var normalMatrix,vertexOffset=this.vertices.length,vertices1=this.vertices,vertices2=geometry.vertices,faces1=this.faces,faces2=geometry.faces,uvs1=this.faceVertexUvs[0],uvs2=geometry.faceVertexUvs[0],colors1=this.colors,colors2=geometry.colors;if(materialIndexOffset===undefined)materialIndexOffset=0;if(matrix!==undefined){normalMatrix=new Matrix3().getNormalMatrix(matrix);}// vertices
for(var i=0,il=vertices2.length;i<il;i++){var vertex=vertices2[i];var vertexCopy=vertex.clone();if(matrix!==undefined)vertexCopy.applyMatrix4(matrix);vertices1.push(vertexCopy);}// colors
for(var i=0,il=colors2.length;i<il;i++){colors1.push(colors2[i].clone());}// faces
for(i=0,il=faces2.length;i<il;i++){var face=faces2[i],faceCopy,normal,color,faceVertexNormals=face.vertexNormals,faceVertexColors=face.vertexColors;faceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);faceCopy.normal.copy(face.normal);if(normalMatrix!==undefined){faceCopy.normal.applyMatrix3(normalMatrix).normalize();}for(var j=0,jl=faceVertexNormals.length;j<jl;j++){normal=faceVertexNormals[j].clone();if(normalMatrix!==undefined){normal.applyMatrix3(normalMatrix).normalize();}faceCopy.vertexNormals.push(normal);}faceCopy.color.copy(face.color);for(var j=0,jl=faceVertexColors.length;j<jl;j++){color=faceVertexColors[j];faceCopy.vertexColors.push(color.clone());}faceCopy.materialIndex=face.materialIndex+materialIndexOffset;faces1.push(faceCopy);}// uvs
for(i=0,il=uvs2.length;i<il;i++){var uv=uvs2[i],uvCopy=[];if(uv===undefined){continue;}for(var j=0,jl=uv.length;j<jl;j++){uvCopy.push(uv[j].clone());}uvs1.push(uvCopy);}},mergeMesh:function(mesh){if((mesh&&mesh.isMesh)===false){console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);return;}mesh.matrixAutoUpdate&&mesh.updateMatrix();this.merge(mesh.geometry,mesh.matrix);},/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */mergeVertices:function(){var verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var unique=[],changes=[];var v,key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var i,il,face;var indices,j,jl;for(i=0,il=this.vertices.length;i<il;i++){v=this.vertices[i];key=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);if(verticesMap[key]===undefined){verticesMap[key]=i;unique.push(this.vertices[i]);changes[i]=unique.length-1;}else{//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
changes[i]=changes[verticesMap[key]];}}// if faces are completely degenerate after merging vertices, we
// have to remove them from the geometry.
var faceIndicesToRemove=[];for(i=0,il=this.faces.length;i<il;i++){face=this.faces[i];face.a=changes[face.a];face.b=changes[face.b];face.c=changes[face.c];indices=[face.a,face.b,face.c];// if any duplicate vertices are found in a Face3
// we have to remove the face as nothing can be saved
for(var n=0;n<3;n++){if(indices[n]===indices[(n+1)%3]){faceIndicesToRemove.push(i);break;}}}for(i=faceIndicesToRemove.length-1;i>=0;i--){var idx=faceIndicesToRemove[i];this.faces.splice(idx,1);for(j=0,jl=this.faceVertexUvs.length;j<jl;j++){this.faceVertexUvs[j].splice(idx,1);}}// Use unique set of vertices
var diff=this.vertices.length-unique.length;this.vertices=unique;return diff;},sortFacesByMaterialIndex:function(){var faces=this.faces;var length=faces.length;// tag faces
for(var i=0;i<length;i++){faces[i]._id=i;}// sort faces
function materialIndexSort(a,b){return a.materialIndex-b.materialIndex;}faces.sort(materialIndexSort);// sort uvs
var uvs1=this.faceVertexUvs[0];var uvs2=this.faceVertexUvs[1];var newUvs1,newUvs2;if(uvs1&&uvs1.length===length)newUvs1=[];if(uvs2&&uvs2.length===length)newUvs2=[];for(var i=0;i<length;i++){var id=faces[i]._id;if(newUvs1)newUvs1.push(uvs1[id]);if(newUvs2)newUvs2.push(uvs2[id]);}if(newUvs1)this.faceVertexUvs[0]=newUvs1;if(newUvs2)this.faceVertexUvs[1]=newUvs2;},toJSON:function(){var data={metadata:{version:4.5,type:'Geometry',generator:'Geometry.toJSON'}};// standard Geometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}var vertices=[];for(var i=0;i<this.vertices.length;i++){var vertex=this.vertices[i];vertices.push(vertex.x,vertex.y,vertex.z);}var faces=[];var normals=[];var normalsHash={};var colors=[];var colorsHash={};var uvs=[];var uvsHash={};for(var i=0;i<this.faces.length;i++){var face=this.faces[i];var hasMaterial=true;var hasFaceUv=false;// deprecated
var hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;var hasFaceNormal=face.normal.length()>0;var hasFaceVertexNormal=face.vertexNormals.length>0;var hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;var hasFaceVertexColor=face.vertexColors.length>0;var faceType=0;faceType=setBit(faceType,0,0);// isQuad
faceType=setBit(faceType,1,hasMaterial);faceType=setBit(faceType,2,hasFaceUv);faceType=setBit(faceType,3,hasFaceVertexUv);faceType=setBit(faceType,4,hasFaceNormal);faceType=setBit(faceType,5,hasFaceVertexNormal);faceType=setBit(faceType,6,hasFaceColor);faceType=setBit(faceType,7,hasFaceVertexColor);faces.push(faceType);faces.push(face.a,face.b,face.c);faces.push(face.materialIndex);if(hasFaceVertexUv){var faceVertexUvs=this.faceVertexUvs[0][i];faces.push(getUvIndex(faceVertexUvs[0]),getUvIndex(faceVertexUvs[1]),getUvIndex(faceVertexUvs[2]));}if(hasFaceNormal){faces.push(getNormalIndex(face.normal));}if(hasFaceVertexNormal){var vertexNormals=face.vertexNormals;faces.push(getNormalIndex(vertexNormals[0]),getNormalIndex(vertexNormals[1]),getNormalIndex(vertexNormals[2]));}if(hasFaceColor){faces.push(getColorIndex(face.color));}if(hasFaceVertexColor){var vertexColors=face.vertexColors;faces.push(getColorIndex(vertexColors[0]),getColorIndex(vertexColors[1]),getColorIndex(vertexColors[2]));}}function setBit(value,position,enabled){return enabled?value|1<<position:value&~(1<<position);}function getNormalIndex(normal){var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();if(normalsHash[hash]!==undefined){return normalsHash[hash];}normalsHash[hash]=normals.length/3;normals.push(normal.x,normal.y,normal.z);return normalsHash[hash];}function getColorIndex(color){var hash=color.r.toString()+color.g.toString()+color.b.toString();if(colorsHash[hash]!==undefined){return colorsHash[hash];}colorsHash[hash]=colors.length;colors.push(color.getHex());return colorsHash[hash];}function getUvIndex(uv){var hash=uv.x.toString()+uv.y.toString();if(uvsHash[hash]!==undefined){return uvsHash[hash];}uvsHash[hash]=uvs.length/2;uvs.push(uv.x,uv.y);return uvsHash[hash];}data.data={};data.data.vertices=vertices;data.data.normals=normals;if(colors.length>0)data.data.colors=colors;if(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility
data.data.faces=faces;return data;},clone:function(){/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */return new Geometry().copy(this);},copy:function(source){var i,il,j,jl,k,kl;// reset
this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// name
this.name=source.name;// vertices
var vertices=source.vertices;for(i=0,il=vertices.length;i<il;i++){this.vertices.push(vertices[i].clone());}// colors
var colors=source.colors;for(i=0,il=colors.length;i<il;i++){this.colors.push(colors[i].clone());}// faces
var faces=source.faces;for(i=0,il=faces.length;i<il;i++){this.faces.push(faces[i].clone());}// face vertex uvs
for(i=0,il=source.faceVertexUvs.length;i<il;i++){var faceVertexUvs=source.faceVertexUvs[i];if(this.faceVertexUvs[i]===undefined){this.faceVertexUvs[i]=[];}for(j=0,jl=faceVertexUvs.length;j<jl;j++){var uvs=faceVertexUvs[j],uvsCopy=[];for(k=0,kl=uvs.length;k<kl;k++){var uv=uvs[k];uvsCopy.push(uv.clone());}this.faceVertexUvs[i].push(uvsCopy);}}// morph targets
var morphTargets=source.morphTargets;for(i=0,il=morphTargets.length;i<il;i++){var morphTarget={};morphTarget.name=morphTargets[i].name;// vertices
if(morphTargets[i].vertices!==undefined){morphTarget.vertices=[];for(j=0,jl=morphTargets[i].vertices.length;j<jl;j++){morphTarget.vertices.push(morphTargets[i].vertices[j].clone());}}// normals
if(morphTargets[i].normals!==undefined){morphTarget.normals=[];for(j=0,jl=morphTargets[i].normals.length;j<jl;j++){morphTarget.normals.push(morphTargets[i].normals[j].clone());}}this.morphTargets.push(morphTarget);}// morph normals
var morphNormals=source.morphNormals;for(i=0,il=morphNormals.length;i<il;i++){var morphNormal={};// vertex normals
if(morphNormals[i].vertexNormals!==undefined){morphNormal.vertexNormals=[];for(j=0,jl=morphNormals[i].vertexNormals.length;j<jl;j++){var srcVertexNormal=morphNormals[i].vertexNormals[j];var destVertexNormal={};destVertexNormal.a=srcVertexNormal.a.clone();destVertexNormal.b=srcVertexNormal.b.clone();destVertexNormal.c=srcVertexNormal.c.clone();morphNormal.vertexNormals.push(destVertexNormal);}}// face normals
if(morphNormals[i].faceNormals!==undefined){morphNormal.faceNormals=[];for(j=0,jl=morphNormals[i].faceNormals.length;j<jl;j++){morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());}}this.morphNormals.push(morphNormal);}// skin weights
var skinWeights=source.skinWeights;for(i=0,il=skinWeights.length;i<il;i++){this.skinWeights.push(skinWeights[i].clone());}// skin indices
var skinIndices=source.skinIndices;for(i=0,il=skinIndices.length;i<il;i++){this.skinIndices.push(skinIndices[i].clone());}// line distances
var lineDistances=source.lineDistances;for(i=0,il=lineDistances.length;i<il;i++){this.lineDistances.push(lineDistances[i]);}// bounding box
var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// update flags
this.elementsNeedUpdate=source.elementsNeedUpdate;this.verticesNeedUpdate=source.verticesNeedUpdate;this.uvsNeedUpdate=source.uvsNeedUpdate;this.normalsNeedUpdate=source.normalsNeedUpdate;this.colorsNeedUpdate=source.colorsNeedUpdate;this.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;this.groupsNeedUpdate=source.groupsNeedUpdate;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */function BufferGeometry(){Object.defineProperty(this,'id',{value:GeometryIdCount()});this.uuid=_Math.generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};}BufferGeometry.MaxIndex=65535;Object.assign(BufferGeometry.prototype,EventDispatcher.prototype,{isBufferGeometry:true,getIndex:function(){return this.index;},setIndex:function(index){if(Array.isArray(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else{this.index=index;}},addAttribute:function(name,attribute){if((attribute&&attribute.isBufferAttribute)===false&&(attribute&&attribute.isInterleavedBufferAttribute)===false){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');this.addAttribute(name,new BufferAttribute(arguments[1],arguments[2]));return;}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return;}this.attributes[name]=attribute;return this;},getAttribute:function(name){return this.attributes[name];},removeAttribute:function(name){delete this.attributes[name];return this;},addGroup:function(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex!==undefined?materialIndex:0});},clearGroups:function(){this.groups=[];},setDrawRange:function(start,count){this.drawRange.start=start;this.drawRange.count=count;},applyMatrix:function(matrix){var position=this.attributes.position;if(position!==undefined){matrix.applyToBufferAttribute(position);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normalMatrix.applyToBufferAttribute(normal);normal.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;},rotateX:function(){// rotate geometry around world x-axis
var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),center:function(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},setFromObject:function(object){// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
var geometry=object.geometry;if(object.isPoints||object.isLine){var positions=new Float32BufferAttribute(geometry.vertices.length*3,3);var colors=new Float32BufferAttribute(geometry.colors.length*3,3);this.addAttribute('position',positions.copyVector3sArray(geometry.vertices));this.addAttribute('color',colors.copyColorsArray(geometry.colors));if(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){var lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);this.addAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}}else if(object.isMesh){if(geometry&&geometry.isGeometry){this.fromGeometry(geometry);}}return this;},updateFromObject:function(object){var geometry=object.geometry;if(object.isMesh){var direct=geometry.__directGeometry;if(geometry.elementsNeedUpdate===true){direct=undefined;geometry.elementsNeedUpdate=false;}if(direct===undefined){return this.fromGeometry(geometry);}direct.verticesNeedUpdate=geometry.verticesNeedUpdate;direct.normalsNeedUpdate=geometry.normalsNeedUpdate;direct.colorsNeedUpdate=geometry.colorsNeedUpdate;direct.uvsNeedUpdate=geometry.uvsNeedUpdate;direct.groupsNeedUpdate=geometry.groupsNeedUpdate;geometry.verticesNeedUpdate=false;geometry.normalsNeedUpdate=false;geometry.colorsNeedUpdate=false;geometry.uvsNeedUpdate=false;geometry.groupsNeedUpdate=false;geometry=direct;}var attribute;if(geometry.verticesNeedUpdate===true){attribute=this.attributes.position;if(attribute!==undefined){attribute.copyVector3sArray(geometry.vertices);attribute.needsUpdate=true;}geometry.verticesNeedUpdate=false;}if(geometry.normalsNeedUpdate===true){attribute=this.attributes.normal;if(attribute!==undefined){attribute.copyVector3sArray(geometry.normals);attribute.needsUpdate=true;}geometry.normalsNeedUpdate=false;}if(geometry.colorsNeedUpdate===true){attribute=this.attributes.color;if(attribute!==undefined){attribute.copyColorsArray(geometry.colors);attribute.needsUpdate=true;}geometry.colorsNeedUpdate=false;}if(geometry.uvsNeedUpdate){attribute=this.attributes.uv;if(attribute!==undefined){attribute.copyVector2sArray(geometry.uvs);attribute.needsUpdate=true;}geometry.uvsNeedUpdate=false;}if(geometry.lineDistancesNeedUpdate){attribute=this.attributes.lineDistance;if(attribute!==undefined){attribute.copyArray(geometry.lineDistances);attribute.needsUpdate=true;}geometry.lineDistancesNeedUpdate=false;}if(geometry.groupsNeedUpdate){geometry.computeGroups(object.geometry);this.groups=geometry.groups;geometry.groupsNeedUpdate=false;}return this;},fromGeometry:function(geometry){geometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);return this.fromDirectGeometry(geometry.__directGeometry);},fromDirectGeometry:function(geometry){var positions=new Float32Array(geometry.vertices.length*3);this.addAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));if(geometry.normals.length>0){var normals=new Float32Array(geometry.normals.length*3);this.addAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));}if(geometry.colors.length>0){var colors=new Float32Array(geometry.colors.length*3);this.addAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));}if(geometry.uvs.length>0){var uvs=new Float32Array(geometry.uvs.length*2);this.addAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));}if(geometry.uvs2.length>0){var uvs2=new Float32Array(geometry.uvs2.length*2);this.addAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));}if(geometry.indices.length>0){var TypeArray=arrayMax(geometry.indices)>65535?Uint32Array:Uint16Array;var indices=new TypeArray(geometry.indices.length*3);this.setIndex(new BufferAttribute(indices,1).copyIndicesArray(geometry.indices));}// groups
this.groups=geometry.groups;// morphs
for(var name in geometry.morphTargets){var array=[];var morphTargets=geometry.morphTargets[name];for(var i=0,l=morphTargets.length;i<l;i++){var morphTarget=morphTargets[i];var attribute=new Float32BufferAttribute(morphTarget.length*3,3);array.push(attribute.copyVector3sArray(morphTarget));}this.morphAttributes[name]=array;}// skinning
if(geometry.skinIndices.length>0){var skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);this.addAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));}if(geometry.skinWeights.length>0){var skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);this.addAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));}//
if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}return this;},computeBoundingBox:function(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);}else{this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}},computeBoundingSphere:function(){var box=new Box3();var vector=new Vector3();return function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;if(position){var center=this.boundingSphere.center;box.setFromBufferAttribute(position);box.getCenter(center);// hoping to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
var maxRadiusSq=0;for(var i=0,il=position.count;i<il;i++){vector.x=position.getX(i);vector.y=position.getY(i);vector.z=position.getZ(i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}};}(),computeFaceNormals:function(){// backwards compatibility
},computeVertexNormals:function(){var index=this.index;var attributes=this.attributes;var groups=this.groups;if(attributes.position){var positions=attributes.position.array;if(attributes.normal===undefined){this.addAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));}else{// reset existing normals to zero
var array=attributes.normal.array;for(var i=0,il=array.length;i<il;i++){array[i]=0;}}var normals=attributes.normal.array;var vA,vB,vC;var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
if(index){var indices=index.array;if(groups.length===0){this.addGroup(0,indices.length);}for(var j=0,jl=groups.length;j<jl;++j){var group=groups[j];var start=group.start;var count=group.count;for(var i=start,il=start+count;i<il;i+=3){vA=indices[i+0]*3;vB=indices[i+1]*3;vC=indices[i+2]*3;pA.fromArray(positions,vA);pB.fromArray(positions,vB);pC.fromArray(positions,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[vA]+=cb.x;normals[vA+1]+=cb.y;normals[vA+2]+=cb.z;normals[vB]+=cb.x;normals[vB+1]+=cb.y;normals[vB+2]+=cb.z;normals[vC]+=cb.x;normals[vC+1]+=cb.y;normals[vC+2]+=cb.z;}}}else{// non-indexed elements (unconnected triangle soup)
for(var i=0,il=positions.length;i<il;i+=9){pA.fromArray(positions,i);pB.fromArray(positions,i+3);pC.fromArray(positions,i+6);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[i]=cb.x;normals[i+1]=cb.y;normals[i+2]=cb.z;normals[i+3]=cb.x;normals[i+4]=cb.y;normals[i+5]=cb.z;normals[i+6]=cb.x;normals[i+7]=cb.y;normals[i+8]=cb.z;}}this.normalizeNormals();attributes.normal.needsUpdate=true;}},merge:function(geometry,offset){if((geometry&&geometry.isBufferGeometry)===false){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined)offset=0;var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeSize=attribute2.itemSize;for(var i=0,j=attributeSize*offset;i<attributeArray2.length;i++,j++){attributeArray1[j]=attributeArray2[i];}}return this;},normalizeNormals:function(){var normals=this.attributes.normal;var x,y,z,n;for(var i=0,il=normals.count;i<il;i++){x=normals.getX(i);y=normals.getY(i);z=normals.getZ(i);n=1.0/Math.sqrt(x*x+y*y+z*z);normals.setXYZ(i,x*n,y*n,z*n);}},toNonIndexed:function(){if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;for(var name in attributes){var attribute=attributes[name];var array=attribute.array;var itemSize=attribute.itemSize;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var i=0,l=indices.length;i<l;i++){index=indices[i]*itemSize;for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}geometry2.addAttribute(name,new BufferAttribute(array2,itemSize));}return geometry2;},toJSON:function(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}data.data={attributes:{}};var index=this.index;if(index!==null){var array=Array.prototype.slice.call(index.array);data.data.index={type:index.array.constructor.name,array:array};}var attributes=this.attributes;for(var key in attributes){var attribute=attributes[key];var array=Array.prototype.slice.call(attribute.array);data.data.attributes[key]={itemSize:attribute.itemSize,type:attribute.array.constructor.name,array:array,normalized:attribute.normalized};}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;},clone:function(){/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */return new BufferGeometry().copy(this);},copy:function(source){var name,i,l;// reset
this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// name
this.name=source.name;// index
var index=source.index;if(index!==null){this.setIndex(index.clone());}// attributes
var attributes=source.attributes;for(name in attributes){var attribute=attributes[name];this.addAttribute(name,attribute.clone());}// morph attributes
var morphAttributes=source.morphAttributes;for(name in morphAttributes){var array=[];var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
for(i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone());}this.morphAttributes[name]=array;}// groups
var groups=source.groups;for(i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */function Mesh(geometry,material){Object3D.call(this);this.type='Mesh';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new MeshBasicMaterial({color:Math.random()*0xffffff});this.drawMode=TrianglesDrawMode;this.updateMorphTargets();}Mesh.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Mesh,isMesh:true,setDrawMode:function(value){this.drawMode=value;},copy:function(source){Object3D.prototype.copy.call(this,source);this.drawMode=source.drawMode;return this;},updateMorphTargets:function(){var morphTargets=this.geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var m=0,ml=morphTargets.length;m<ml;m++){this.morphTargetInfluences.push(0);this.morphTargetDictionary[morphTargets[m].name]=m;}}},raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();var vA=new Vector3();var vB=new Vector3();var vC=new Vector3();var tempA=new Vector3();var tempB=new Vector3();var tempC=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();var barycoord=new Vector3();var intersectionPoint=new Vector3();var intersectionPointWorld=new Vector3();function uvIntersection(point,p1,p2,p3,uv1,uv2,uv3){Triangle.barycoordFromPoint(point,p1,p2,p3,barycoord);uv1.multiplyScalar(barycoord.x);uv2.multiplyScalar(barycoord.y);uv3.multiplyScalar(barycoord.z);uv1.add(uv2).add(uv3);return uv1.clone();}function checkIntersection(object,raycaster,ray,pA,pB,pC,point){var intersect;var material=object.material;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else{intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;intersectionPointWorld.copy(point);intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return{distance:distance,point:intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,raycaster,ray,position,uv,a,b,c){vA.fromBufferAttribute(position,a);vB.fromBufferAttribute(position,b);vC.fromBufferAttribute(position,c);var intersection=checkIntersection(object,raycaster,ray,vA,vB,vC,intersectionPoint);if(intersection){if(uv){uvA.fromBufferAttribute(uv,a);uvB.fromBufferAttribute(uv,b);uvC.fromBufferAttribute(uv,c);intersection.uv=uvIntersection(intersectionPoint,vA,vB,vC,uvA,uvB,uvC);}intersection.face=new Face3(a,b,c,Triangle.normal(vA,vB,vC));intersection.faceIndex=a;}return intersection;}return function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);// Check boundingBox before continuing
if(geometry.boundingBox!==null){if(ray.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var a,b,c;var index=geometry.index;var position=geometry.attributes.position;var uv=geometry.attributes.uv;var i,l;if(index!==null){// indexed buffer geometry
for(i=0,l=index.count;i<l;i+=3){a=index.getX(i);b=index.getX(i+1);c=index.getX(i+2);intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indices buffer semantics
intersects.push(intersection);}}}else{// non-indexed buffer geometry
for(i=0,l=position.count;i<l;i+=3){a=i;b=i+1;c=i+2;intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.index=a;// triangle number in positions buffer semantics
intersects.push(intersection);}}}}else if(geometry.isGeometry){var fvA,fvB,fvC;var isMultiMaterial=Array.isArray(material);var vertices=geometry.vertices;var faces=geometry.faces;var uvs;var faceVertexUvs=geometry.faceVertexUvs[0];if(faceVertexUvs.length>0)uvs=faceVertexUvs;for(var f=0,fl=faces.length;f<fl;f++){var face=faces[f];var faceMaterial=isMultiMaterial?material[face.materialIndex]:material;if(faceMaterial===undefined)continue;fvA=vertices[face.a];fvB=vertices[face.b];fvC=vertices[face.c];if(faceMaterial.morphTargets===true){var morphTargets=geometry.morphTargets;var morphInfluences=this.morphTargetInfluences;vA.set(0,0,0);vB.set(0,0,0);vC.set(0,0,0);for(var t=0,tl=morphTargets.length;t<tl;t++){var influence=morphInfluences[t];if(influence===0)continue;var targets=morphTargets[t].vertices;vA.addScaledVector(tempA.subVectors(targets[face.a],fvA),influence);vB.addScaledVector(tempB.subVectors(targets[face.b],fvB),influence);vC.addScaledVector(tempC.subVectors(targets[face.c],fvC),influence);}vA.add(fvA);vB.add(fvB);vC.add(fvC);fvA=vA;fvB=vB;fvC=vC;}intersection=checkIntersection(this,raycaster,ray,fvA,fvB,fvC,intersectionPoint);if(intersection){if(uvs&&uvs[f]){var uvs_f=uvs[f];uvA.copy(uvs_f[0]);uvB.copy(uvs_f[1]);uvC.copy(uvs_f[2]);intersection.uv=uvIntersection(intersectionPoint,fvA,fvB,fvC,uvA,uvB,uvC);}intersection.face=face;intersection.faceIndex=f;intersects.push(intersection);}}}};}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */// BoxGeometry
function BoxGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){Geometry.call(this);this.type='BoxGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};this.fromBufferGeometry(new BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments));this.mergeVertices();}BoxGeometry.prototype=Object.create(Geometry.prototype);BoxGeometry.prototype.constructor=BoxGeometry;// BoxBufferGeometry
function BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){BufferGeometry.call(this);this.type='BoxBufferGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=this;// segments
widthSegments=Math.floor(widthSegments)||1;heightSegments=Math.floor(heightSegments)||1;depthSegments=Math.floor(depthSegments)||1;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var ix,iy;var vector=new Vector3();// generate vertices, normals and uvs
for(iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
normals.push(vector.x,vector.y,vector.z);// uvs
uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
vertexCounter+=1;}}// indices
// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=numberOfVertices+ix+gridX1*iy;var b=numberOfVertices+ix+gridX1*(iy+1);var c=numberOfVertices+(ix+1)+gridX1*(iy+1);var d=numberOfVertices+(ix+1)+gridX1*iy;// faces
indices.push(a,b,d);indices.push(b,c,d);// increase counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
groupStart+=groupCount;// update total number of vertices
numberOfVertices+=vertexCounter;}}BoxBufferGeometry.prototype=Object.create(BufferGeometry.prototype);BoxBufferGeometry.prototype.constructor=BoxBufferGeometry;/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */// PlaneGeometry
function PlaneGeometry(width,height,widthSegments,heightSegments){Geometry.call(this);this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};this.fromBufferGeometry(new PlaneBufferGeometry(width,height,widthSegments,heightSegments));this.mergeVertices();}PlaneGeometry.prototype=Object.create(Geometry.prototype);PlaneGeometry.prototype.constructor=PlaneGeometry;// PlaneBufferGeometry
function PlaneBufferGeometry(width,height,widthSegments,heightSegments){BufferGeometry.call(this);this.type='PlaneBufferGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments)||1;var gridY=Math.floor(heightSegments)||1;var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;var ix,iy;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
for(iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}// indices
for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=ix+gridX1*iy;var b=ix+gridX1*(iy+1);var c=ix+1+gridX1*(iy+1);var d=ix+1+gridX1*iy;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}PlaneBufferGeometry.prototype=Object.create(BufferGeometry.prototype);PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/function Camera(){Object3D.call(this);this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();}Camera.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Camera,isCamera:true,copy:function(source){Object3D.prototype.copy.call(this,source);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);return this;},getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,-1).applyQuaternion(quaternion);};}(),clone:function(){return new this.constructor().copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */function PerspectiveCamera(fov,aspect,near,far){Camera.call(this);this.type='PerspectiveCamera';this.fov=fov!==undefined?fov:50;this.zoom=1;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.focus=10;this.aspect=aspect!==undefined?aspect:1;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
this.filmOffset=0;// horizontal film offset (same unit as gauge)
this.updateProjectionMatrix();}PerspectiveCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:true,copy:function(source){Camera.prototype.copy.call(this,source);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;},/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */setFocalLength:function(focalLength){// see http://www.bobatkins.com/photography/technical/field_of_view.html
var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=_Math.RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();},/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */getFocalLength:function(){var vExtentSlope=Math.tan(_Math.DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;},getEffectiveFOV:function(){return _Math.RAD2DEG*2*Math.atan(Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom);},getFilmWidth:function(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1);},getFilmHeight:function(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1);},/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */setViewOffset:function(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;this.view={fullWidth:fullWidth,fullHeight:fullHeight,offsetX:x,offsetY:y,width:width,height:height};this.updateProjectionMatrix();},clearViewOffset:function(){this.view=null;this.updateProjectionMatrix();},updateProjectionMatrix:function(){var near=this.near,top=near*Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-0.5*width,view=this.view;if(view!==null){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}});/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */function OrthographicCamera(left,right,top,bottom,near,far){Camera.call(this);this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.updateProjectionMatrix();}OrthographicCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:true,copy:function(source){Camera.prototype.copy.call(this,source);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;},setViewOffset:function(fullWidth,fullHeight,x,y,width,height){this.view={fullWidth:fullWidth,fullHeight:fullHeight,offsetX:x,offsetY:y,width:width,height:height};this.updateProjectionMatrix();},clearViewOffset:function(){this.view=null;this.updateProjectionMatrix();},updateProjectionMatrix:function(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null){var zoomW=this.zoom/(this.view.width/this.view.fullWidth);var zoomH=this.zoom/(this.view.height/this.view.fullHeight);var scaleW=(this.right-this.left)/this.view.width;var scaleH=(this.top-this.bottom)/this.view.height;left+=scaleW*(this.view.offsetX/zoomW);right=left+scaleW*(this.view.width/zoomW);top-=scaleH*(this.view.offsetY/zoomH);bottom=top-scaleH*(this.view.height/zoomH);}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLAttributes(gl){var buffers={};function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.dynamic?gl.DYNAMIC_DRAW:gl.STATIC_DRAW;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type=gl.FLOAT;if(array instanceof Float32Array){type=gl.FLOAT;}else if(array instanceof Float64Array){console.warn("Unsupported data buffer format: Float64Array");}else if(array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;}else if(array instanceof Int16Array){type=gl.SHORT;}else if(array instanceof Uint32Array){type=gl.UNSIGNED_INT;}else if(array instanceof Int32Array){type=gl.INT;}else if(array instanceof Int8Array){type=gl.BYTE;}else if(array instanceof Uint8Array){type=gl.UNSIGNED_BYTE;}return{buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(attribute.dynamic===false){gl.bufferData(bufferType,array,gl.STATIC_DRAW);}else if(updateRange.count===-1){// Not using update ranges
gl.bufferSubData(bufferType,0,array);}else if(updateRange.count===0){console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');}else{gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));updateRange.count=0;// reset range
}}//
function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers[attribute.uuid];}function remove(attribute){var data=buffers[attribute.uuid];if(data){gl.deleteBuffer(data.buffer);delete buffers[attribute.uuid];}}function update(attribute,bufferType){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers[attribute.uuid];if(data===undefined){buffers[attribute.uuid]=createBuffer(attribute,bufferType);}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return{get:get,remove:remove,update:update};}/**
 * @author mrdoob / http://mrdoob.com/
 */function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program&&b.program&&a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else{return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}if(a.z!==b.z){return b.z-a.z;}else{return a.id-b.id;}}function WebGLRenderList(){var opaque=[];var opaqueLastIndex=-1;var transparent=[];var transparentLastIndex=-1;function init(){opaqueLastIndex=-1;transparentLastIndex=-1;}function push(object,geometry,material,z,group){var array,index;// allocate the next position in the appropriate array
if(material.transparent){array=transparent;index=++transparentLastIndex;}else{array=opaque;index=++opaqueLastIndex;}// recycle existing render item or grow the array
var renderItem=array[index];if(renderItem){renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=material.program;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}else{renderItem={id:object.id,object:object,geometry:geometry,material:material,program:material.program,renderOrder:object.renderOrder,z:z,group:group};// assert( index === array.length );
array.push(renderItem);}}function finish(){opaque.length=opaqueLastIndex+1;transparent.length=transparentLastIndex+1;}function sort(){opaque.sort(painterSortStable);transparent.sort(reversePainterSortStable);}return{opaque:opaque,transparent:transparent,init:init,push:push,finish:finish,sort:sort};}function WebGLRenderLists(){var lists={};function get(scene,camera){var hash=scene.id+','+camera.id;var list=lists[hash];if(list===undefined){// console.log( 'THREE.WebGLRenderLists:', hash );
list=new WebGLRenderList();lists[hash]=list;}return list;}function dispose(){lists={};}return{get:get,dispose:dispose};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLIndexedBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}var type,size;function setIndex(index){if(index.array instanceof Uint32Array&&extensions.get('OES_element_index_uint')){type=gl.UNSIGNED_INT;size=4;}else if(index.array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;size=2;}else{type=gl.UNSIGNED_BYTE;size=1;}}function render(start,count){gl.drawElements(mode,count,type,start*size);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}extension.drawElementsInstancedANGLE(mode,count,type,start*size,geometry.maxInstancedCount);infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;}//
this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}var position=geometry.attributes.position;if(position.isInterleavedBufferAttribute){count=position.data.count;extension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);}else{extension.drawArraysInstancedANGLE(mode,start,count,geometry.maxInstancedCount);}infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;}//
this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLGeometries(gl,attributes,infoMemory){var geometries={};var wireframeAttributes={};function onGeometryDispose(event){var geometry=event.target;var buffergeometry=geometries[geometry.id];if(buffergeometry.index!==null){attributes.remove(buffergeometry.index);}for(var name in buffergeometry.attributes){attributes.remove(buffergeometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];// TODO Remove duplicate code
var attribute=wireframeAttributes[geometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[geometry.id];}attribute=wireframeAttributes[buffergeometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[buffergeometry.id];}//
infoMemory.geometries--;}function get(object,geometry){var buffergeometry=geometries[geometry.id];if(buffergeometry)return buffergeometry;geometry.addEventListener('dispose',onGeometryDispose);if(geometry.isBufferGeometry){buffergeometry=geometry;}else if(geometry.isGeometry){if(geometry._bufferGeometry===undefined){geometry._bufferGeometry=new BufferGeometry().setFromObject(object);}buffergeometry=geometry._bufferGeometry;}geometries[geometry.id]=buffergeometry;infoMemory.geometries++;return buffergeometry;}function update(geometry){var index=geometry.index;var geometryAttributes=geometry.attributes;if(index!==null){attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);}for(var name in geometryAttributes){attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);}// morph targets
var morphAttributes=geometry.morphAttributes;for(var name in morphAttributes){var array=morphAttributes[name];for(var i=0,l=array.length;i<l;i++){attributes.update(array[i],gl.ARRAY_BUFFER);}}}function getWireframeAttribute(geometry){var attribute=wireframeAttributes[geometry.id];if(attribute)return attribute;var indices=[];var geometryIndex=geometry.index;var geometryAttributes=geometry.attributes;// console.time( 'wireframe' );
if(geometryIndex!==null){var array=geometryIndex.array;for(var i=0,l=array.length;i<l;i+=3){var a=array[i+0];var b=array[i+1];var c=array[i+2];indices.push(a,b,b,c,c,a);}}else{var array=geometryAttributes.position.array;for(var i=0,l=array.length/3-1;i<l;i+=3){var a=i+0;var b=i+1;var c=i+2;indices.push(a,b,b,c,c,a);}}// console.timeEnd( 'wireframe' );
attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attributes.update(attribute,gl.ELEMENT_ARRAY_BUFFER);wireframeAttributes[geometry.id]=attribute;return attribute;}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLLights(){var lights={};return{get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color(),shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={position:new Vector3(),color:new Color(),distance:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()// TODO (abelnation): set RectAreaLight shadow uniforms
};break;}lights[light.id]=uniforms;return uniforms;}};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLObjects(gl,geometries,infoRender){var updateList={};function update(object){var frame=infoRender.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
if(updateList[buffergeometry.id]!==frame){if(geometry.isGeometry){buffergeometry.updateFromObject(object);}geometries.update(buffergeometry);updateList[buffergeometry.id]=frame;}return buffergeometry;}function clear(){updateList={};}return{update:update,clear:clear};}/**
 * @author mrdoob / http://mrdoob.com/
 */function addLineNumbers(string){var lines=string.split('\n');for(var i=0;i<lines.length;i++){lines[i]=i+1+': '+lines[i];}return lines.join('\n');}function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)===false){console.error('THREE.WebGLShader: Shader couldn\'t compile.');}if(gl.getShaderInfoLog(shader)!==''){console.warn('THREE.WebGLShader: gl.getShaderInfoLog()',type===gl.VERTEX_SHADER?'vertex':'fragment',gl.getShaderInfoLog(shader),addLineNumbers(string));}// --enable-privileged-webgl-extension
// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
return shader;}/**
 * @author mrdoob / http://mrdoob.com/
 */var programIdCount=0;function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return['Linear','( value )'];case sRGBEncoding:return['sRGB','( value )'];case RGBEEncoding:return['RGBE','( value )'];case RGBM7Encoding:return['RGBM','( value, 7.0 )'];case RGBM16Encoding:return['RGBM','( value, 16.0 )'];case RGBDEncoding:return['RGBD','( value, 256.0 )'];case GammaEncoding:return['Gamma','( value, float( GAMMA_FACTOR ) )'];default:throw new Error('unsupported encoding: '+encoding);}}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return "+components[0]+"ToLinear"+components[1]+"; }";}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return LinearTo"+components[0]+components[1]+"; }";}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName="Linear";break;case ReinhardToneMapping:toneMappingName="Reinhard";break;case Uncharted2ToneMapping:toneMappingName="Uncharted2";break;case CineonToneMapping:toneMappingName="OptimizedCineon";break;default:throw new Error('unsupported toneMapping: '+toneMapping);}return"vec3 "+functionName+"( vec3 color ) { return "+toneMappingName+"ToneMapping( color ); }";}function generateExtensions(extensions,parameters,rendererExtensions){extensions=extensions||{};var chunks=[extensions.derivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.normalMap||parameters.flatShading?'#extension GL_OES_standard_derivatives : enable':'',(extensions.fragDepth||parameters.logarithmicDepthBuffer)&&rendererExtensions.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',extensions.drawBuffers&&rendererExtensions.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',(extensions.shaderTextureLOD||parameters.envMap)&&rendererExtensions.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program,identifiers){var attributes={};var n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(var i=0;i<n;i++){var info=gl.getActiveAttrib(program,i);var name=info.name;// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
attributes[name]=gl.getAttribLocation(program,name);}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights);}function parseIncludes(string){var pattern=/^[ \t]*#include +<([\w\d.]+)>/gm;function replace(match,include){var replace=ShaderChunk[include];if(replace===undefined){throw new Error('Can not resolve #include <'+include+'>');}return parseIncludes(replace);}return string.replace(pattern,replace);}function unrollLoops(string){var pattern=/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;function replace(match,start,end,snippet){var unroll='';for(var i=parseInt(start);i<parseInt(end);i++){unroll+=snippet.replace(/\[ i \]/g,'[ '+i+' ]');}return unroll;}return string.replace(pattern,replace);}function WebGLProgram(renderer,code,material,parameters){var gl=renderer.context;var extensions=material.extensions;var defines=material.defines;var vertexShader=material.__webglShader.vertexShader;var fragmentShader=material.__webglShader.fragmentShader;var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}var envMapTypeDefine='ENVMAP_TYPE_CUBE';var envMapModeDefine='ENVMAP_MODE_REFLECTION';var envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';if(parameters.envMap){switch(material.envMap.mapping){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;case EquirectangularReflectionMapping:case EquirectangularRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_EQUIREC';break;case SphericalReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_SPHERE';break;}switch(material.envMap.mapping){case CubeRefractionMapping:case EquirectangularRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}switch(material.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;// console.log( 'building new program ' );
//
var customExtensions=generateExtensions(extensions,parameters,renderer.extensions);var customDefines=generateDefines(defines);//
var program=gl.createProgram();var prefixVertex,prefixFragment;if(material.isRawShaderMaterial){prefixVertex=[customDefines,'\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,customDefines,'\n'].filter(filterEmptyLine).join('\n');}else{prefixVertex=['precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+material.__webglShader.name,customDefines,parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_COLOR','	attribute vec3 color;','#endif','#ifdef USE_MORPHTARGETS','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,'precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+material.__webglShader.name,customDefines,parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest:'','#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,'#define UNION_CLIPPING_PLANES '+(parameters.numClippingPlanes-parameters.numClipIntersection),parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":'',parameters.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',parameters.envMap&&renderer.extensions.get('EXT_shader_texture_lod')?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;',parameters.toneMapping!==NoToneMapping?"#define TONE_MAPPING":'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
parameters.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.outputEncoding||parameters.mapEncoding||parameters.envMapEncoding||parameters.emissiveMapEncoding?ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below
parameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.outputEncoding?getTexelEncodingFunction("linearToOutputTexel",parameters.outputEncoding):'',parameters.depthPacking?"#define DEPTH_PACKING "+material.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=parseIncludes(vertexShader,parameters);vertexShader=replaceLightNums(vertexShader,parameters);fragmentShader=parseIncludes(fragmentShader,parameters);fragmentShader=replaceLightNums(fragmentShader,parameters);if(!material.isShaderMaterial){vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);}var vertexGlsl=prefixVertex+vertexShader;var fragmentGlsl=prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
// console.log( '*FRAGMENT*', fragmentGlsl );
var glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);var glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
if(material.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,material.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);var programLog=gl.getProgramInfoLog(program);var vertexLog=gl.getShaderInfoLog(glVertexShader);var fragmentLog=gl.getShaderInfoLog(glFragmentShader);var runnable=true;var haveDiagnostics=true;// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){runnable=false;console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'gl.VALIDATE_STATUS',gl.getProgramParameter(program,gl.VALIDATE_STATUS),'gl.getProgramInfoLog',programLog,vertexLog,fragmentLog);}else if(programLog!==''){console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,material:material,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}// clean up
gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program,renderer);}return cachedUniforms;};// set up caching for attribute locations
var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
this.destroy=function(){gl.deleteProgram(program);this.program=undefined;};// DEPRECATED
Object.defineProperties(this,{uniforms:{get:function(){console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');return this.getUniforms();}},attributes:{get:function(){console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');return this.getAttributes();}}});//
this.id=programIdCount++;this.code=code;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLPrograms(renderer,capabilities){var programs=[];var shaderIDs={MeshDepthMaterial:'depth',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'phong',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points'};var parameterNames=["precision","supportsVertexTextures","map","mapEncoding","envMap","envMapMode","envMapEncoding","lightMap","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","fog","useFog","fogExp","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","shadowMapEnabled","shadowMapType","toneMapping",'physicallyCorrectLights',"alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering"];function allocateBones(object){var skeleton=object.skeleton;var bones=skeleton.bones;if(capabilities.floatVertexTextures){return 1024;}else{// default for when object is not specified
// ( for example when prebuilding shader to be used with multiple objects )
//
//  - leave some extra space for other uniforms
//  - limit here is ANGLE's 254 max uniform vectors
//    (up to 54 should be safe)
var nVertexUniforms=capabilities.maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');return 0;}return maxBones;}}function getTextureEncodingFromMap(map,gammaOverrideLinear){var encoding;if(!map){encoding=LinearEncoding;}else if(map.isTexture){encoding=map.encoding;}else if(map.isWebGLRenderTarget){console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");encoding=map.texture.encoding;}// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
if(encoding===LinearEncoding&&gammaOverrideLinear){encoding=GammaEncoding;}return encoding;}this.getParameters=function(material,lights,fog,nClipPlanes,nClipIntersection,object){var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
// (not to blow over maxLights budget)
var maxBones=object.isSkinnedMesh?allocateBones(object):0;var precision=renderer.getPrecision();if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var currentRenderTarget=renderer.getRenderTarget();var parameters={shaderID:shaderID,precision:precision,supportsVertexTextures:capabilities.vertexTextures,outputEncoding:getTextureEncodingFromMap(!currentRenderTarget?null:currentRenderTarget.texture,renderer.gammaOutput),map:!!material.map,mapEncoding:getTextureEncodingFromMap(material.map,renderer.gammaInput),envMap:!!material.envMap,envMapMode:material.envMap&&material.envMap.mapping,envMapEncoding:getTextureEncodingFromMap(material.envMap,renderer.gammaInput),envMapCubeUV:!!material.envMap&&(material.envMap.mapping===CubeUVReflectionMapping||material.envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap,renderer.gammaInput),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,alphaMap:!!material.alphaMap,gradientMap:!!material.gradientMap,combine:material.combine,vertexColors:material.vertexColors,fog:!!fog,useFog:material.fog,fogExp:fog&&fog.isFogExp2,flatShading:material.shading===FlatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:capabilities.logarithmicDepthBuffer,skinning:material.skinning&&maxBones>0,maxBones:maxBones,useVertexTexture:capabilities.floatVertexTextures,morphTargets:material.morphTargets,morphNormals:material.morphNormals,maxMorphTargets:renderer.maxMorphTargets,maxMorphNormals:renderer.maxMorphNormals,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numClippingPlanes:nClipPlanes,numClipIntersection:nClipIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&object.receiveShadow&&lights.shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:renderer.toneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,alphaTest:material.alphaTest,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false};return parameters;};this.getProgramCode=function(material,parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else{array.push(material.fragmentShader);array.push(material.vertexShader);}if(material.defines!==undefined){for(var name in material.defines){array.push(name);array.push(material.defines[name]);}}for(var i=0;i<parameterNames.length;i++){array.push(parameters[parameterNames[i]]);}return array.join();};this.acquireProgram=function(material,parameters,code){var program;// Check if code has been already compiled
for(var p=0,pl=programs.length;p<pl;p++){var programInfo=programs[p];if(programInfo.code===code){program=programInfo;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,code,material,parameters);programs.push(program);}return program;};this.releaseProgram=function(program){if(--program.usedTimes===0){// Remove from unordered set
var i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
program.destroy();}};// Exposed for resource monitoring & error feedback via renderer.info:
this.programs=programs;}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,infoMemory){var _isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&_gl instanceof WebGL2RenderingContext;//
function clampToMaxSize(image,maxSize){if(image.width>maxSize||image.height>maxSize){// Warning: Scaling through the canvas will only work with images that use
// premultiplied alpha.
var scale=maxSize/Math.max(image.width,image.height);var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=Math.floor(image.width*scale);canvas.height=Math.floor(image.height*scale);var context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is too big ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function isPowerOfTwo(image){return _Math.isPowerOfTwo(image.width)&&_Math.isPowerOfTwo(image.height);}function makePowerOfTwo(image){if(image instanceof HTMLImageElement||image instanceof HTMLCanvasElement){var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=_Math.nearestPowerOfTwo(image.width);canvas.height=_Math.nearestPowerOfTwo(image.height);var context=canvas.getContext('2d');context.drawImage(image,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is not power of two ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function textureNeedsPowerOfTwo(texture){return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}// Fallback filters for non-power-of-2 textures
function filterFallback(f){if(f===NearestFilter||f===NearestMipMapNearestFilter||f===NearestMipMapLinearFilter){return _gl.NEAREST;}return _gl.LINEAR;}//
function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);infoMemory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);infoMemory.textures--;}//
function deallocateTexture(texture){var textureProperties=properties.get(texture);if(texture.image&&textureProperties.__image__webglTextureCube){// cube texture
_gl.deleteTexture(textureProperties.__image__webglTextureCube);}else{// 2D texture
if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);}// remove all webgl properties
properties.remove(texture);}function deallocateRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLRenderTargetCube){for(var i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);}properties.remove(renderTarget.texture);properties.remove(renderTarget);}//
function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined',texture);}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete',texture);}else{uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.image.length===6){if(texture.version>0&&textureProperties.__version!==texture.version){if(!textureProperties.__image__webglTextureCube){texture.addEventListener('dispose',onTextureDispose);textureProperties.__image__webglTextureCube=_gl.createTexture();infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);var isCompressed=texture&&texture.isCompressedTexture;var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=clampToMaxSize(texture.image[i],capabilities.maxCubemapSize);}else{cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}}var image=cubeImage[0],isPowerOfTwoImage=isPowerOfTwo(image),glFormat=paramThreeToGL(texture.format),glType=paramThreeToGL(texture.type);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,isPowerOfTwoImage);for(var i=0;i<6;i++){if(!isCompressed){if(isDataTexture){state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,glFormat,glType,cubeImage[i]);}}else{var mipmap,mipmaps=cubeImage[i].mipmaps;for(var j=0,jl=mipmaps.length;j<jl;j++){mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");}}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}if(texture.generateMipmaps&&isPowerOfTwoImage){_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}else{state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);}}}function setTextureCubeDynamic(texture,slot){state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,properties.get(texture).__webglTexture);}function setTextureParameters(textureType,texture,isPowerOfTwoImage){var extension;if(isPowerOfTwoImage){_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,paramThreeToGL(texture.wrapS));_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,paramThreeToGL(texture.wrapT));_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,paramThreeToGL(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,paramThreeToGL(texture.minFilter));}else{_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE);_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE);if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',texture);}_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',texture);}}extension=extensions.get('EXT_texture_filter_anisotropic');if(extension){if(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;if(texture.type===HalfFloatType&&extensions.get('OES_texture_half_float_linear')===null)return;if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function uploadTexture(textureProperties,texture,slot){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);var image=clampToMaxSize(texture.image,capabilities.maxTextureSize);if(textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(image)===false){image=makePowerOfTwo(image);}var isPowerOfTwoImage=isPowerOfTwo(image),glFormat=paramThreeToGL(texture.format),glType=paramThreeToGL(texture.type);setTextureParameters(_gl.TEXTURE_2D,texture,isPowerOfTwoImage);var mipmap,mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
var internalFormat=_gl.DEPTH_COMPONENT;if(texture.type===FloatType){if(!_isWebGL2)throw new Error('Float Depth Texture only supported in WebGL2.0');internalFormat=_gl.DEPTH_COMPONENT32F;}else if(_isWebGL2){// WebGL 2.0 requires signed internalformat for glTexImage2D
internalFormat=_gl.DEPTH_COMPONENT16;}if(texture.format===DepthFormat&&internalFormat===_gl.DEPTH_COMPONENT){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=paramThreeToGL(texture.type);}}// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.format===DepthStencilFormat){internalFormat=_gl.DEPTH_STENCIL;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=paramThreeToGL(texture.type);}}state.texImage2D(_gl.TEXTURE_2D,0,internalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,image.width,image.height,0,glFormat,glType,image.data);}}else if(texture.isCompressedTexture){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");}}else{state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}else{// regular Texture (image, video, canvas)
// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,glFormat,glType,image);}}if(texture.generateMipmaps&&isPowerOfTwoImage)_gl.generateMipmap(_gl.TEXTURE_2D);textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){var glFormat=paramThreeToGL(renderTarget.texture.format);var glType=paramThreeToGL(renderTarget.texture.type);state.texImage2D(textureTarget,0,glFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function setupRenderBufferStorage(renderbuffer,renderTarget){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_COMPONENT16,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else{// FIXME: We don't support !depth !stencil
_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.RGBA4,renderTarget.width,renderTarget.height);}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;if(isCube)throw new Error('Depth Texture with cube render targets is not supported!');_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else{throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLRenderTargetCube===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else{if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var i=0;i<6;i++){_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget);}}else{_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget);}}_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Set up GL resources for the render target
function setupRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);textureProperties.__webglTexture=_gl.createTexture();infoMemory.textures++;var isCube=renderTarget.isWebGLRenderTargetCube===true;var isTargetPowerOfTwo=isPowerOfTwo(renderTarget);// Setup framebuffer
if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();}// Setup color buffer
if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,renderTarget.texture,isTargetPowerOfTwo);for(var i=0;i<6;i++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i);}if(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);state.bindTexture(_gl.TEXTURE_CUBE_MAP,null);}else{state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_2D,renderTarget.texture,isTargetPowerOfTwo);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D);if(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_2D);state.bindTexture(_gl.TEXTURE_2D,null);}// Setup depth and stencil buffers
if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var texture=renderTarget.texture;if(texture.generateMipmaps&&isPowerOfTwo(renderTarget)&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){var target=renderTarget&&renderTarget.isWebGLRenderTargetCube?_gl.TEXTURE_CUBE_MAP:_gl.TEXTURE_2D;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);_gl.generateMipmap(target);state.bindTexture(target,null);}}this.setTexture2D=setTexture2D;this.setTextureCube=setTextureCube;this.setTextureCubeDynamic=setTextureCubeDynamic;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;}/**
 * @author fordacious / fordacious.github.io
 */function WebGLProperties(){var properties={};function get(object){var uuid=object.uuid;var map=properties[uuid];if(map===undefined){map={};properties[uuid]=map;}return map;}function remove(object){delete properties[object.uuid];}function clear(){properties={};}return{get:get,remove:remove,clear:clear};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLState(gl,extensions,paramThreeToGL){function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4();return{setMask:function(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function(lock){locked=lock;},setClear:function(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function(){locked=false;currentColorMask=null;currentColorClear.set(0,0,0,1);}};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return{setTest:function(depthTest){if(depthTest){enable(gl.DEPTH_TEST);}else{disable(gl.DEPTH_TEST);}},setMask:function(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL);}}else{gl.depthFunc(gl.LEQUAL);}currentDepthFunc=depthFunc;}},setLocked:function(lock){locked=lock;},setClear:function(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return{setTest:function(stencilTest){if(stencilTest){enable(gl.STENCIL_TEST);}else{disable(gl.STENCIL_TEST);}},setMask:function(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function(lock){locked=lock;},setClear:function(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var newAttributes=new Uint8Array(maxVertexAttributes);var enabledAttributes=new Uint8Array(maxVertexAttributes);var attributeDivisors=new Uint8Array(maxVertexAttributes);var capabilities={};var compressedTextureFormats=null;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var currentScissorTest=null;var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var version=parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);var lineWidthAvailable=parseFloat(version)>=1.0;var currentTextureSlot=null;var currentBoundTextures={};var currentScissor=new Vector4();var currentViewport=new Vector4();function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(var i=0;i<count;i++){gl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}return texture;}var emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);//
function init(){colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(gl.CULL_FACE);enable(gl.BLEND);setBlending(NormalBlending);}function initAttributes(){for(var i=0,l=newAttributes.length;i<l;i++){newAttributes[i]=0;}}function enableAttribute(attribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==0){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,0);attributeDivisors[attribute]=0;}}function enableAttributeAndDivisor(attribute,meshPerAttribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){for(var i=0,l=enabledAttributes.length;i!==l;++i){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function enable(id){if(capabilities[id]!==true){gl.enable(id);capabilities[id]=true;}}function disable(id){if(capabilities[id]!==false){gl.disable(id);capabilities[id]=false;}}function getCompressedTextureFormats(){if(compressedTextureFormats===null){compressedTextureFormats=[];if(extensions.get('WEBGL_compressed_texture_pvrtc')||extensions.get('WEBGL_compressed_texture_s3tc')||extensions.get('WEBGL_compressed_texture_etc1')){var formats=gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);for(var i=0;i<formats.length;i++){compressedTextureFormats.push(formats[i]);}}}return compressedTextureFormats;}function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending!==NoBlending){enable(gl.BLEND);}else{disable(gl.BLEND);}if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(blending===AdditiveBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE,gl.ONE,gl.ONE);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);}}else if(blending===SubtractiveBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.ONE_MINUS_SRC_COLOR);}}else if(blending===MultiplyBlending){if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.SRC_COLOR);}}else{if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}}currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}if(blending===CustomBlending){blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(paramThreeToGL(blendEquation),paramThreeToGL(blendEquationAlpha));currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(paramThreeToGL(blendSrc),paramThreeToGL(blendDst),paramThreeToGL(blendSrcAlpha),paramThreeToGL(blendDstAlpha));currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}}else{currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;}}function setMaterial(material){material.side===DoubleSide?disable(gl.CULL_FACE):enable(gl.CULL_FACE);setFlipSided(material.side===BackSide);material.transparent===true?setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha):setBlending(NoBlending);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);}//
function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(gl.CW);}else{gl.frontFace(gl.CCW);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(gl.CULL_FACE);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(gl.BACK);}else if(cullFace===CullFaceFront){gl.cullFace(gl.FRONT);}else{gl.cullFace(gl.FRONT_AND_BACK);}}}else{disable(gl.CULL_FACE);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(gl.POLYGON_OFFSET_FILL);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else{disable(gl.POLYGON_OFFSET_FILL);}}function getScissorTest(){return currentScissorTest;}function setScissorTest(scissorTest){currentScissorTest=scissorTest;if(scissorTest){enable(gl.SCISSOR_TEST);}else{disable(gl.SCISSOR_TEST);}}// texture
function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error(error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error(error);}}//
function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
function reset(){for(var i=0;i<enabledAttributes.length;i++){if(enabledAttributes[i]===1){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}capabilities={};compressedTextureFormats=null;currentTextureSlot=null;currentBoundTextures={};currentBlending=null;currentFlipSided=null;currentCullFace=null;colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},init:init,initAttributes:initAttributes,enableAttribute:enableAttribute,enableAttributeAndDivisor:enableAttributeAndDivisor,disableUnusedAttributes:disableUnusedAttributes,enable:enable,disable:disable,getCompressedTextureFormats:getCompressedTextureFormats,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,getScissorTest:getScissorTest,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,scissor:scissor,viewport:viewport,reset:reset};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;var extension=extensions.get('EXT_texture_filter_anisotropic');if(extension!==null){maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else{maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return'mediump';}}return'lowp';}var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true&&!!extensions.get('EXT_frag_depth');var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);var maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);var maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);var maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);var maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);var maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=!!extensions.get('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;return{getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLExtensions(gl){var extensions={};return{get:function(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;case'WEBGL_compressed_texture_etc1':extension=gl.getExtension('WEBGL_compressed_texture_etc1');break;default:extension=gl.getExtension(name);}if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}extensions[name]=extension;return extension;}};}/**
 * @author tschw
 */function WebGLClipping(){var scope=this,globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false,plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
if(renderingShadows){// there's no global clipping
projectPlanes(null);}else{resetGlobalState();}}else{var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4,dstArray=cache.clippingState||null;uniform.value=dstArray;// ensure unique state
dstArray=projectPlanes(planes,camera,lGlobal,fromCache);for(var i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}cache.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0,dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;return dstArray;}}// import { Sphere } from '../math/Sphere';
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */function WebGLRenderer(parameters){console.log('THREE.WebGLRenderer',REVISION);parameters=parameters||{};var _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false;var lights=[];var currentRenderList=null;var morphInfluences=new Float32Array(8);var sprites=[];var lensFlares=[];// public properties
this.domElement=_canvas;this.context=null;// clearing
this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
this.sortObjects=true;// user-defined clipping
this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
this.gammaFactor=2.0;// for backwards compatibility
this.gammaInput=false;this.gammaOutput=false;// physical lights
this.physicallyCorrectLights=false;// tone mapping
this.toneMapping=LinearToneMapping;this.toneMappingExposure=1.0;this.toneMappingWhitePoint=1.0;// morphs
this.maxMorphTargets=8;this.maxMorphNormals=4;// internal properties
var _this=this,// internal state cache
_currentProgram=null,_currentRenderTarget=null,_currentFramebuffer=null,_currentMaterialId=-1,_currentGeometryProgram='',_currentCamera=null,_currentScissor=new Vector4(),_currentScissorTest=null,_currentViewport=new Vector4(),//
_usedTextureUnits=0,//
_clearColor=new Color(0x000000),_clearAlpha=0,_width=_canvas.width,_height=_canvas.height,_pixelRatio=1,_scissor=new Vector4(0,0,_width,_height),_scissorTest=false,_viewport=new Vector4(0,0,_width,_height),// frustum
_frustum=new Frustum(),// clipping
_clipping=new WebGLClipping(),_clippingEnabled=false,_localClippingEnabled=false,// camera matrices cache
_projScreenMatrix=new Matrix4(),_vector3=new Vector3(),_matrix4=new Matrix4(),_matrix42=new Matrix4(),// light arrays cache
_lights={hash:'',ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],shadows:[]},// info
_infoMemory={geometries:0,textures:0},_infoRender={frame:0,calls:0,vertices:0,faces:0,points:0};this.info={render:_infoRender,memory:_infoMemory,programs:null};// initialize
var _gl;try{var contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer};_gl=_context||_canvas.getContext('webgl',contextAttributes)||_canvas.getContext('experimental-webgl',contextAttributes);if(_gl===null){if(_canvas.getContext('webgl')!==null){throw'Error creating WebGL context with your selected attributes.';}else{throw'Error creating WebGL context.';}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return{'rangeMin':1,'rangeMax':1,'precision':1};};}_canvas.addEventListener('webglcontextlost',onContextLost,false);}catch(error){console.error('THREE.WebGLRenderer: '+error);}var extensions=new WebGLExtensions(_gl);extensions.get('WEBGL_depth_texture');extensions.get('OES_texture_float');extensions.get('OES_texture_float_linear');extensions.get('OES_texture_half_float');extensions.get('OES_texture_half_float_linear');extensions.get('OES_standard_derivatives');extensions.get('ANGLE_instanced_arrays');if(extensions.get('OES_element_index_uint')){BufferGeometry.MaxIndex=4294967296;}var capabilities=new WebGLCapabilities(_gl,extensions,parameters);var state=new WebGLState(_gl,extensions,paramThreeToGL);var properties=new WebGLProperties();var textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,_infoMemory);var attributes=new WebGLAttributes(_gl);var geometries=new WebGLGeometries(_gl,attributes,_infoMemory);var objects=new WebGLObjects(_gl,geometries,_infoRender);var programCache=new WebGLPrograms(this,capabilities);var lightCache=new WebGLLights();var renderLists=new WebGLRenderLists();this.info.programs=programCache.programs;var bufferRenderer=new WebGLBufferRenderer(_gl,extensions,_infoRender);var indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,_infoRender);//
var backgroundPlaneCamera,backgroundPlaneMesh;var backgroundBoxCamera,backgroundBoxMesh;//
function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}function setDefaultGLState(){state.init();state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);}function resetGLState(){_currentProgram=null;_currentCamera=null;_currentGeometryProgram='';_currentMaterialId=-1;state.reset();}setDefaultGLState();this.context=_gl;this.capabilities=capabilities;this.extensions=extensions;this.properties=properties;this.state=state;// shadow map
var shadowMap=new WebGLShadowMap(this,_lights,objects,capabilities);this.shadowMap=shadowMap;// Plugins
var spritePlugin=new SpritePlugin(this,sprites);var lensFlarePlugin=new LensFlarePlugin(this,lensFlares);// API
this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.getMaxAnisotropy=function(){return capabilities.getMaxAnisotropy();};this.getPrecision=function(){return capabilities.precision;};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_viewport.z,_viewport.w,false);};this.getSize=function(){return{width:_width,height:_height};};this.setSize=function(width,height,updateStyle){_width=width;_height=height;_canvas.width=width*_pixelRatio;_canvas.height=height*_pixelRatio;if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.setViewport=function(x,y,width,height){state.viewport(_viewport.set(x,y,width,height));};this.setScissor=function(x,y,width,height){state.scissor(_scissor.set(x,y,width,height));};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};// Clearing
this.getClearColor=function(){return _clearColor;};this.setClearColor=function(color,alpha){_clearColor.set(color);_clearAlpha=alpha!==undefined?alpha:1;state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);};this.getClearAlpha=function(){return _clearAlpha;};this.setClearAlpha=function(alpha){_clearAlpha=alpha;state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=_gl.COLOR_BUFFER_BIT;if(depth===undefined||depth)bits|=_gl.DEPTH_BUFFER_BIT;if(stencil===undefined||stencil)bits|=_gl.STENCIL_BUFFER_BIT;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};this.clearTarget=function(renderTarget,color,depth,stencil){this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};// Reset
this.resetGLState=resetGLState;this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);renderLists.dispose();};// Events
function onContextLost(event){event.preventDefault();resetGLState();setDefaultGLState();properties.clear();objects.clear();}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
function deallocateMaterial(material){releaseMaterialProgramReference(material);properties.remove(material);}function releaseMaterialProgramReference(material){var programInfo=properties.get(material).program;material.program=undefined;if(programInfo!==undefined){programCache.releaseProgram(programInfo);}}// Buffer rendering
function renderObjectImmediate(object,program,material){object.render(function(object){_this.renderBufferImmediate(object,program,material);});}this.renderBufferImmediate=function(object,program,material){state.initAttributes();var buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();var programAttributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.position);_gl.bufferData(_gl.ARRAY_BUFFER,object.positionArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.position);_gl.vertexAttribPointer(programAttributes.position,3,_gl.FLOAT,false,0,0);}if(object.hasNormals){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.normal);if(!material.isMeshPhongMaterial&&!material.isMeshStandardMaterial&&!material.isMeshNormalMaterial&&material.shading===FlatShading){for(var i=0,l=object.count*3;i<l;i+=9){var array=object.normalArray;var nx=(array[i+0]+array[i+3]+array[i+6])/3;var ny=(array[i+1]+array[i+4]+array[i+7])/3;var nz=(array[i+2]+array[i+5]+array[i+8])/3;array[i+0]=nx;array[i+1]=ny;array[i+2]=nz;array[i+3]=nx;array[i+4]=ny;array[i+5]=nz;array[i+6]=nx;array[i+7]=ny;array[i+8]=nz;}}_gl.bufferData(_gl.ARRAY_BUFFER,object.normalArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.normal);_gl.vertexAttribPointer(programAttributes.normal,3,_gl.FLOAT,false,0,0);}if(object.hasUvs&&material.map){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.uv);_gl.bufferData(_gl.ARRAY_BUFFER,object.uvArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.uv);_gl.vertexAttribPointer(attributes.uv,2,_gl.FLOAT,false,0,0);}if(object.hasColors&&material.vertexColors!==NoColors){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.color);_gl.bufferData(_gl.ARRAY_BUFFER,object.colorArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.color);_gl.vertexAttribPointer(programAttributes.color,3,_gl.FLOAT,false,0,0);}state.disableUnusedAttributes();_gl.drawArrays(_gl.TRIANGLES,0,object.count);object.count=0;};function absNumericalSort(a,b){return Math.abs(b[0])-Math.abs(a[0]);}this.renderBufferDirect=function(camera,fog,geometry,material,object,group){state.setMaterial(material);var program=setProgram(camera,fog,material,object);var geometryProgram=geometry.id+'_'+program.id+'_'+(material.wireframe===true);var updateBuffers=false;if(geometryProgram!==_currentGeometryProgram){_currentGeometryProgram=geometryProgram;updateBuffers=true;}// morph targets
var morphTargetInfluences=object.morphTargetInfluences;if(morphTargetInfluences!==undefined){// TODO Remove allocations
var activeInfluences=[];for(var i=0,l=morphTargetInfluences.length;i<l;i++){var influence=morphTargetInfluences[i];activeInfluences.push([influence,i]);}activeInfluences.sort(absNumericalSort);if(activeInfluences.length>8){activeInfluences.length=8;}var morphAttributes=geometry.morphAttributes;for(var i=0,l=activeInfluences.length;i<l;i++){var influence=activeInfluences[i];morphInfluences[i]=influence[0];if(influence[0]!==0){var index=influence[1];if(material.morphTargets===true&&morphAttributes.position)geometry.addAttribute('morphTarget'+i,morphAttributes.position[index]);if(material.morphNormals===true&&morphAttributes.normal)geometry.addAttribute('morphNormal'+i,morphAttributes.normal[index]);}else{if(material.morphTargets===true)geometry.removeAttribute('morphTarget'+i);if(material.morphNormals===true)geometry.removeAttribute('morphNormal'+i);}}for(var i=activeInfluences.length,il=morphInfluences.length;i<il;i++){morphInfluences[i]=0.0;}program.getUniforms().setValue(_gl,'morphTargetInfluences',morphInfluences);updateBuffers=true;}//
var index=geometry.index;var position=geometry.attributes.position;var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}var renderer=bufferRenderer;if(index!==null){renderer=indexedBufferRenderer;renderer.setIndex(index);}if(updateBuffers){setupVertexAttributes(material,program,geometry);if(index!==null){_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer);}}//
var dataCount=0;if(index!==null){dataCount=index.count;}else if(position!==undefined){dataCount=position.count;}var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(_gl.LINES);}else{switch(object.drawMode){case TrianglesDrawMode:renderer.setMode(_gl.TRIANGLES);break;case TriangleStripDrawMode:renderer.setMode(_gl.TRIANGLE_STRIP);break;case TriangleFanDrawMode:renderer.setMode(_gl.TRIANGLE_FAN);break;}}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(_gl.LINES);}else if(object.isLineLoop){renderer.setMode(_gl.LINE_LOOP);}else{renderer.setMode(_gl.LINE_STRIP);}}else if(object.isPoints){renderer.setMode(_gl.POINTS);}if(geometry&&geometry.isInstancedBufferGeometry){if(geometry.maxInstancedCount>0){renderer.renderInstances(geometry,drawStart,drawCount);}}else{renderer.render(drawStart,drawCount);}};function setupVertexAttributes(material,program,geometry,startIndex){if(geometry&&geometry.isInstancedBufferGeometry){if(extensions.get('ANGLE_instanced_arrays')===null){console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}if(startIndex===undefined)startIndex=0;state.initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attributeProperties=attributes.get(geometryAttribute);var buffer=attributeProperties.buffer;var type=attributeProperties.type;var bytesPerElement=attributeProperties.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){state.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=data.meshPerAttribute*data.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,(startIndex*stride+offset)*bytesPerElement);}else{if(geometryAttribute.isInstancedBufferAttribute){state.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,startIndex*size*bytesPerElement);}}else if(materialDefaultAttributeValues!==undefined){var value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:_gl.vertexAttrib2fv(programAttribute,value);break;case 3:_gl.vertexAttrib3fv(programAttribute,value);break;case 4:_gl.vertexAttrib4fv(programAttribute,value);break;default:_gl.vertexAttrib1fv(programAttribute,value);}}}}}state.disableUnusedAttributes();}// Compile
this.compile=function(scene,camera){lights=[];scene.traverse(function(object){if(object.isLight){lights.push(object);}});setupLights(lights,camera);scene.traverse(function(object){if(object.material){if(Array.isArray(object.material)){for(var i=0;i<object.material.length;i++){initMaterial(object.material[i],scene.fog,object);}}else{initMaterial(object.material,scene.fog,object);}}});};// Rendering
this.render=function(scene,camera,renderTarget,forceClear){if(camera!==undefined&&camera.isCamera!==true){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}// reset caching for this frame
_currentGeometryProgram='';_currentMaterialId=-1;_currentCamera=null;// update scene graph
if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
camera.onBeforeRender(_this);if(camera.parent===null)camera.updateMatrixWorld();camera.matrixWorldInverse.getInverse(camera.matrixWorld);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);lights.length=0;sprites.length=0;lensFlares.length=0;_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,camera);currentRenderList.init();projectObject(scene,camera,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort();}//
if(_clippingEnabled)_clipping.beginShadows();setupShadows(lights);shadowMap.render(scene,camera);setupLights(lights,camera);if(_clippingEnabled)_clipping.endShadows();//
_infoRender.frame++;_infoRender.calls=0;_infoRender.vertices=0;_infoRender.faces=0;_infoRender.points=0;if(renderTarget===undefined){renderTarget=null;}this.setRenderTarget(renderTarget);//
var background=scene.background;if(background===null){state.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);}else if(background&&background.isColor){state.buffers.color.setClear(background.r,background.g,background.b,1,_premultipliedAlpha);forceClear=true;}if(this.autoClear||forceClear){this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);}if(background&&background.isCubeTexture){if(backgroundBoxCamera===undefined){backgroundBoxCamera=new PerspectiveCamera();backgroundBoxMesh=new Mesh(new BoxBufferGeometry(5,5,5),new ShaderMaterial({uniforms:ShaderLib.cube.uniforms,vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));}backgroundBoxCamera.projectionMatrix.copy(camera.projectionMatrix);backgroundBoxCamera.matrixWorld.extractRotation(camera.matrixWorld);backgroundBoxCamera.matrixWorldInverse.getInverse(backgroundBoxCamera.matrixWorld);backgroundBoxMesh.material.uniforms["tCube"].value=background;backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundBoxCamera.matrixWorldInverse,backgroundBoxMesh.matrixWorld);objects.update(backgroundBoxMesh);_this.renderBufferDirect(backgroundBoxCamera,null,backgroundBoxMesh.geometry,backgroundBoxMesh.material,backgroundBoxMesh,null);}else if(background&&background.isTexture){if(backgroundPlaneCamera===undefined){backgroundPlaneCamera=new OrthographicCamera(-1,1,1,-1,0,1);backgroundPlaneMesh=new Mesh(new PlaneBufferGeometry(2,2),new MeshBasicMaterial({depthTest:false,depthWrite:false,fog:false}));}backgroundPlaneMesh.material.map=background;objects.update(backgroundPlaneMesh);_this.renderBufferDirect(backgroundPlaneCamera,null,backgroundPlaneMesh.geometry,backgroundPlaneMesh.material,backgroundPlaneMesh,null);}//
var opaqueObjects=currentRenderList.opaque;var transparentObjects=currentRenderList.transparent;if(scene.overrideMaterial){var overrideMaterial=scene.overrideMaterial;if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera,overrideMaterial);if(transparentObjects.length)renderObjects(transparentObjects,scene,camera,overrideMaterial);}else{// opaque pass (front-to-back order)
if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera);// transparent pass (back-to-front order)
if(transparentObjects.length)renderObjects(transparentObjects,scene,camera);}// custom render plugins (post pass)
spritePlugin.render(scene,camera);lensFlarePlugin.render(scene,camera,_currentViewport);// Generate mipmap if we're using any kind of mipmap filtering
if(renderTarget){textures.updateRenderTargetMipmap(renderTarget);}// Ensure depth buffer writing is enabled so it can be cleared on next render
state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);if(camera.isArrayCamera&&camera.enabled){_this.setScissorTest(false);}camera.onAfterRender(_this);// _gl.finish();
};/*
	// TODO Duplicated code (Frustum)

	var _sphere = new Sphere();

	function isObjectViewable( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null )
			geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere ).
		applyMatrix4( object.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSpriteViewable( sprite ) {

		_sphere.center.set( 0, 0, 0 );
		_sphere.radius = 0.7071067811865476;
		_sphere.applyMatrix4( sprite.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSphereViewable( sphere ) {

		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

		var numPlanes = _clipping.numPlanes;

		if ( numPlanes === 0 ) return true;

		var planes = _this.clippingPlanes,

			center = sphere.center,
			negRad = - sphere.radius,
			i = 0;

		do {

			// out when deeper than radius in the negative halfspace
			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

		} while ( ++ i !== numPlanes );

		return true;

	}
	*/function projectObject(object,camera,sortObjects){if(!object.visible)return;var visible=object.layers.test(camera.layers);if(visible){if(object.isLight){lights.push(object);}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){sprites.push(object);}}else if(object.isLensFlare){lensFlares.push(object);}else if(object.isImmediateRenderObject){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}currentRenderList.push(object,null,object.material,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){object.skeleton.update();}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,_vector3.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,_vector3.z,null);}}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){projectObject(children[i],camera,sortObjects);}}function renderObjects(renderList,scene,camera,overrideMaterial){for(var i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===undefined?renderItem.material:overrideMaterial;var group=renderItem.group;object.onBeforeRender(_this,scene,camera,geometry,material,group);if(camera.isArrayCamera&&camera.enabled){var cameras=camera.cameras;for(var j=0,jl=cameras.length;j<jl;j++){var camera2=cameras[j];var bounds=camera2.bounds;_this.setViewport(bounds.x*_width*_pixelRatio,bounds.y*_height*_pixelRatio,bounds.z*_width*_pixelRatio,bounds.w*_height*_pixelRatio);_this.setScissor(bounds.x*_width*_pixelRatio,bounds.y*_height*_pixelRatio,bounds.z*_width*_pixelRatio,bounds.w*_height*_pixelRatio);_this.setScissorTest(true);renderObject(object,scene,camera2,geometry,material,group);}}else{renderObject(object,scene,camera,geometry,material,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}}function renderObject(object,scene,camera,geometry,material,group){object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);if(object.isImmediateRenderObject){state.setMaterial(material);var program=setProgram(camera,scene.fog,material,object);_currentGeometryProgram='';renderObjectImmediate(object,program,material);}else{_this.renderBufferDirect(camera,scene.fog,geometry,material,object,group);}}function initMaterial(material,fog,object){var materialProperties=properties.get(material);var parameters=programCache.getParameters(material,_lights,fog,_clipping.numPlanes,_clipping.numIntersection,object);var code=programCache.getProgramCode(material,parameters);var program=materialProperties.program;var programChange=true;if(program===undefined){// new material
material.addEventListener('dispose',onMaterialDispose);}else if(program.code!==code){// changed glsl or parameters
releaseMaterialProgramReference(material);}else if(parameters.shaderID!==undefined){// same glsl and uniform list
return;}else{// only rebuild uniform list
programChange=false;}if(programChange){if(parameters.shaderID){var shader=ShaderLib[parameters.shaderID];materialProperties.__webglShader={name:material.type,uniforms:UniformsUtils.clone(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader};}else{materialProperties.__webglShader={name:material.type,uniforms:material.uniforms,vertexShader:material.vertexShader,fragmentShader:material.fragmentShader};}material.__webglShader=materialProperties.__webglShader;program=programCache.acquireProgram(material,parameters,code);materialProperties.program=program;material.program=program;}var programAttributes=program.getAttributes();if(material.morphTargets){material.numSupportedMorphTargets=0;for(var i=0;i<_this.maxMorphTargets;i++){if(programAttributes['morphTarget'+i]>=0){material.numSupportedMorphTargets++;}}}if(material.morphNormals){material.numSupportedMorphNormals=0;for(var i=0;i<_this.maxMorphNormals;i++){if(programAttributes['morphNormal'+i]>=0){material.numSupportedMorphNormals++;}}}var uniforms=materialProperties.__webglShader.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){materialProperties.numClippingPlanes=_clipping.numPlanes;materialProperties.numIntersection=_clipping.numIntersection;uniforms.clippingPlanes=_clipping.uniform;}materialProperties.fog=fog;// store the light setup it was created for
materialProperties.lightsHash=_lights.hash;if(material.lights){// wire up the material to this renderer's lighting state
uniforms.ambientLightColor.value=_lights.ambient;uniforms.directionalLights.value=_lights.directional;uniforms.spotLights.value=_lights.spot;uniforms.rectAreaLights.value=_lights.rectArea;uniforms.pointLights.value=_lights.point;uniforms.hemisphereLights.value=_lights.hemi;uniforms.directionalShadowMap.value=_lights.directionalShadowMap;uniforms.directionalShadowMatrix.value=_lights.directionalShadowMatrix;uniforms.spotShadowMap.value=_lights.spotShadowMap;uniforms.spotShadowMatrix.value=_lights.spotShadowMatrix;uniforms.pointShadowMap.value=_lights.pointShadowMap;uniforms.pointShadowMatrix.value=_lights.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
}var progUniforms=materialProperties.program.getUniforms(),uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.uniformsList=uniformsList;}function setProgram(camera,fog,material,object){_usedTextureUnits=0;var materialProperties=properties.get(material);if(_clippingEnabled){if(_localClippingEnabled||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
_clipping.setState(material.clippingPlanes,material.clipIntersection,material.clipShadows,camera,materialProperties,useCache);}}if(material.needsUpdate===false){if(materialProperties.program===undefined){material.needsUpdate=true;}else if(material.fog&&materialProperties.fog!==fog){material.needsUpdate=true;}else if(material.lights&&materialProperties.lightsHash!==_lights.hash){material.needsUpdate=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==_clipping.numPlanes||materialProperties.numIntersection!==_clipping.numIntersection)){material.needsUpdate=true;}}if(material.needsUpdate){initMaterial(material,fog,object);material.needsUpdate=false;}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var program=materialProperties.program,p_uniforms=program.getUniforms(),m_uniforms=materialProperties.__webglShader.uniforms;if(program.id!==_currentProgram){_gl.useProgram(program.program);_currentProgram=program.id;refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||camera!==_currentCamera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(camera!==_currentCamera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
refreshMaterial=true;// set to true on material change
refreshLights=true;// remains set until update done
}// load material specific uniforms
// (shader material also gets them for the sake of genericity)
if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.skinning){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);p_uniforms.setValue(_gl,'toneMappingWhitePoint',_this.toneMappingWhitePoint);}// skinning uniforms must be set even if material didn't change
// auto-setting of texture unit for bone texture must go before other textures
// not sure why, but otherwise weird things happen
if(material.skinning){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){var bones=skeleton.bones;if(capabilities.floatVertexTextures){if(skeleton.boneTexture===undefined){// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
var size=Math.sqrt(bones.length*4);// 4 pixels needed for 1 matrix
size=_Math.nextPowerOfTwo(Math.ceil(size));size=Math.max(size,4);var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
boneMatrices.set(skeleton.boneMatrices);// copy current values
var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);skeleton.boneMatrices=boneMatrices;skeleton.boneTexture=boneTexture;skeleton.boneTextureSize=size;}p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else{p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(refreshMaterial){if(material.lights){// the current material requires lighting info
// note: all lighting uniforms are always set correctly
// they simply reference the renderer's state for their
// values
//
// use the current material's .needsUpdate flags to set
// the GL state when required
markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
if(fog&&material.fog){refreshUniformsFog(m_uniforms,fog);}if(material.isMeshBasicMaterial||material.isMeshLambertMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isMeshNormalMaterial||material.isMeshDepthMaterial){refreshUniformsCommon(m_uniforms,material);}// refresh single material specific uniforms
if(material.isLineBasicMaterial){refreshUniformsLine(m_uniforms,material);}else if(material.isLineDashedMaterial){refreshUniformsLine(m_uniforms,material);refreshUniformsDash(m_uniforms,material);}else if(material.isPointsMaterial){refreshUniformsPoints(m_uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsLambert(m_uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsToon(m_uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsPhong(m_uniforms,material);}else if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(m_uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsStandard(m_uniforms,material);}else if(material.isMeshDepthMaterial){if(material.displacementMap){m_uniforms.displacementMap.value=material.displacementMap;m_uniforms.displacementScale.value=material.displacementScale;m_uniforms.displacementBias.value=material.displacementBias;}}else if(material.isMeshNormalMaterial){refreshUniformsNormal(m_uniforms,material);}// RectAreaLight Texture
// TODO (mrdoob): Find a nicer implementation
if(m_uniforms.ltcMat!==undefined)m_uniforms.ltcMat.value=UniformsLib.LTC_MAT_TEXTURE;if(m_uniforms.ltcMag!==undefined)m_uniforms.ltcMag.value=UniformsLib.LTC_MAG_TEXTURE;WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,_this);}// common matrices
p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// Uniforms (refresh uniforms objects)
function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;uniforms.diffuse.value=material.color;if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}uniforms.map.value=material.map;uniforms.specularMap.value=material.specularMap;uniforms.alphaMap.value=material.alphaMap;if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
// 1. color map
// 2. specular map
// 3. normal map
// 4. bump map
// 5. alpha map
// 6. emissive map
var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}if(uvScaleMap!==undefined){// backwards compatibility
if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}var offset=uvScaleMap.offset;var repeat=uvScaleMap.repeat;uniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);}uniforms.envMap.value=material.envMap;// don't flip CubeTexture envMaps, flip everything else:
//  WebGLRenderTargetCube will be flipped for backwards compatibility
//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
uniforms.flipEnvMap.value=!(material.envMap&&material.envMap.isCubeTexture)?1:-1;uniforms.reflectivity.value=material.reflectivity;uniforms.refractionRatio.value=material.refractionRatio;}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*_pixelRatio;uniforms.scale.value=_height*0.5;uniforms.map.value=material.map;if(material.map!==null){var offset=material.map.offset;var repeat=material.map.repeat;uniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);}}function refreshUniformsFog(uniforms,fog){uniforms.fogColor.value=fog.color;if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value=material.specular;uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){refreshUniformsPhong(uniforms,material);if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material){uniforms.clearCoat.value=material.clearCoat;uniforms.clearCoatRoughness.value=material.clearCoatRoughness;refreshUniformsStandard(uniforms,material);}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}// Lighting
function setupShadows(lights){var lightShadowsLength=0;for(var i=0,l=lights.length;i<l;i++){var light=lights[i];if(light.castShadow){_lights.shadows[lightShadowsLength]=light;lightShadowsLength++;}}_lights.shadows.length=lightShadowsLength;}function setupLights(lights,camera){var l,ll,light,shadow,r=0,g=0,b=0,color,intensity,distance,shadowMap,viewMatrix=camera.matrixWorldInverse,directionalLength=0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0;for(l=0,ll=lights.length;l<ll;l++){light=lights[l];color=light.color;intensity=light.intensity;distance=light.distance;shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isDirectionalLight){var uniforms=lightCache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.direction.setFromMatrixPosition(light.matrixWorld);_vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(_vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.shadow=light.castShadow;if(light.castShadow){shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}_lights.directionalShadowMap[directionalLength]=shadowMap;_lights.directionalShadowMatrix[directionalLength]=light.shadow.matrix;_lights.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var uniforms=lightCache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.direction.setFromMatrixPosition(light.matrixWorld);_vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(_vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}_lights.spotShadowMap[spotLength]=shadowMap;_lights.spotShadowMatrix[spotLength]=light.shadow.matrix;_lights.spot[spotLength]=uniforms;spotLength++;}else if(light.isRectAreaLight){var uniforms=lightCache.get(light);// (a) intensity controls irradiance of entire light
uniforms.color.copy(color).multiplyScalar(intensity/(light.width*light.height));// (b) intensity controls the radiance per light area
// uniforms.color.copy( color ).multiplyScalar( intensity );
uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
_matrix42.identity();_matrix4.copy(light.matrixWorld);_matrix4.premultiply(viewMatrix);_matrix42.extractRotation(_matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(_matrix42);uniforms.halfHeight.applyMatrix4(_matrix42);// TODO (abelnation): RectAreaLight distance?
// uniforms.distance = distance;
_lights.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){var uniforms=lightCache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}_lights.pointShadowMap[pointLength]=shadowMap;_lights.pointShadowMatrix[pointLength]=light.shadow.matrix;_lights.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){var uniforms=lightCache.get(light);uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);uniforms.direction.normalize();uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);_lights.hemi[hemiLength]=uniforms;hemiLength++;}}_lights.ambient[0]=r;_lights.ambient[1]=g;_lights.ambient[2]=b;_lights.directional.length=directionalLength;_lights.spot.length=spotLength;_lights.rectArea.length=rectAreaLength;_lights.point.length=pointLength;_lights.hemi.length=hemiLength;// TODO (sam-g-steel) why aren't we using join
_lights.hash=directionalLength+','+pointLength+','+spotLength+','+rectAreaLength+','+hemiLength+','+_lights.shadows.length;}// GL state setting
this.setFaceCulling=function(cullFace,frontFaceDirection){state.setCullFace(cullFace);state.setFlipSided(frontFaceDirection===FrontFaceDirectionCW);};// Textures
function allocTextureUnit(){var textureUnit=_usedTextureUnits;if(textureUnit>=capabilities.maxTextures){console.warn('WebGLRenderer: trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);}_usedTextureUnits+=1;return textureUnit;}this.allocTextureUnit=allocTextureUnit;// this.setTexture2D = setTexture2D;
this.setTexture2D=function(){var warned=false;// backwards compatibility: peel texture.texture
return function setTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(!warned){console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}textures.setTexture2D(texture,slot);};}();this.setTexture=function(){var warned=false;return function setTexture(texture,slot){if(!warned){console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");warned=true;}textures.setTexture2D(texture,slot);};}();this.setTextureCube=function(){var warned=false;return function setTextureCube(texture,slot){// backwards compatibility: peel texture.texture
if(texture&&texture.isWebGLRenderTargetCube){if(!warned){console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
// TODO: unify these code paths
if(texture&&texture.isCubeTexture||Array.isArray(texture.image)&&texture.image.length===6){// CompressedTexture can have Array in image :/
// this function alone should take care of cube textures
textures.setTextureCube(texture,slot);}else{// assumed: texture property of THREE.WebGLRenderTargetCube
textures.setTextureCubeDynamic(texture,slot);}};}();this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget){_currentRenderTarget=renderTarget;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;var framebuffer;if(renderTarget){var renderTargetProperties=properties.get(renderTarget);if(isCube){framebuffer=renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];}else{framebuffer=renderTargetProperties.__webglFramebuffer;}_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;_currentViewport.copy(renderTarget.viewport);}else{framebuffer=null;_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);_currentScissorTest=_scissorTest;_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);}if(_currentFramebuffer!==framebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_currentFramebuffer=framebuffer;}state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);state.viewport(_currentViewport);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+renderTarget.activeCubeFace,textureProperties.__webglTexture,renderTarget.activeMipMapLevel);}};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer){if((renderTarget&&renderTarget.isWebGLRenderTarget)===false){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(framebuffer){var restore=false;if(framebuffer!==_currentFramebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);restore=true;}try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&paramThreeToGL(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(textureType!==UnsignedByteType&&paramThreeToGL(textureType)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// IE11, Edge and Chrome Mac < 52 (#9513)
!(textureType===FloatType&&(extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
!(textureType===HalfFloatType&&extensions.get('EXT_color_buffer_half_float'))){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(_gl.FRAMEBUFFER)===_gl.FRAMEBUFFER_COMPLETE){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,paramThreeToGL(textureFormat),paramThreeToGL(textureType),buffer);}}else{console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{if(restore){_gl.bindFramebuffer(_gl.FRAMEBUFFER,_currentFramebuffer);}}}};// Map three.js constants to WebGL constants
function paramThreeToGL(p){var extension;if(p===RepeatWrapping)return _gl.REPEAT;if(p===ClampToEdgeWrapping)return _gl.CLAMP_TO_EDGE;if(p===MirroredRepeatWrapping)return _gl.MIRRORED_REPEAT;if(p===NearestFilter)return _gl.NEAREST;if(p===NearestMipMapNearestFilter)return _gl.NEAREST_MIPMAP_NEAREST;if(p===NearestMipMapLinearFilter)return _gl.NEAREST_MIPMAP_LINEAR;if(p===LinearFilter)return _gl.LINEAR;if(p===LinearMipMapNearestFilter)return _gl.LINEAR_MIPMAP_NEAREST;if(p===LinearMipMapLinearFilter)return _gl.LINEAR_MIPMAP_LINEAR;if(p===UnsignedByteType)return _gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return _gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return _gl.UNSIGNED_SHORT_5_5_5_1;if(p===UnsignedShort565Type)return _gl.UNSIGNED_SHORT_5_6_5;if(p===ByteType)return _gl.BYTE;if(p===ShortType)return _gl.SHORT;if(p===UnsignedShortType)return _gl.UNSIGNED_SHORT;if(p===IntType)return _gl.INT;if(p===UnsignedIntType)return _gl.UNSIGNED_INT;if(p===FloatType)return _gl.FLOAT;if(p===HalfFloatType){extension=extensions.get('OES_texture_half_float');if(extension!==null)return extension.HALF_FLOAT_OES;}if(p===AlphaFormat)return _gl.ALPHA;if(p===RGBFormat)return _gl.RGB;if(p===RGBAFormat)return _gl.RGBA;if(p===LuminanceFormat)return _gl.LUMINANCE;if(p===LuminanceAlphaFormat)return _gl.LUMINANCE_ALPHA;if(p===DepthFormat)return _gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return _gl.DEPTH_STENCIL;if(p===AddEquation)return _gl.FUNC_ADD;if(p===SubtractEquation)return _gl.FUNC_SUBTRACT;if(p===ReverseSubtractEquation)return _gl.FUNC_REVERSE_SUBTRACT;if(p===ZeroFactor)return _gl.ZERO;if(p===OneFactor)return _gl.ONE;if(p===SrcColorFactor)return _gl.SRC_COLOR;if(p===OneMinusSrcColorFactor)return _gl.ONE_MINUS_SRC_COLOR;if(p===SrcAlphaFactor)return _gl.SRC_ALPHA;if(p===OneMinusSrcAlphaFactor)return _gl.ONE_MINUS_SRC_ALPHA;if(p===DstAlphaFactor)return _gl.DST_ALPHA;if(p===OneMinusDstAlphaFactor)return _gl.ONE_MINUS_DST_ALPHA;if(p===DstColorFactor)return _gl.DST_COLOR;if(p===OneMinusDstColorFactor)return _gl.ONE_MINUS_DST_COLOR;if(p===SrcAlphaSaturateFactor)return _gl.SRC_ALPHA_SATURATE;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null)return extension.COMPRESSED_RGB_ETC1_WEBGL;}if(p===MinEquation||p===MaxEquation){extension=extensions.get('EXT_blend_minmax');if(extension!==null){if(p===MinEquation)return extension.MIN_EXT;if(p===MaxEquation)return extension.MAX_EXT;}}if(p===UnsignedInt248Type){extension=extensions.get('WEBGL_depth_texture');if(extension!==null)return extension.UNSIGNED_INT_24_8_WEBGL;}return 0;}}/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function FogExp2(color,density){this.name='';this.color=new Color(color);this.density=density!==undefined?density:0.00025;}FogExp2.prototype.isFogExp2=true;FogExp2.prototype.clone=function(){return new FogExp2(this.color.getHex(),this.density);};FogExp2.prototype.toJSON=function(meta){return{type:'FogExp2',color:this.color.getHex(),density:this.density};};/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function Fog(color,near,far){this.name='';this.color=new Color(color);this.near=near!==undefined?near:1;this.far=far!==undefined?far:1000;}Fog.prototype.isFog=true;Fog.prototype.clone=function(){return new Fog(this.color.getHex(),this.near,this.far);};Fog.prototype.toJSON=function(meta){return{type:'Fog',color:this.color.getHex(),near:this.near,far:this.far};};/**
 * @author mrdoob / http://mrdoob.com/
 */function Scene(){Object3D.call(this);this.type='Scene';this.background=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
}Scene.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Scene,copy:function(source,recursive){Object3D.prototype.copy.call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);if(this.background!==null)data.object.background=this.background.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */function LensFlare(texture,size,distance,blending,color){Object3D.call(this);this.lensFlares=[];this.positionScreen=new Vector3();this.customUpdateCallback=undefined;if(texture!==undefined){this.add(texture,size,distance,blending,color);}}LensFlare.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:LensFlare,isLensFlare:true,copy:function(source){Object3D.prototype.copy.call(this,source);this.positionScreen.copy(source.positionScreen);this.customUpdateCallback=source.customUpdateCallback;for(var i=0,l=source.lensFlares.length;i<l;i++){this.lensFlares.push(source.lensFlares[i]);}return this;},add:function(texture,size,distance,blending,color,opacity){if(size===undefined)size=-1;if(distance===undefined)distance=0;if(opacity===undefined)opacity=1;if(color===undefined)color=new Color(0xffffff);if(blending===undefined)blending=NormalBlending;distance=Math.min(distance,Math.max(0,distance));this.lensFlares.push({texture:texture,// THREE.Texture
size:size,// size in pixels (-1 = use texture.width)
distance:distance,// distance (0-1) from light source (0=at light source)
x:0,y:0,z:0,// screen position (-1 => 1) z = 0 is in front z = 1 is back
scale:1,// scale
rotation:0,// rotation
opacity:opacity,// opacity
color:color,// color
blending:blending// blending
});},/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */updateLensFlares:function(){var f,fl=this.lensFlares.length;var flare;var vecX=-this.positionScreen.x*2;var vecY=-this.positionScreen.y*2;for(f=0;f<fl;f++){flare=this.lensFlares[f];flare.x=this.positionScreen.x+vecX*flare.distance;flare.y=this.positionScreen.y+vecY*flare.distance;flare.wantedRotation=flare.x*Math.PI*0.25;flare.rotation+=(flare.wantedRotation-flare.rotation)*0.25;}}});/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2()
 * }
 */function SpriteMaterial(parameters){Material.call(this);this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.rotation=0;this.fog=false;this.lights=false;this.setValues(parameters);}SpriteMaterial.prototype=Object.create(Material.prototype);SpriteMaterial.prototype.constructor=SpriteMaterial;SpriteMaterial.prototype.isSpriteMaterial=true;SpriteMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.rotation=source.rotation;return this;};/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */function Sprite(material){Object3D.call(this);this.type='Sprite';this.material=material!==undefined?material:new SpriteMaterial();}Sprite.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Sprite,isSprite:true,raycast:function(){var intersectPoint=new Vector3();var worldPosition=new Vector3();var worldScale=new Vector3();return function raycast(raycaster,intersects){worldPosition.setFromMatrixPosition(this.matrixWorld);raycaster.ray.closestPointToPoint(worldPosition,intersectPoint);worldScale.setFromMatrixScale(this.matrixWorld);var guessSizeSq=worldScale.x*worldScale.y/4;if(worldPosition.distanceToSquared(intersectPoint)>guessSizeSq)return;var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:intersectPoint.clone(),face:null,object:this});};}(),clone:function(){return new this.constructor(this.material).copy(this);}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */function LOD(){Object3D.call(this);this.type='LOD';Object.defineProperties(this,{levels:{enumerable:true,value:[]}});}LOD.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:LOD,copy:function(source){Object3D.prototype.copy.call(this,source,false);var levels=source.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];this.addLevel(level.object.clone(),level.distance);}return this;},addLevel:function(object,distance){if(distance===undefined)distance=0;distance=Math.abs(distance);var levels=this.levels;for(var l=0;l<levels.length;l++){if(distance<levels[l].distance){break;}}levels.splice(l,0,{distance:distance,object:object});this.add(object);},getObjectForDistance:function(distance){var levels=this.levels;for(var i=1,l=levels.length;i<l;i++){if(distance<levels[i].distance){break;}}return levels[i-1].object;},raycast:function(){var matrixPosition=new Vector3();return function raycast(raycaster,intersects){matrixPosition.setFromMatrixPosition(this.matrixWorld);var distance=raycaster.ray.origin.distanceTo(matrixPosition);this.getObjectForDistance(distance).raycast(raycaster,intersects);};}(),update:function(){var v1=new Vector3();var v2=new Vector3();return function update(camera){var levels=this.levels;if(levels.length>1){v1.setFromMatrixPosition(camera.matrixWorld);v2.setFromMatrixPosition(this.matrixWorld);var distance=v1.distanceTo(v2);levels[0].object.visible=true;for(var i=1,l=levels.length;i<l;i++){if(distance>=levels[i].distance){levels[i-1].object.visible=false;levels[i].object.visible=true;}else{break;}}for(;i<l;i++){levels[i].object.visible=false;}}};}(),toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.levels=[];var levels=this.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];data.object.levels.push({object:level.object.uuid,distance:level.distance});}return data;}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */function Skeleton(bones,boneInverses){// copy the bone array
bones=bones||[];this.bones=bones.slice(0);this.boneMatrices=new Float32Array(this.bones.length*16);// use the supplied bone inverses or calculate the inverses
if(boneInverses===undefined){this.calculateInverses();}else{if(this.bones.length===boneInverses.length){this.boneInverses=boneInverses.slice(0);}else{console.warn('THREE.Skeleton boneInverses is the wrong length.');this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){this.boneInverses.push(new Matrix4());}}}}Object.assign(Skeleton.prototype,{calculateInverses:function(){this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){var inverse=new Matrix4();if(this.bones[i]){inverse.getInverse(this.bones[i].matrixWorld);}this.boneInverses.push(inverse);}},pose:function(){var bone,i,il;// recover the bind-time world matrices
for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){bone.matrixWorld.getInverse(this.boneInverses[i]);}}// compute the local matrices, positions, rotations and scales
for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){if(bone.parent&&bone.parent.isBone){bone.matrix.getInverse(bone.parent.matrixWorld);bone.matrix.multiply(bone.matrixWorld);}else{bone.matrix.copy(bone.matrixWorld);}bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);}}},update:function(){var offsetMatrix=new Matrix4();var identityMatrix=new Matrix4();return function update(){var bones=this.bones;var boneInverses=this.boneInverses;var boneMatrices=this.boneMatrices;var boneTexture=this.boneTexture;// flatten bone matrices to array
for(var i=0,il=bones.length;i<il;i++){// compute the offset between the current and the original transform
var matrix=bones[i]?bones[i].matrixWorld:identityMatrix;offsetMatrix.multiplyMatrices(matrix,boneInverses[i]);offsetMatrix.toArray(boneMatrices,i*16);}if(boneTexture!==undefined){boneTexture.needsUpdate=true;}};}(),clone:function(){return new Skeleton(this.bones,this.boneInverses);}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */function Bone(){Object3D.call(this);this.type='Bone';}Bone.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Bone,isBone:true});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */function SkinnedMesh(geometry,material){Mesh.call(this,geometry,material);this.type='SkinnedMesh';this.bindMode='attached';this.bindMatrix=new Matrix4();this.bindMatrixInverse=new Matrix4();var bones=this.initBones();var skeleton=new Skeleton(bones);this.bind(skeleton,this.matrixWorld);this.normalizeSkinWeights();}SkinnedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{constructor:SkinnedMesh,isSkinnedMesh:true,initBones:function(){var bones=[],bone,gbone;var i,il;if(this.geometry&&this.geometry.bones!==undefined){// first, create array of 'Bone' objects from geometry data
for(i=0,il=this.geometry.bones.length;i<il;i++){gbone=this.geometry.bones[i];// create new 'Bone' object
bone=new Bone();bones.push(bone);// apply values
bone.name=gbone.name;bone.position.fromArray(gbone.pos);bone.quaternion.fromArray(gbone.rotq);if(gbone.scl!==undefined)bone.scale.fromArray(gbone.scl);}// second, create bone hierarchy
for(i=0,il=this.geometry.bones.length;i<il;i++){gbone=this.geometry.bones[i];if(gbone.parent!==-1&&gbone.parent!==null&&bones[gbone.parent]!==undefined){// subsequent bones in the hierarchy
bones[gbone.parent].add(bones[i]);}else{// topmost bone, immediate child of the skinned mesh
this.add(bones[i]);}}}// now the bones are part of the scene graph and children of the skinned mesh.
// let's update the corresponding matrices
this.updateMatrixWorld(true);return bones;},bind:function(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.getInverse(bindMatrix);},pose:function(){this.skeleton.pose();},normalizeSkinWeights:function(){var scale,i;if(this.geometry&&this.geometry.isGeometry){for(i=0;i<this.geometry.skinWeights.length;i++){var sw=this.geometry.skinWeights[i];scale=1.0/sw.lengthManhattan();if(scale!==Infinity){sw.multiplyScalar(scale);}else{sw.set(1,0,0,0);// do something reasonable
}}}else if(this.geometry&&this.geometry.isBufferGeometry){var vec=new Vector4();var skinWeight=this.geometry.attributes.skinWeight;for(i=0;i<skinWeight.count;i++){vec.x=skinWeight.getX(i);vec.y=skinWeight.getY(i);vec.z=skinWeight.getZ(i);vec.w=skinWeight.getW(i);scale=1.0/vec.lengthManhattan();if(scale!==Infinity){vec.multiplyScalar(scale);}else{vec.set(1,0,0,0);// do something reasonable
}skinWeight.setXYZW(i,vec.x,vec.y,vec.z,vec.w);}}},updateMatrixWorld:function(force){Mesh.prototype.updateMatrixWorld.call(this,force);if(this.bindMode==='attached'){this.bindMatrixInverse.getInverse(this.matrixWorld);}else if(this.bindMode==='detached'){this.bindMatrixInverse.getInverse(this.bindMatrix);}else{console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);}},clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */function LineBasicMaterial(parameters){Material.call(this);this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.lights=false;this.setValues(parameters);}LineBasicMaterial.prototype=Object.create(Material.prototype);LineBasicMaterial.prototype.constructor=LineBasicMaterial;LineBasicMaterial.prototype.isLineBasicMaterial=true;LineBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 */function Line(geometry,material,mode){if(mode===1){console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');return new LineSegments(geometry,material);}Object3D.call(this);this.type='Line';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new LineBasicMaterial({color:Math.random()*0xffffff});}Line.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Line,isLine:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var precision=raycaster.linePrecision;var precisionSq=precision*precision;var geometry=this.geometry;var matrixWorld=this.matrixWorld;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this&&this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,l=indices.length-1;i<l;i+=step){var a=indices[i];var b=indices[i+1];vStart.fromArray(positions,a*3);vEnd.fromArray(positions,b*3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}else{for(var i=0,l=positions.length/3-1;i<l;i+=step){vStart.fromArray(positions,3*i);vEnd.fromArray(positions,3*i+3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){var vertices=geometry.vertices;var nbVertices=vertices.length;for(var i=0;i<nbVertices-1;i+=step){var distSq=ray.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}};}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 */function LineSegments(geometry,material){Line.call(this,geometry,material);this.type='LineSegments';}LineSegments.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineSegments,isLineSegments:true});/**
 * @author mgreter / http://github.com/mgreter
 */function LineLoop(geometry,material){Line.call(this,geometry,material);this.type='LineLoop';}LineLoop.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineLoop,isLineLoop:true});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 * }
 */function PointsMaterial(parameters){Material.call(this);this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.size=1;this.sizeAttenuation=true;this.lights=false;this.setValues(parameters);}PointsMaterial.prototype=Object.create(Material.prototype);PointsMaterial.prototype.constructor=PointsMaterial;PointsMaterial.prototype.isPointsMaterial=true;PointsMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;};/**
 * @author alteredq / http://alteredqualia.com/
 */function Points(geometry,material){Object3D.call(this);this.type='Points';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new PointsMaterial({color:Math.random()*0xffffff});}Points.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Points,isPoints:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var object=this;var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);sphere.radius+=threshold;if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var position=new Vector3();function testPoint(point,index){var rayPointDistanceSq=ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){var intersectPoint=ray.closestPointToPoint(point);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint.clone(),index:index,face:null,object:object});}}if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,il=indices.length;i<il;i++){var a=indices[i];position.fromArray(positions,a*3);testPoint(position,a);}}else{for(var i=0,l=positions.length/3;i<l;i++){position.fromArray(positions,i*3);testPoint(position,i);}}}else{var vertices=geometry.vertices;for(var i=0,l=vertices.length;i<l;i++){testPoint(vertices[i],i);}}};}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 */function Group(){Object3D.call(this);this.type='Group';}Group.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Group});/**
 * @author mrdoob / http://mrdoob.com/
 */function VideoTexture(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.generateMipmaps=false;var scope=this;function update(){requestAnimationFrame(update);if(video.readyState>=video.HAVE_CURRENT_DATA){scope.needsUpdate=true;}}update();}VideoTexture.prototype=Object.create(Texture.prototype);VideoTexture.prototype.constructor=VideoTexture;/**
 * @author alteredq / http://alteredqualia.com/
 */function CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={width:width,height:height};this.mipmaps=mipmaps;// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=false;// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=false;}CompressedTexture.prototype=Object.create(Texture.prototype);CompressedTexture.prototype.constructor=CompressedTexture;CompressedTexture.prototype.isCompressedTexture=true;/**
 * @author mrdoob / http://mrdoob.com/
 */function CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=true;}CanvasTexture.prototype=Object.create(Texture.prototype);CanvasTexture.prototype.constructor=CanvasTexture;/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;}DepthTexture.prototype=Object.create(Texture.prototype);DepthTexture.prototype.constructor=DepthTexture;DepthTexture.prototype.isDepthTexture=true;/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */function WireframeGeometry(geometry){BufferGeometry.call(this);this.type='WireframeGeometry';// buffer
var vertices=[];// helper variables
var i,j,l,o,ol;var edge=[0,0],edges={},e,edge1,edge2;var key,keys=['a','b','c'];var vertex;// different logic for Geometry and BufferGeometry
if(geometry&&geometry.isGeometry){// create a data structure that contains all edges without duplicates
var faces=geometry.faces;for(i=0,l=faces.length;i<l;i++){var face=faces[i];for(j=0;j<3;j++){edge1=face[keys[j]];edge2=face[keys[(j+1)%3]];edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1]};}}}// generate vertices
for(key in edges){e=edges[key];vertex=geometry.vertices[e.index1];vertices.push(vertex.x,vertex.y,vertex.z);vertex=geometry.vertices[e.index2];vertices.push(vertex.x,vertex.y,vertex.z);}}else if(geometry&&geometry.isBufferGeometry){var position,indices,groups;var group,start,count;var index1,index2;vertex=new Vector3();if(geometry.index!==null){// indexed BufferGeometry
position=geometry.attributes.position;indices=geometry.index;groups=geometry.groups;if(groups.length===0){groups=[{start:0,count:indices.count,materialIndex:0}];}// create a data structure that contains all eges without duplicates
for(o=0,ol=groups.length;o<ol;++o){group=groups[o];start=group.start;count=group.count;for(i=start,l=start+count;i<l;i+=3){for(j=0;j<3;j++){edge1=indices.getX(i+j);edge2=indices.getX(i+(j+1)%3);edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1]};}}}}// generate vertices
for(key in edges){e=edges[key];vertex.fromBufferAttribute(position,e.index1);vertices.push(vertex.x,vertex.y,vertex.z);vertex.fromBufferAttribute(position,e.index2);vertices.push(vertex.x,vertex.y,vertex.z);}}else{// non-indexed BufferGeometry
position=geometry.attributes.position;for(i=0,l=position.count/3;i<l;i++){for(j=0;j<3;j++){// three edges per triangle, an edge is represented as (index1, index2)
// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
index1=3*i+j;vertex.fromBufferAttribute(position,index1);vertices.push(vertex.x,vertex.y,vertex.z);index2=3*i+(j+1)%3;vertex.fromBufferAttribute(position,index2);vertices.push(vertex.x,vertex.y,vertex.z);}}}}// build geometry
this.addAttribute('position',new Float32BufferAttribute(vertices,3));}WireframeGeometry.prototype=Object.create(BufferGeometry.prototype);WireframeGeometry.prototype.constructor=WireframeGeometry;/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */// ParametricGeometry
function ParametricGeometry(func,slices,stacks){Geometry.call(this);this.type='ParametricGeometry';this.parameters={func:func,slices:slices,stacks:stacks};this.fromBufferGeometry(new ParametricBufferGeometry(func,slices,stacks));this.mergeVertices();}ParametricGeometry.prototype=Object.create(Geometry.prototype);ParametricGeometry.prototype.constructor=ParametricGeometry;// ParametricBufferGeometry
function ParametricBufferGeometry(func,slices,stacks){BufferGeometry.call(this);this.type='ParametricBufferGeometry';this.parameters={func:func,slices:slices,stacks:stacks};// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];var EPS=0.00001;var normal=new Vector3();var p0=new Vector3(),p1=new Vector3();var pu=new Vector3(),pv=new Vector3();var i,j;// generate vertices, normals and uvs
var sliceCount=slices+1;for(i=0;i<=stacks;i++){var v=i/stacks;for(j=0;j<=slices;j++){var u=j/slices;// vertex
p0=func(u,v,p0);vertices.push(p0.x,p0.y,p0.z);// normal
// approximate tangent vectors via finite differences
if(u-EPS>=0){p1=func(u-EPS,v,p1);pu.subVectors(p0,p1);}else{p1=func(u+EPS,v,p1);pu.subVectors(p1,p0);}if(v-EPS>=0){p1=func(u,v-EPS,p1);pv.subVectors(p0,p1);}else{p1=func(u,v+EPS,p1);pv.subVectors(p1,p0);}// cross product of tangent vectors returns surface normal
normal.crossVectors(pu,pv).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,v);}}// generate indices
for(i=0;i<stacks;i++){for(j=0;j<slices;j++){var a=i*sliceCount+j;var b=i*sliceCount+j+1;var c=(i+1)*sliceCount+j+1;var d=(i+1)*sliceCount+j;// faces one and two
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}ParametricBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */// PolyhedronGeometry
function PolyhedronGeometry(vertices,indices,radius,detail){Geometry.call(this);this.type='PolyhedronGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices,indices,radius,detail));this.mergeVertices();}PolyhedronGeometry.prototype=Object.create(Geometry.prototype);PolyhedronGeometry.prototype.constructor=PolyhedronGeometry;// PolyhedronBufferGeometry
function PolyhedronBufferGeometry(vertices,indices,radius,detail){BufferGeometry.call(this);this.type='PolyhedronBufferGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};radius=radius||1;detail=detail||0;// default buffer data
var vertexBuffer=[];var uvBuffer=[];// the subdivision creates the vertex buffer data
subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
appplyRadius(radius);// finally, create the uv data
generateUVs();// build non-indexed geometry
this.addAttribute('position',new Float32BufferAttribute(vertexBuffer,3));this.addAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));this.addAttribute('uv',new Float32BufferAttribute(uvBuffer,2));this.normalizeNormals();// helper functions
function subdivide(detail){var a=new Vector3();var b=new Vector3();var c=new Vector3();// iterate over all faces and apply a subdivison with the given detail value
for(var i=0;i<indices.length;i+=3){// get the vertices of the face
getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);// perform subdivision
subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){var cols=Math.pow(2,detail);// we use this multidimensional array as a data structure for creating the subdivision
var v=[];var i,j;// construct all of the vertices for this subdivision
for(i=0;i<=cols;i++){v[i]=[];var aj=a.clone().lerp(c,i/cols);var bj=b.clone().lerp(c,i/cols);var rows=cols-i;for(j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj;}else{v[i][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
for(i=0;i<cols;i++){for(j=0;j<2*(cols-i)-1;j++){var k=Math.floor(j/2);if(j%2===0){pushVertex(v[i][k+1]);pushVertex(v[i+1][k]);pushVertex(v[i][k]);}else{pushVertex(v[i][k+1]);pushVertex(v[i+1][k+1]);pushVertex(v[i+1][k]);}}}}function appplyRadius(radius){var vertex=new Vector3();// iterate over the entire buffer and apply the radius to each vertex
for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z;}}function generateUVs(){var vertex=new Vector3();for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];var u=azimuth(vertex)/2/Math.PI+0.5;var v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
for(var i=0;i<uvBuffer.length;i+=6){// uv data of a single face
var x0=uvBuffer[i+0];var x1=uvBuffer[i+2];var x2=uvBuffer[i+4];var max=Math.max(x0,x1,x2);var min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[i+0]+=1;if(x1<0.2)uvBuffer[i+2]+=1;if(x2<0.2)uvBuffer[i+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){var stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){var a=new Vector3();var b=new Vector3();var c=new Vector3();var centroid=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();for(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);var azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}}PolyhedronBufferGeometry.prototype=Object.create(BufferGeometry.prototype);PolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry;/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */// TetrahedronGeometry
function TetrahedronGeometry(radius,detail){Geometry.call(this);this.type='TetrahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new TetrahedronBufferGeometry(radius,detail));this.mergeVertices();}TetrahedronGeometry.prototype=Object.create(Geometry.prototype);TetrahedronGeometry.prototype.constructor=TetrahedronGeometry;// TetrahedronBufferGeometry
function TetrahedronBufferGeometry(radius,detail){var vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];var indices=[2,1,0,0,3,2,1,3,0,2,3,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='TetrahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}TetrahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);TetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry;/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */// OctahedronGeometry
function OctahedronGeometry(radius,detail){Geometry.call(this);this.type='OctahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new OctahedronBufferGeometry(radius,detail));this.mergeVertices();}OctahedronGeometry.prototype=Object.create(Geometry.prototype);OctahedronGeometry.prototype.constructor=OctahedronGeometry;// OctahedronBufferGeometry
function OctahedronBufferGeometry(radius,detail){var vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];var indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='OctahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}OctahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);OctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry;/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */// IcosahedronGeometry
function IcosahedronGeometry(radius,detail){Geometry.call(this);this.type='IcosahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new IcosahedronBufferGeometry(radius,detail));this.mergeVertices();}IcosahedronGeometry.prototype=Object.create(Geometry.prototype);IcosahedronGeometry.prototype.constructor=IcosahedronGeometry;// IcosahedronBufferGeometry
function IcosahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];var indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='IcosahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}IcosahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);IcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry;/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */// DodecahedronGeometry
function DodecahedronGeometry(radius,detail){Geometry.call(this);this.type='DodecahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new DodecahedronBufferGeometry(radius,detail));this.mergeVertices();}DodecahedronGeometry.prototype=Object.create(Geometry.prototype);DodecahedronGeometry.prototype.constructor=DodecahedronGeometry;// DodecahedronBufferGeometry
function DodecahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var r=1/t;var vertices=[// (±1, ±1, ±1)
-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, ±1/φ, ±φ)
0,-r,-t,0,-r,t,0,r,-t,0,r,t,// (±1/φ, ±φ, 0)
-r,-t,0,-r,t,0,r,-t,0,r,t,0,// (±φ, 0, ±1/φ)
-t,0,-r,t,0,-r,-t,0,r,t,0,r];var indices=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='DodecahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}DodecahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);DodecahedronBufferGeometry.prototype.constructor=DodecahedronBufferGeometry;/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */// TubeGeometry
function TubeGeometry(path,tubularSegments,radius,radialSegments,closed,taper){Geometry.call(this);this.type='TubeGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};if(taper!==undefined)console.warn('THREE.TubeGeometry: taper has been removed.');var bufferGeometry=new TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed);// expose internals
this.tangents=bufferGeometry.tangents;this.normals=bufferGeometry.normals;this.binormals=bufferGeometry.binormals;// create geometry
this.fromBufferGeometry(bufferGeometry);this.mergeVertices();}TubeGeometry.prototype=Object.create(Geometry.prototype);TubeGeometry.prototype.constructor=TubeGeometry;// TubeBufferGeometry
function TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed){BufferGeometry.call(this);this.type='TubeBufferGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};tubularSegments=tubularSegments||64;radius=radius||1;radialSegments=radialSegments||8;closed=closed||false;var frames=path.computeFrenetFrames(tubularSegments,closed);// expose internals
this.tangents=frames.tangents;this.normals=frames.normals;this.binormals=frames.binormals;// helper variables
var vertex=new Vector3();var normal=new Vector3();var uv=new Vector2();var i,j;// buffer
var vertices=[];var normals=[];var uvs=[];var indices=[];// create buffer data
generateBufferData();// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// functions
function generateBufferData(){for(i=0;i<tubularSegments;i++){generateSegment(i);}// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
generateSegment(closed===false?tubularSegments:0);// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries
generateUVs();// finally create faces
generateIndices();}function generateSegment(i){// we use getPointAt to sample evenly distributed points from the given path
var P=path.getPointAt(i/tubularSegments);// retrieve corresponding normal and binormal
var N=frames.normals[i];var B=frames.binormals[i];// generate normals and vertices for the current segment
for(j=0;j<=radialSegments;j++){var v=j/radialSegments*Math.PI*2;var sin=Math.sin(v);var cos=-Math.cos(v);// normal
normal.x=cos*N.x+sin*B.x;normal.y=cos*N.y+sin*B.y;normal.z=cos*N.z+sin*B.z;normal.normalize();normals.push(normal.x,normal.y,normal.z);// vertex
vertex.x=P.x+radius*normal.x;vertex.y=P.y+radius*normal.y;vertex.z=P.z+radius*normal.z;vertices.push(vertex.x,vertex.y,vertex.z);}}function generateIndices(){for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}}function generateUVs(){for(i=0;i<=tubularSegments;i++){for(j=0;j<=radialSegments;j++){uv.x=i/tubularSegments;uv.y=j/radialSegments;uvs.push(uv.x,uv.y);}}}}TubeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);TubeBufferGeometry.prototype.constructor=TubeBufferGeometry;/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */// TorusKnotGeometry
function TorusKnotGeometry(radius,tube,tubularSegments,radialSegments,p,q,heightScale){Geometry.call(this);this.type='TorusKnotGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};if(heightScale!==undefined)console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');this.fromBufferGeometry(new TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q));this.mergeVertices();}TorusKnotGeometry.prototype=Object.create(Geometry.prototype);TorusKnotGeometry.prototype.constructor=TorusKnotGeometry;// TorusKnotBufferGeometry
function TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q){BufferGeometry.call(this);this.type='TorusKnotBufferGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};radius=radius||100;tube=tube||40;tubularSegments=Math.floor(tubularSegments)||64;radialSegments=Math.floor(radialSegments)||8;p=p||2;q=q||3;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var i,j;var vertex=new Vector3();var normal=new Vector3();var P1=new Vector3();var P2=new Vector3();var B=new Vector3();var T=new Vector3();var N=new Vector3();// generate vertices, normals and uvs
for(i=0;i<=tubularSegments;++i){// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
var u=i/tubularSegments*p*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
calculatePositionOnCurve(u,p,q,radius,P1);calculatePositionOnCurve(u+0.01,p,q,radius,P2);// calculate orthonormal basis
T.subVectors(P2,P1);N.addVectors(P2,P1);B.crossVectors(T,N);N.crossVectors(B,T);// normalize B, N. T can be ignored, we don't use it
B.normalize();N.normalize();for(j=0;j<=radialSegments;++j){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
var v=j/radialSegments*Math.PI*2;var cx=-tube*Math.cos(v);var cy=tube*Math.sin(v);// now calculate the final vertex position.
// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
vertex.x=P1.x+(cx*N.x+cy*B.x);vertex.y=P1.y+(cx*N.y+cy*B.y);vertex.z=P1.z+(cx*N.z+cy*B.z);vertices.push(vertex.x,vertex.y,vertex.z);// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
normal.subVectors(vertex,P1).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){// indices
var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// this function calculates the current position on the torus curve
function calculatePositionOnCurve(u,p,q,radius,position){var cu=Math.cos(u);var su=Math.sin(u);var quOverP=q/p*u;var cs=Math.cos(quOverP);position.x=radius*(2+cs)*0.5*cu;position.y=radius*(2+cs)*su*0.5;position.z=radius*Math.sin(quOverP)*0.5;}}TorusKnotBufferGeometry.prototype=Object.create(BufferGeometry.prototype);TorusKnotBufferGeometry.prototype.constructor=TorusKnotBufferGeometry;/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */// TorusGeometry
function TorusGeometry(radius,tube,radialSegments,tubularSegments,arc){Geometry.call(this);this.type='TorusGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};this.fromBufferGeometry(new TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc));this.mergeVertices();}TorusGeometry.prototype=Object.create(Geometry.prototype);TorusGeometry.prototype.constructor=TorusGeometry;// TorusBufferGeometry
function TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc){BufferGeometry.call(this);this.type='TorusBufferGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};radius=radius||100;tube=tube||40;radialSegments=Math.floor(radialSegments)||8;tubularSegments=Math.floor(tubularSegments)||6;arc=arc||Math.PI*2;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var center=new Vector3();var vertex=new Vector3();var normal=new Vector3();var j,i;// generate vertices, normals and uvs
for(j=0;j<=radialSegments;j++){for(i=0;i<=tubularSegments;i++){var u=i/tubularSegments*arc;var v=j/radialSegments*Math.PI*2;// vertex
vertex.x=(radius+tube*Math.cos(v))*Math.cos(u);vertex.y=(radius+tube*Math.cos(v))*Math.sin(u);vertex.z=tube*Math.sin(v);vertices.push(vertex.x,vertex.y,vertex.z);// normal
center.x=radius*Math.cos(u);center.y=radius*Math.sin(u);normal.subVectors(vertex,center).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
for(j=1;j<=radialSegments;j++){for(i=1;i<=tubularSegments;i++){// indices
var a=(tubularSegments+1)*j+i-1;var b=(tubularSegments+1)*(j-1)+i-1;var c=(tubularSegments+1)*(j-1)+i;var d=(tubularSegments+1)*j+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}TorusBufferGeometry.prototype=Object.create(BufferGeometry.prototype);TorusBufferGeometry.prototype.constructor=TorusBufferGeometry;/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */var ShapeUtils={// calculate area of the contour polygon
area:function(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;},triangulate:function(){/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */function snip(contour,u,v,w,n,verts){var p;var ax,ay,bx,by;var cx,cy,px,py;ax=contour[verts[u]].x;ay=contour[verts[u]].y;bx=contour[verts[v]].x;by=contour[verts[v]].y;cx=contour[verts[w]].x;cy=contour[verts[w]].y;if((bx-ax)*(cy-ay)-(by-ay)*(cx-ax)<=0)return false;var aX,aY,bX,bY,cX,cY;var apx,apy,bpx,bpy,cpx,cpy;var cCROSSap,bCROSScp,aCROSSbp;aX=cx-bx;aY=cy-by;bX=ax-cx;bY=ay-cy;cX=bx-ax;cY=by-ay;for(p=0;p<n;p++){px=contour[verts[p]].x;py=contour[verts[p]].y;if(px===ax&&py===ay||px===bx&&py===by||px===cx&&py===cy)continue;apx=px-ax;apy=py-ay;bpx=px-bx;bpy=py-by;cpx=px-cx;cpy=py-cy;// see if p is inside triangle abc
aCROSSbp=aX*bpy-aY*bpx;cCROSSap=cX*apy-cY*apx;bCROSScp=bX*cpy-bY*cpx;if(aCROSSbp>=-Number.EPSILON&&bCROSScp>=-Number.EPSILON&&cCROSSap>=-Number.EPSILON)return false;}return true;}// takes in an contour array and returns
return function triangulate(contour,indices){var n=contour.length;if(n<3)return null;var result=[],verts=[],vertIndices=[];/* we want a counter-clockwise polygon in verts */var u,v,w;if(ShapeUtils.area(contour)>0.0){for(v=0;v<n;v++)verts[v]=v;}else{for(v=0;v<n;v++)verts[v]=n-1-v;}var nv=n;/*  remove nv - 2 vertices, creating 1 triangle every time */var count=2*nv;/* error detection */for(v=nv-1;nv>2;){/* if we loop, it is probably a non-simple polygon */if(count--<=0){//** Triangulate: ERROR - probable bad polygon!
//throw ( "Warning, unable to triangulate polygon!" );
//return null;
// Sometimes warning is fine, especially polygons are triangulated in reverse.
console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');if(indices)return vertIndices;return result;}/* three consecutive vertices in current polygon, <u,v,w> */u=v;if(nv<=u)u=0;/* previous */v=u+1;if(nv<=v)v=0;/* new v    */w=v+1;if(nv<=w)w=0;/* next     */if(snip(contour,u,v,w,nv,verts)){var a,b,c,s,t;/* true names of the vertices */a=verts[u];b=verts[v];c=verts[w];/* output Triangle */result.push([contour[a],contour[b],contour[c]]);vertIndices.push([verts[u],verts[v],verts[w]]);/* remove v from the remaining polygon */for(s=v,t=v+1;t<nv;s++,t++){verts[s]=verts[t];}nv--;/* reset error detection counter */count=2*nv;}}if(indices)return vertIndices;return result;};}(),triangulateShape:function(contour,holes){function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}removeDupEndPts(contour);holes.forEach(removeDupEndPts);function point_in_segment_2D_colin(inSegPt1,inSegPt2,inOtherPt){// inOtherPt needs to be collinear to the inSegment
if(inSegPt1.x!==inSegPt2.x){if(inSegPt1.x<inSegPt2.x){return inSegPt1.x<=inOtherPt.x&&inOtherPt.x<=inSegPt2.x;}else{return inSegPt2.x<=inOtherPt.x&&inOtherPt.x<=inSegPt1.x;}}else{if(inSegPt1.y<inSegPt2.y){return inSegPt1.y<=inOtherPt.y&&inOtherPt.y<=inSegPt2.y;}else{return inSegPt2.y<=inOtherPt.y&&inOtherPt.y<=inSegPt1.y;}}}function intersect_segments_2D(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1,inSeg2Pt2,inExcludeAdjacentSegs){var seg1dx=inSeg1Pt2.x-inSeg1Pt1.x,seg1dy=inSeg1Pt2.y-inSeg1Pt1.y;var seg2dx=inSeg2Pt2.x-inSeg2Pt1.x,seg2dy=inSeg2Pt2.y-inSeg2Pt1.y;var seg1seg2dx=inSeg1Pt1.x-inSeg2Pt1.x;var seg1seg2dy=inSeg1Pt1.y-inSeg2Pt1.y;var limit=seg1dy*seg2dx-seg1dx*seg2dy;var perpSeg1=seg1dy*seg1seg2dx-seg1dx*seg1seg2dy;if(Math.abs(limit)>Number.EPSILON){// not parallel
var perpSeg2;if(limit>0){if(perpSeg1<0||perpSeg1>limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2<0||perpSeg2>limit)return[];}else{if(perpSeg1>0||perpSeg1<limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2>0||perpSeg2<limit)return[];}// i.e. to reduce rounding errors
// intersection at endpoint of segment#1?
if(perpSeg2===0){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt1];}if(perpSeg2===limit){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt2];}// intersection at endpoint of segment#2?
if(perpSeg1===0)return[inSeg2Pt1];if(perpSeg1===limit)return[inSeg2Pt2];// return real intersection point
var factorSeg1=perpSeg2/limit;return[{x:inSeg1Pt1.x+factorSeg1*seg1dx,y:inSeg1Pt1.y+factorSeg1*seg1dy}];}else{// parallel or collinear
if(perpSeg1!==0||seg2dy*seg1seg2dx!==seg2dx*seg1seg2dy)return[];// they are collinear or degenerate
var seg1Pt=seg1dx===0&&seg1dy===0;// segment1 is just a point?
var seg2Pt=seg2dx===0&&seg2dy===0;// segment2 is just a point?
// both segments are points
if(seg1Pt&&seg2Pt){if(inSeg1Pt1.x!==inSeg2Pt1.x||inSeg1Pt1.y!==inSeg2Pt1.y)return[];// they are distinct  points
return[inSeg1Pt1];// they are the same point
}// segment#1  is a single point
if(seg1Pt){if(!point_in_segment_2D_colin(inSeg2Pt1,inSeg2Pt2,inSeg1Pt1))return[];// but not in segment#2
return[inSeg1Pt1];}// segment#2  is a single point
if(seg2Pt){if(!point_in_segment_2D_colin(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1))return[];// but not in segment#1
return[inSeg2Pt1];}// they are collinear segments, which might overlap
var seg1min,seg1max,seg1minVal,seg1maxVal;var seg2min,seg2max,seg2minVal,seg2maxVal;if(seg1dx!==0){// the segments are NOT on a vertical line
if(inSeg1Pt1.x<inSeg1Pt2.x){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.x;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.x;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.x;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.x;}if(inSeg2Pt1.x<inSeg2Pt2.x){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.x;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.x;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.x;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.x;}}else{// the segments are on a vertical line
if(inSeg1Pt1.y<inSeg1Pt2.y){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.y;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.y;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.y;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.y;}if(inSeg2Pt1.y<inSeg2Pt2.y){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.y;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.y;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.y;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.y;}}if(seg1minVal<=seg2minVal){if(seg1maxVal<seg2minVal)return[];if(seg1maxVal===seg2minVal){if(inExcludeAdjacentSegs)return[];return[seg2min];}if(seg1maxVal<=seg2maxVal)return[seg2min,seg1max];return[seg2min,seg2max];}else{if(seg1minVal>seg2maxVal)return[];if(seg1minVal===seg2maxVal){if(inExcludeAdjacentSegs)return[];return[seg1min];}if(seg1maxVal<=seg2maxVal)return[seg1min,seg1max];return[seg1min,seg2max];}}}function isPointInsideAngle(inVertex,inLegFromPt,inLegToPt,inOtherPt){// The order of legs is important
// translation of all points, so that Vertex is at (0,0)
var legFromPtX=inLegFromPt.x-inVertex.x,legFromPtY=inLegFromPt.y-inVertex.y;var legToPtX=inLegToPt.x-inVertex.x,legToPtY=inLegToPt.y-inVertex.y;var otherPtX=inOtherPt.x-inVertex.x,otherPtY=inOtherPt.y-inVertex.y;// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
var from2toAngle=legFromPtX*legToPtY-legFromPtY*legToPtX;var from2otherAngle=legFromPtX*otherPtY-legFromPtY*otherPtX;if(Math.abs(from2toAngle)>Number.EPSILON){// angle != 180 deg.
var other2toAngle=otherPtX*legToPtY-otherPtY*legToPtX;// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
if(from2toAngle>0){// main angle < 180 deg.
return from2otherAngle>=0&&other2toAngle>=0;}else{// main angle > 180 deg.
return from2otherAngle>=0||other2toAngle>=0;}}else{// angle == 180 deg.
// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
return from2otherAngle>0;}}function removeHoles(contour,holes){var shape=contour.concat();// work on this shape
var hole;function isCutLineInsideAngles(inShapeIdx,inHoleIdx){// Check if hole point lies within angle around shape point
var lastShapeIdx=shape.length-1;var prevShapeIdx=inShapeIdx-1;if(prevShapeIdx<0)prevShapeIdx=lastShapeIdx;var nextShapeIdx=inShapeIdx+1;if(nextShapeIdx>lastShapeIdx)nextShapeIdx=0;var insideAngle=isPointInsideAngle(shape[inShapeIdx],shape[prevShapeIdx],shape[nextShapeIdx],hole[inHoleIdx]);if(!insideAngle){// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
return false;}// Check if shape point lies within angle around hole point
var lastHoleIdx=hole.length-1;var prevHoleIdx=inHoleIdx-1;if(prevHoleIdx<0)prevHoleIdx=lastHoleIdx;var nextHoleIdx=inHoleIdx+1;if(nextHoleIdx>lastHoleIdx)nextHoleIdx=0;insideAngle=isPointInsideAngle(hole[inHoleIdx],hole[prevHoleIdx],hole[nextHoleIdx],shape[inShapeIdx]);if(!insideAngle){// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
return false;}return true;}function intersectsShapeEdge(inShapePt,inHolePt){// checks for intersections with shape edges
var sIdx,nextIdx,intersection;for(sIdx=0;sIdx<shape.length;sIdx++){nextIdx=sIdx+1;nextIdx%=shape.length;intersection=intersect_segments_2D(inShapePt,inHolePt,shape[sIdx],shape[nextIdx],true);if(intersection.length>0)return true;}return false;}var indepHoles=[];function intersectsHoleEdge(inShapePt,inHolePt){// checks for intersections with hole edges
var ihIdx,chkHole,hIdx,nextIdx,intersection;for(ihIdx=0;ihIdx<indepHoles.length;ihIdx++){chkHole=holes[indepHoles[ihIdx]];for(hIdx=0;hIdx<chkHole.length;hIdx++){nextIdx=hIdx+1;nextIdx%=chkHole.length;intersection=intersect_segments_2D(inShapePt,inHolePt,chkHole[hIdx],chkHole[nextIdx],true);if(intersection.length>0)return true;}}return false;}var holeIndex,shapeIndex,shapePt,holePt,holeIdx,cutKey,failedCuts=[],tmpShape1,tmpShape2,tmpHole1,tmpHole2;for(var h=0,hl=holes.length;h<hl;h++){indepHoles.push(h);}var minShapeIndex=0;var counter=indepHoles.length*2;while(indepHoles.length>0){counter--;if(counter<0){console.log("Infinite Loop! Holes left:"+indepHoles.length+", Probably Hole outside Shape!");break;}// search for shape-vertex and hole-vertex,
// which can be connected without intersections
for(shapeIndex=minShapeIndex;shapeIndex<shape.length;shapeIndex++){shapePt=shape[shapeIndex];holeIndex=-1;// search for hole which can be reached without intersections
for(var h=0;h<indepHoles.length;h++){holeIdx=indepHoles[h];// prevent multiple checks
cutKey=shapePt.x+":"+shapePt.y+":"+holeIdx;if(failedCuts[cutKey]!==undefined)continue;hole=holes[holeIdx];for(var h2=0;h2<hole.length;h2++){holePt=hole[h2];if(!isCutLineInsideAngles(shapeIndex,h2))continue;if(intersectsShapeEdge(shapePt,holePt))continue;if(intersectsHoleEdge(shapePt,holePt))continue;holeIndex=h2;indepHoles.splice(h,1);tmpShape1=shape.slice(0,shapeIndex+1);tmpShape2=shape.slice(shapeIndex);tmpHole1=hole.slice(holeIndex);tmpHole2=hole.slice(0,holeIndex+1);shape=tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);minShapeIndex=shapeIndex;// Debug only, to show the selected cuts
// glob_CutLines.push( [ shapePt, holePt ] );
break;}if(holeIndex>=0)break;// hole-vertex found
failedCuts[cutKey]=true;// remember failure
}if(holeIndex>=0)break;// hole-vertex found
}}return shape;/* shape with no holes */}var i,il,f,face,key,index,allPointsMap={};// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
var allpoints=contour.concat();for(var h=0,hl=holes.length;h<hl;h++){Array.prototype.push.apply(allpoints,holes[h]);}//console.log( "allpoints",allpoints, allpoints.length );
// prepare all points map
for(i=0,il=allpoints.length;i<il;i++){key=allpoints[i].x+":"+allpoints[i].y;if(allPointsMap[key]!==undefined){console.warn("THREE.ShapeUtils: Duplicate point",key,i);}allPointsMap[key]=i;}// remove holes by cutting paths to holes and adding them to the shape
var shapeWithoutHoles=removeHoles(contour,holes);var triangles=ShapeUtils.triangulate(shapeWithoutHoles,false);// True returns indices for points of spooled shape
//console.log( "triangles",triangles, triangles.length );
// check all face vertices against all points map
for(i=0,il=triangles.length;i<il;i++){face=triangles[i];for(f=0;f<3;f++){key=face[f].x+":"+face[f].y;index=allPointsMap[key];if(index!==undefined){face[f]=index;}}}return triangles.concat();},isClockWise:function(pts){return ShapeUtils.area(pts)<0;}};/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *  frames: <Object> // containing arrays of tangents, normals, binormals
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */// ExtrudeGeometry
function ExtrudeGeometry(shapes,options){Geometry.call(this);this.type='ExtrudeGeometry';this.parameters={shapes:shapes,options:options};this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes,options));this.mergeVertices();}ExtrudeGeometry.prototype=Object.create(Geometry.prototype);ExtrudeGeometry.prototype.constructor=ExtrudeGeometry;// ExtrudeBufferGeometry
function ExtrudeBufferGeometry(shapes,options){if(typeof shapes==="undefined"){shapes=[];return;}BufferGeometry.call(this);this.type='ExtrudeBufferGeometry';shapes=Array.isArray(shapes)?shapes:[shapes];this.addShapeList(shapes,options);this.computeVertexNormals();// can't really use automatic vertex normals
// as then front and back sides get smoothed too
// should do separate smoothing just for sides
//this.computeVertexNormals();
//console.log( "took", ( Date.now() - startTime ) );
}ExtrudeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ExtrudeBufferGeometry.prototype.constructor=ExtrudeBufferGeometry;ExtrudeBufferGeometry.prototype.getArrays=function(){var positionAttribute=this.getAttribute("position");var verticesArray=positionAttribute?Array.prototype.slice.call(positionAttribute.array):[];var uvAttribute=this.getAttribute("uv");var uvArray=uvAttribute?Array.prototype.slice.call(uvAttribute.array):[];var IndexAttribute=this.index;var indicesArray=IndexAttribute?Array.prototype.slice.call(IndexAttribute.array):[];return{position:verticesArray,uv:uvArray,index:indicesArray};};ExtrudeBufferGeometry.prototype.addShapeList=function(shapes,options){var sl=shapes.length;options.arrays=this.getArrays();for(var s=0;s<sl;s++){var shape=shapes[s];this.addShape(shape,options);}this.setIndex(options.arrays.index);this.addAttribute('position',new Float32BufferAttribute(options.arrays.position,3));this.addAttribute('uv',new Float32BufferAttribute(options.arrays.uv,2));};ExtrudeBufferGeometry.prototype.addShape=function(shape,options){var arrays=options.arrays?options.arrays:this.getArrays();var verticesArray=arrays.position;var indicesArray=arrays.index;var uvArray=arrays.uv;var placeholder=[];var amount=options.amount!==undefined?options.amount:100;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;// 10
var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;// 8
var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;// false
var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var extrudePath=options.extrudePath;var extrudePts,extrudeByPath=false;// Use default WorldUVGenerator if no UV generators are specified.
var uvgen=options.UVGenerator!==undefined?options.UVGenerator:ExtrudeGeometry.WorldUVGenerator;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
splineTube=options.frames!==undefined?options.frames:extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;}// Variables initialization
var ahole,h,hl;// looping of holes
var scope=this;var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}reverse=false;// If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];vertices=vertices.concat(ahole);}function scalePt2(pt,vec,size){if(!vec)console.error("THREE.ExtrudeGeometry: vec does not exist");return vec.clone().multiplyScalar(size).add(pt);}var b,bs,t,z,vert,vlen=vertices.length,face,flen=faces.length;// Find directions for point movement
function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
//   shifted by 1 unit (length of normalized vector) to the left
// if we walk along contour clockwise, this new contour is outside the old one
//
// inPt' is the intersection of the two lines parallel to the two
//  adjacent edges of inPt at a distance of 1 unit on the left side.
var v_trans_x,v_trans_y,shrink_by=1;// resulting translation vector for inPt
// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){// not collinear
// length of vectors for normalizing
var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else{shrink_by=Math.sqrt(v_trans_lensq/2);}}else{// handle special case of collinear edges
var direction_eq=false;// assumes: opposite
if(v_prev_x>Number.EPSILON){if(v_next_x>Number.EPSILON){direction_eq=true;}}else{if(v_prev_x<-Number.EPSILON){if(v_next_x<-Number.EPSILON){direction_eq=true;}}else{if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else{// console.log("Warning: lines are a straight spike");
v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);}var holesMovements=[],oneHoleMovements,verticesMovements=contourMovements.concat();for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=[];for(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
for(b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z);}}}bs=bevelSize;// Back facing vertices
for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,0);}else{// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
// Including front facing vertices
var s;for(s=1;s<=steps;s++){for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,amount/steps*s);}else{// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(b=bevelSegments-1;b>=0;b--){t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,amount+z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);if(!extrudeByPath){v(vert.x,vert.y,amount+z);}else{v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);}}}}/* Faces */// Top and bottom faces
buildLidFaces();// Sides faces
buildSideFaces();/////  Internal functions
function buildLidFaces(){var start=verticesArray.length/3;if(bevelEnabled){var layer=0;// steps + 1
var offset=vlen*layer;// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset);}}else{// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2],face[1],face[0]);}// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,options.material!==undefined?options.material:0);}// Create faces for the z-sides of the shape
function buildSideFaces(){var start=verticesArray.length/3;var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];sidewalls(ahole,layeroffset);//, true
layeroffset+=ahole.length;}scope.addGroup(start,verticesArray.length/3-start,options.extrudeMaterial!==undefined?options.extrudeMaterial:1);}function sidewalls(contour,layeroffset){var j,k;i=contour.length;while(--i>=0){j=i;k=i-1;if(k<0)k=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
var s=0,sl=steps+bevelSegments*2;for(s=0;s<sl;s++){var slen1=vlen*s;var slen2=vlen*(s+1);var a=layeroffset+j+slen1,b=layeroffset+k+slen1,c=layeroffset+k+slen2,d=layeroffset+j+slen2;f4(a,b,c,d,contour,s,sl,j,k);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d,wallContour,stepIndex,stepsLength,contourIndex1,contourIndex2){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){indicesArray.push(verticesArray.length/3);verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}if(!options.arrays){this.setIndex(indicesArray);this.addAttribute('position',new Float32BufferAttribute(verticesArray,3));this.addAttribute('uv',new Float32BufferAttribute(options.arrays.uv,2));}};ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(geometry,vertices,indexA,indexB,indexC){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];return[new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function(geometry,vertices,indexA,indexB,indexC,indexD){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var a_z=vertices[indexA*3+2];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var b_z=vertices[indexB*3+2];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];var c_z=vertices[indexC*3+2];var d_x=vertices[indexD*3];var d_y=vertices[indexD*3+1];var d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<0.01){return[new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else{return[new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */// TextGeometry
function TextGeometry(text,parameters){Geometry.call(this);this.type='TextGeometry';this.parameters={text:text,parameters:parameters};this.fromBufferGeometry(new TextBufferGeometry(text,parameters));this.mergeVertices();}TextGeometry.prototype=Object.create(Geometry.prototype);TextGeometry.prototype.constructor=TextGeometry;// TextBufferGeometry
function TextBufferGeometry(text,parameters){parameters=parameters||{};var font=parameters.font;if((font&&font.isFont)===false){console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');return new Geometry();}var shapes=font.generateShapes(text,parameters.size,parameters.curveSegments);// translate parameters to ExtrudeGeometry API
parameters.amount=parameters.height!==undefined?parameters.height:50;// defaults
if(parameters.bevelThickness===undefined)parameters.bevelThickness=10;if(parameters.bevelSize===undefined)parameters.bevelSize=8;if(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;ExtrudeBufferGeometry.call(this,shapes,parameters);this.type='TextBufferGeometry';}TextBufferGeometry.prototype=Object.create(ExtrudeBufferGeometry.prototype);TextBufferGeometry.prototype.constructor=TextBufferGeometry;/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */// SphereGeometry
function SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){Geometry.call(this);this.type='SphereGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));this.mergeVertices();}SphereGeometry.prototype=Object.create(Geometry.prototype);SphereGeometry.prototype.constructor=SphereGeometry;// SphereBufferGeometry
function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){BufferGeometry.call(this);this.type='SphereBufferGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||50;widthSegments=Math.max(3,Math.floor(widthSegments)||8);heightSegments=Math.max(2,Math.floor(heightSegments)||6);phiStart=phiStart!==undefined?phiStart:0;phiLength=phiLength!==undefined?phiLength:Math.PI*2;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI;var thetaEnd=thetaStart+thetaLength;var ix,iy;var index=0;var grid=[];var vertex=new Vector3();var normal=new Vector3();// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
for(iy=0;iy<=heightSegments;iy++){var verticesRow=[];var v=iy/heightSegments;for(ix=0;ix<=widthSegments;ix++){var u=ix/widthSegments;// vertex
vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.set(vertex.x,vertex.y,vertex.z).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
for(iy=0;iy<heightSegments;iy++){for(ix=0;ix<widthSegments;ix++){var a=grid[iy][ix+1];var b=grid[iy][ix];var c=grid[iy+1][ix];var d=grid[iy+1][ix+1];if(iy!==0||thetaStart>0)indices.push(a,b,d);if(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}SphereBufferGeometry.prototype=Object.create(BufferGeometry.prototype);SphereBufferGeometry.prototype.constructor=SphereBufferGeometry;/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */// RingGeometry
function RingGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){Geometry.call(this);this.type='RingGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength));this.mergeVertices();}RingGeometry.prototype=Object.create(Geometry.prototype);RingGeometry.prototype.constructor=RingGeometry;// RingBufferGeometry
function RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='RingBufferGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};innerRadius=innerRadius||20;outerRadius=outerRadius||50;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;thetaSegments=thetaSegments!==undefined?Math.max(3,thetaSegments):8;phiSegments=phiSegments!==undefined?Math.max(1,phiSegments):1;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// some helper variables
var segment;var radius=innerRadius;var radiusStep=(outerRadius-innerRadius)/phiSegments;var vertex=new Vector3();var uv=new Vector2();var j,i;// generate vertices, normals and uvs
for(j=0;j<=phiSegments;j++){for(i=0;i<=thetaSegments;i++){// values are generate from the inside of the ring to the outside
segment=thetaStart+i/thetaSegments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uv
uv.x=(vertex.x/outerRadius+1)/2;uv.y=(vertex.y/outerRadius+1)/2;uvs.push(uv.x,uv.y);}// increase the radius for next row of vertices
radius+=radiusStep;}// indices
for(j=0;j<phiSegments;j++){var thetaSegmentLevel=j*(thetaSegments+1);for(i=0;i<thetaSegments;i++){segment=i+thetaSegmentLevel;var a=segment;var b=segment+thetaSegments+1;var c=segment+thetaSegments+2;var d=segment+1;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}RingBufferGeometry.prototype=Object.create(BufferGeometry.prototype);RingBufferGeometry.prototype.constructor=RingBufferGeometry;/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */// LatheGeometry
function LatheGeometry(points,segments,phiStart,phiLength){Geometry.call(this);this.type='LatheGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};this.fromBufferGeometry(new LatheBufferGeometry(points,segments,phiStart,phiLength));this.mergeVertices();}LatheGeometry.prototype=Object.create(Geometry.prototype);LatheGeometry.prototype.constructor=LatheGeometry;// LatheBufferGeometry
function LatheBufferGeometry(points,segments,phiStart,phiLength){BufferGeometry.call(this);this.type='LatheBufferGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};segments=Math.floor(segments)||12;phiStart=phiStart||0;phiLength=phiLength||Math.PI*2;// clamp phiLength so it's in range of [ 0, 2PI ]
phiLength=_Math.clamp(phiLength,0,Math.PI*2);// buffers
var indices=[];var vertices=[];var uvs=[];// helper variables
var base;var inverseSegments=1.0/segments;var vertex=new Vector3();var uv=new Vector2();var i,j;// generate vertices and uvs
for(i=0;i<=segments;i++){var phi=phiStart+i*inverseSegments*phiLength;var sin=Math.sin(phi);var cos=Math.cos(phi);for(j=0;j<=points.length-1;j++){// vertex
vertex.x=points[j].x*sin;vertex.y=points[j].y;vertex.z=points[j].x*cos;vertices.push(vertex.x,vertex.y,vertex.z);// uv
uv.x=i/segments;uv.y=j/(points.length-1);uvs.push(uv.x,uv.y);}}// indices
for(i=0;i<segments;i++){for(j=0;j<points.length-1;j++){base=j+i*points.length;var a=base;var b=base+points.length;var c=base+points.length+1;var d=base+1;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// generate normals
this.computeVertexNormals();// if the geometry is closed, we need to average the normals along the seam.
// because the corresponding vertices are identical (but still have different UVs).
if(phiLength===Math.PI*2){var normals=this.attributes.normal.array;var n1=new Vector3();var n2=new Vector3();var n=new Vector3();// this is the buffer offset for the last line of vertices
base=segments*points.length*3;for(i=0,j=0;i<points.length;i++,j+=3){// select the normal of the vertex in the first line
n1.x=normals[j+0];n1.y=normals[j+1];n1.z=normals[j+2];// select the normal of the vertex in the last line
n2.x=normals[base+j+0];n2.y=normals[base+j+1];n2.z=normals[base+j+2];// average normals
n.addVectors(n1,n2).normalize();// assign the new values to both normals
normals[j+0]=normals[base+j+0]=n.x;normals[j+1]=normals[base+j+1]=n.y;normals[j+2]=normals[base+j+2]=n.z;}}}LatheBufferGeometry.prototype=Object.create(BufferGeometry.prototype);LatheBufferGeometry.prototype.constructor=LatheBufferGeometry;/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */// ShapeGeometry
function ShapeGeometry(shapes,curveSegments){Geometry.call(this);this.type='ShapeGeometry';if(typeof curveSegments==='object'){console.warn('THREE.ShapeGeometry: Options parameter has been removed.');curveSegments=curveSegments.curveSegments;}this.parameters={shapes:shapes,curveSegments:curveSegments};this.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));this.mergeVertices();}ShapeGeometry.prototype=Object.create(Geometry.prototype);ShapeGeometry.prototype.constructor=ShapeGeometry;// ShapeBufferGeometry
function ShapeBufferGeometry(shapes,curveSegments){BufferGeometry.call(this);this.type='ShapeBufferGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};curveSegments=curveSegments||12;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
if(Array.isArray(shapes)===false){addShape(shapes);}else{for(var i=0;i<shapes.length;i++){addShape(shapes[i]);this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support
groupStart+=groupCount;groupCount=0;}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
function addShape(shape){var i,l,shapeHole;var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();// also check if holes are in the opposite direction
for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[i]=shapeHole.reverse();}}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole);}// vertices, normals, uvs
for(i=0,l=shapeVertices.length;i<l;i++){var vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0);normals.push(0,0,1);uvs.push(vertex.x,vertex.y);// world uvs
}// incides
for(i=0,l=faces.length;i<l;i++){var face=faces[i];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}ShapeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */function EdgesGeometry(geometry,thresholdAngle){BufferGeometry.call(this);this.type='EdgesGeometry';this.parameters={thresholdAngle:thresholdAngle};thresholdAngle=thresholdAngle!==undefined?thresholdAngle:1;// buffer
var vertices=[];// helper variables
var thresholdDot=Math.cos(_Math.DEG2RAD*thresholdAngle);var edge=[0,0],edges={},edge1,edge2;var key,keys=['a','b','c'];// prepare source geometry
var geometry2;if(geometry.isBufferGeometry){geometry2=new Geometry();geometry2.fromBufferGeometry(geometry);}else{geometry2=geometry.clone();}geometry2.mergeVertices();geometry2.computeFaceNormals();var sourceVertices=geometry2.vertices;var faces=geometry2.faces;// now create a data structure where each entry represents an edge with its adjoining faces
for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0;j<3;j++){edge1=face[keys[j]];edge2=face[keys[(j+1)%3]];edge[0]=Math.min(edge1,edge2);edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1],face1:i,face2:undefined};}else{edges[key].face2=i;}}}// generate vertices
for(key in edges){var e=edges[key];// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
if(e.face2===undefined||faces[e.face1].normal.dot(faces[e.face2].normal)<=thresholdDot){var vertex=sourceVertices[e.index1];vertices.push(vertex.x,vertex.y,vertex.z);vertex=sourceVertices[e.index2];vertices.push(vertex.x,vertex.y,vertex.z);}}// build geometry
this.addAttribute('position',new Float32BufferAttribute(vertices,3));}EdgesGeometry.prototype=Object.create(BufferGeometry.prototype);EdgesGeometry.prototype.constructor=EdgesGeometry;/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */// CylinderGeometry
function CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){Geometry.call(this);this.type='CylinderGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength));this.mergeVertices();}CylinderGeometry.prototype=Object.create(Geometry.prototype);CylinderGeometry.prototype.constructor=CylinderGeometry;// CylinderBufferGeometry
function CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CylinderBufferGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};var scope=this;radiusTop=radiusTop!==undefined?radiusTop:20;radiusBottom=radiusBottom!==undefined?radiusBottom:20;height=height!==undefined?height:100;radialSegments=Math.floor(radialSegments)||8;heightSegments=Math.floor(heightSegments)||1;openEnded=openEnded!==undefined?openEnded:false;thetaStart=thetaStart!==undefined?thetaStart:0.0;thetaLength=thetaLength!==undefined?thetaLength:2.0*Math.PI;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var index=0;var indexArray=[];var halfHeight=height/2;var groupStart=0;// generate geometry
generateTorso();if(openEnded===false){if(radiusTop>0)generateCap(true);if(radiusBottom>0)generateCap(false);}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));function generateTorso(){var x,y;var normal=new Vector3();var vertex=new Vector3();var groupCount=0;// this will be used to calculate the normal
var slope=(radiusBottom-radiusTop)/height;// generate vertices, normals and uvs
for(y=0;y<=heightSegments;y++){var indexRow=[];var v=y/heightSegments;// calculate the radius of the current row
var radius=v*(radiusBottom-radiusTop)+radiusTop;for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.set(sinTheta,slope,cosTheta).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,1-v);// save index of vertex in respective row
indexRow.push(index++);}// now save vertices of the row in our index array
indexArray.push(indexRow);}// generate indices
for(x=0;x<radialSegments;x++){for(y=0;y<heightSegments;y++){// we use the index array to access the correct indices
var a=indexArray[y][x];var b=indexArray[y+1][x];var c=indexArray[y+1][x+1];var d=indexArray[y][x+1];// faces
indices.push(a,b,d);indices.push(b,c,d);// update group counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,0);// calculate new start value for groups
groupStart+=groupCount;}function generateCap(top){var x,centerIndexStart,centerIndexEnd;var uv=new Vector2();var vertex=new Vector3();var groupCount=0;var radius=top===true?radiusTop:radiusBottom;var sign=top===true?1:-1;// save the index of the first center vertex
centerIndexStart=index;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(x=1;x<=radialSegments;x++){// vertex
vertices.push(0,halfHeight*sign,0);// normal
normals.push(0,sign,0);// uv
uvs.push(0.5,0.5);// increase index
index++;}// save the index of the last center vertex
centerIndexEnd=index;// now we generate the surrounding vertices, normals and uvs
for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var cosTheta=Math.cos(theta);var sinTheta=Math.sin(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,sign,0);// uv
uv.x=cosTheta*0.5+0.5;uv.y=sinTheta*0.5*sign+0.5;uvs.push(uv.x,uv.y);// increase index
index++;}// generate indices
for(x=0;x<radialSegments;x++){var c=centerIndexStart+x;var i=centerIndexEnd+x;if(top===true){// face top
indices.push(i,i+1,c);}else{// face bottom
indices.push(i+1,i,c);}groupCount+=3;}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,top===true?1:2);// calculate new start value for groups
groupStart+=groupCount;}}CylinderBufferGeometry.prototype=Object.create(BufferGeometry.prototype);CylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry;/**
 * @author abelnation / http://github.com/abelnation
 */// ConeGeometry
function ConeGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeGeometry.prototype=Object.create(CylinderGeometry.prototype);ConeGeometry.prototype.constructor=ConeGeometry;// ConeBufferGeometry
function ConeBufferGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderBufferGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeBufferGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeBufferGeometry.prototype=Object.create(CylinderBufferGeometry.prototype);ConeBufferGeometry.prototype.constructor=ConeBufferGeometry;/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */// CircleGeometry
function CircleGeometry(radius,segments,thetaStart,thetaLength){Geometry.call(this);this.type='CircleGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CircleBufferGeometry(radius,segments,thetaStart,thetaLength));this.mergeVertices();}CircleGeometry.prototype=Object.create(Geometry.prototype);CircleGeometry.prototype.constructor=CircleGeometry;// CircleBufferGeometry
function CircleBufferGeometry(radius,segments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CircleBufferGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||50;segments=segments!==undefined?Math.max(3,segments):8;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var i,s;var vertex=new Vector3();var uv=new Vector2();// center point
vertices.push(0,0,0);normals.push(0,0,1);uvs.push(0.5,0.5);for(s=0,i=3;s<=segments;s++,i+=3){var segment=thetaStart+s/segments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uvs
uv.x=(vertices[i]/radius+1)/2;uv.y=(vertices[i+1]/radius+1)/2;uvs.push(uv.x,uv.y);}// indices
for(i=1;i<=segments;i++){indices.push(i,i+1,0);}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}CircleBufferGeometry.prototype=Object.create(BufferGeometry.prototype);CircleBufferGeometry.prototype.constructor=CircleBufferGeometry;var Geometries=Object.freeze({WireframeGeometry:WireframeGeometry,ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricBufferGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronBufferGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronBufferGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronBufferGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronBufferGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronBufferGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeBufferGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotBufferGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusBufferGeometry,TextGeometry:TextGeometry,TextBufferGeometry:TextBufferGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereBufferGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingBufferGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneBufferGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheBufferGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeBufferGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeBufferGeometry,EdgesGeometry:EdgesGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeBufferGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderBufferGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleBufferGeometry,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxBufferGeometry});/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>
 * }
 */function ShadowMaterial(parameters){ShaderMaterial.call(this,{uniforms:UniformsUtils.merge([UniformsLib.lights,{opacity:{value:1.0}}]),vertexShader:ShaderChunk['shadow_vert'],fragmentShader:ShaderChunk['shadow_frag']});this.lights=true;this.transparent=true;Object.defineProperties(this,{opacity:{enumerable:true,get:function(){return this.uniforms.opacity.value;},set:function(value){this.uniforms.opacity.value=value;}}});this.setValues(parameters);}ShadowMaterial.prototype=Object.create(ShaderMaterial.prototype);ShadowMaterial.prototype.constructor=ShadowMaterial;ShadowMaterial.prototype.isShadowMaterial=true;/**
 * @author mrdoob / http://mrdoob.com/
 */function RawShaderMaterial(parameters){ShaderMaterial.call(this,parameters);this.type='RawShaderMaterial';}RawShaderMaterial.prototype=Object.create(ShaderMaterial.prototype);RawShaderMaterial.prototype.constructor=RawShaderMaterial;RawShaderMaterial.prototype.isRawShaderMaterial=true;/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshStandardMaterial(parameters){Material.call(this);this.defines={'STANDARD':''};this.type='MeshStandardMaterial';this.color=new Color(0xffffff);// diffuse
this.roughness=0.5;this.metalness=0.5;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.roughnessMap=null;this.metalnessMap=null;this.alphaMap=null;this.envMap=null;this.envMapIntensity=1.0;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshStandardMaterial.prototype=Object.create(Material.prototype);MeshStandardMaterial.prototype.constructor=MeshStandardMaterial;MeshStandardMaterial.prototype.isMeshStandardMaterial=true;MeshStandardMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.defines={'STANDARD':''};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 * }
 */function MeshPhysicalMaterial(parameters){MeshStandardMaterial.call(this);this.defines={'PHYSICAL':''};this.type='MeshPhysicalMaterial';this.reflectivity=0.5;// maps to F0 = 0.04
this.clearCoat=0.0;this.clearCoatRoughness=0.0;this.setValues(parameters);}MeshPhysicalMaterial.prototype=Object.create(MeshStandardMaterial.prototype);MeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial;MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;MeshPhysicalMaterial.prototype.copy=function(source){MeshStandardMaterial.prototype.copy.call(this,source);this.defines={'PHYSICAL':''};this.reflectivity=source.reflectivity;this.clearCoat=source.clearCoat;this.clearCoatRoughness=source.clearCoatRoughness;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshPhongMaterial(parameters){Material.call(this);this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshPhongMaterial.prototype=Object.create(Material.prototype);MeshPhongMaterial.prototype.constructor=MeshPhongMaterial;MeshPhongMaterial.prototype.isMeshPhongMaterial=true;MeshPhongMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */function MeshToonMaterial(parameters){MeshPhongMaterial.call(this);this.defines={'TOON':''};this.type='MeshToonMaterial';this.gradientMap=null;this.setValues(parameters);}MeshToonMaterial.prototype=Object.create(MeshPhongMaterial.prototype);MeshToonMaterial.prototype.constructor=MeshToonMaterial;MeshToonMaterial.prototype.isMeshToonMaterial=true;MeshToonMaterial.prototype.copy=function(source){MeshPhongMaterial.prototype.copy.call(this,source);this.gradientMap=source.gradientMap;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshNormalMaterial(parameters){Material.call(this,parameters);this.type='MeshNormalMaterial';this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshNormalMaterial.prototype=Object.create(Material.prototype);MeshNormalMaterial.prototype.constructor=MeshNormalMaterial;MeshNormalMaterial.prototype.isMeshNormalMaterial=true;MeshNormalMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshLambertMaterial(parameters){Material.call(this);this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshLambertMaterial.prototype=Object.create(Material.prototype);MeshLambertMaterial.prototype.constructor=MeshLambertMaterial;MeshLambertMaterial.prototype.isMeshLambertMaterial=true;MeshLambertMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */function LineDashedMaterial(parameters){Material.call(this);this.type='LineDashedMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.scale=1;this.dashSize=3;this.gapSize=1;this.lights=false;this.setValues(parameters);}LineDashedMaterial.prototype=Object.create(Material.prototype);LineDashedMaterial.prototype.constructor=LineDashedMaterial;LineDashedMaterial.prototype.isLineDashedMaterial=true;LineDashedMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;};var Materials=Object.freeze({ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshBasicMaterial:MeshBasicMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});/**
 * @author mrdoob / http://mrdoob.com/
 */var Cache={enabled:false,files:{},add:function(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
this.files[key]=file;},get:function(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[key];},remove:function(key){delete this.files[key];},clear:function(){this.files={};}};/**
 * @author mrdoob / http://mrdoob.com/
 */function LoadingManager(onLoad,onProgress,onError){var scope=this;var isLoading=false,itemsLoaded=0,itemsTotal=0;this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};}var DefaultLoadingManager=new LoadingManager();/**
 * @author mrdoob / http://mrdoob.com/
 */function FileLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(FileLoader.prototype,{load:function(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check for data: URI
var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);// Safari can not handle Data URIs through XMLHttpRequest so process manually
if(dataUriRegexResult){var mimeType=dataUriRegexResult[1];var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64)data=window.atob(data);try{var response;var responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':response=new ArrayBuffer(data.length);var view=new Uint8Array(response);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}if(responseType==='blob'){response=new Blob([response],{type:mimeType});}break;case'document':var parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
response=data;break;}// Wait for next browser tick
window.setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick
window.setTimeout(function(){if(onError)onError(error);scope.manager.itemEnd(url);scope.manager.itemError(url);},0);}}else{var request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=event.target.response;Cache.add(url,response);if(this.status===200){if(onLoad)onLoad(response);scope.manager.itemEnd(url);}else if(this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
console.warn('THREE.FileLoader: HTTP Status 0 received.');if(onLoad)onLoad(response);scope.manager.itemEnd(url);}else{if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);}},false);if(onProgress!==undefined){request.addEventListener('progress',function(event){onProgress(event);},false);}request.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');for(var header in this.requestHeader){request.setRequestHeader(header,this.requestHeader[header]);}request.send(null);}scope.manager.itemStart(url);return request;},setPath:function(value){this.path=value;return this;},setResponseType:function(value){this.responseType=value;return this;},setWithCredentials:function(value){this.withCredentials=value;return this;},setMimeType:function(value){this.mimeType=value;return this;},setRequestHeader:function(value){this.requestHeader=value;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */function CompressedTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
this._parser=null;}Object.assign(CompressedTextureLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var images=[];var texture=new CompressedTexture();texture.image=images;var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType('arraybuffer');function loadTexture(i){loader.load(url[i],function(buffer){var texDatas=scope._parser(buffer,true);images[i]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps};loaded+=1;if(loaded===6){if(texDatas.mipmapCount===1)texture.minFilter=LinearFilter;texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);}},onProgress,onError);}if(Array.isArray(url)){var loaded=0;for(var i=0,il=url.length;i<il;++i){loadTexture(i);}}else{// compressed cubemap texture stored in a single DDS file
loader.load(url,function(buffer){var texDatas=scope._parser(buffer,true);if(texDatas.isCubemap){var faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(var f=0;f<faces;f++){images[f]={mipmaps:[]};for(var i=0;i<texDatas.mipmapCount;i++){images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);images[f].format=texDatas.format;images[f].width=texDatas.width;images[f].height=texDatas.height;}}}else{texture.image.width=texDatas.width;texture.image.height=texDatas.height;texture.mipmaps=texDatas.mipmaps;}if(texDatas.mipmapCount===1){texture.minFilter=LinearFilter;}texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);},onProgress,onError);}return texture;},setPath:function(value){this.path=value;return this;}});/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */function DataTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
this._parser=null;}Object.assign(DataTextureLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var texture=new DataTexture();var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var texData=scope._parser(buffer);if(!texData)return;if(undefined!==texData.image){texture.image=texData.image;}else if(undefined!==texData.data){texture.image.width=texData.width;texture.image.height=texData.height;texture.image.data=texData.data;}texture.wrapS=undefined!==texData.wrapS?texData.wrapS:ClampToEdgeWrapping;texture.wrapT=undefined!==texData.wrapT?texData.wrapT:ClampToEdgeWrapping;texture.magFilter=undefined!==texData.magFilter?texData.magFilter:LinearFilter;texture.minFilter=undefined!==texData.minFilter?texData.minFilter:LinearMipMapLinearFilter;texture.anisotropy=undefined!==texData.anisotropy?texData.anisotropy:1;if(undefined!==texData.format){texture.format=texData.format;}if(undefined!==texData.type){texture.type=texData.type;}if(undefined!==texData.mipmaps){texture.mipmaps=texData.mipmaps;}if(1===texData.mipmapCount){texture.minFilter=LinearFilter;}texture.needsUpdate=true;if(onLoad)onLoad(texture,texData);},onProgress,onError);return texture;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function ImageLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(ImageLoader.prototype,{load:function(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=document.createElementNS('http://www.w3.org/1999/xhtml','img');image.addEventListener('load',function(){Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);},false);/*
		image.addEventListener( 'progress', function ( event ) {

			if ( onProgress ) onProgress( event );

		}, false );
		*/image.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;},setCrossOrigin:function(value){this.crossOrigin=value;return this;},setPath:function(value){this.path=value;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function CubeTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(CubeTextureLoader.prototype,{load:function(urls,onLoad,onProgress,onError){var texture=new CubeTexture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(var i=0;i<urls.length;++i){loadTexture(i);}return texture;},setCrossOrigin:function(value){this.crossOrigin=value;return this;},setPath:function(value){this.path=value;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function TextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(TextureLoader.prototype,{load:function(url,onLoad,onProgress,onError){var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var texture=new Texture();texture.image=loader.load(url,function(){// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
var isJPEG=url.search(/\.(jpg|jpeg)$/)>0||url.search(/^data\:image\/jpeg/)===0;texture.format=isJPEG?RGBFormat:RGBAFormat;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;},setCrossOrigin:function(value){this.crossOrigin=value;return this;},setPath:function(value){this.path=value;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function Light(color,intensity){Object3D.call(this);this.type='Light';this.color=new Color(color);this.intensity=intensity!==undefined?intensity:1;this.receiveShadow=undefined;}Light.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Light,isLight:true,copy:function(source){Object3D.prototype.copy.call(this,source);this.color.copy(source.color);this.intensity=source.intensity;return this;},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}});/**
 * @author alteredq / http://alteredqualia.com/
 */function HemisphereLight(skyColor,groundColor,intensity){Light.call(this,skyColor,intensity);this.type='HemisphereLight';this.castShadow=undefined;this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}HemisphereLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function LightShadow(camera){this.camera=camera;this.bias=0;this.radius=1;this.mapSize=new Vector2(512,512);this.map=null;this.matrix=new Matrix4();}Object.assign(LightShadow.prototype,{copy:function(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;},clone:function(){return new this.constructor().copy(this);},toJSON:function(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function SpotLightShadow(){LightShadow.call(this,new PerspectiveCamera(50,1,0.5,500));}SpotLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:SpotLightShadow,isSpotLightShadow:true,update:function(light){var camera=this.camera;var fov=_Math.RAD2DEG*2*light.angle;var aspect=this.mapSize.width/this.mapSize.height;var far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}}});/**
 * @author alteredq / http://alteredqualia.com/
 */function SpotLight(color,intensity,distance,angle,penumbra,decay){Light.call(this,color,intensity);this.type='SpotLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();Object.defineProperty(this,'power',{get:function(){// intensity = power per solid angle.
// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
return this.intensity*Math.PI;},set:function(power){// intensity = power per solid angle.
// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
this.intensity=power/Math.PI;}});this.distance=distance!==undefined?distance:0;this.angle=angle!==undefined?angle:Math.PI/3;this.penumbra=penumbra!==undefined?penumbra:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new SpotLightShadow();}SpotLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:SpotLight,isSpotLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function PointLight(color,intensity,distance,decay){Light.call(this,color,intensity);this.type='PointLight';Object.defineProperty(this,'power',{get:function(){// intensity = power per solid angle.
// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
return this.intensity*4*Math.PI;},set:function(power){// intensity = power per solid angle.
// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
this.intensity=power/(4*Math.PI);}});this.distance=distance!==undefined?distance:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new LightShadow(new PerspectiveCamera(90,1,0.5,500));}PointLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:PointLight,isPointLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));}DirectionalLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:DirectionalLightShadow});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function DirectionalLight(color,intensity){Light.call(this,color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.shadow=new DirectionalLightShadow();}DirectionalLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function AmbientLight(color,intensity){Light.call(this,color,intensity);this.type='AmbientLight';this.castShadow=undefined;}AmbientLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:AmbientLight,isAmbientLight:true});/**
 * @author abelnation / http://github.com/abelnation
 */function RectAreaLight(color,intensity,width,height){Light.call(this,color,intensity);this.type='RectAreaLight';this.position.set(0,1,0);this.updateMatrix();this.width=width!==undefined?width:10;this.height=height!==undefined?height:10;// TODO (abelnation): distance/decay
// TODO (abelnation): update method for RectAreaLight to update transform to lookat target
// TODO (abelnation): shadows
}// TODO (abelnation): RectAreaLight update when light shape is changed
RectAreaLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:RectAreaLight,isRectAreaLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.width=source.width;this.height=source.height;return this;},toJSON:function(meta){var data=Light.prototype.toJSON.call(this,meta);data.object.width=this.width;data.object.height=this.height;return data;}});/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
// but array.subarray(from) or array.subarray(from, len) is correct
return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
convertArray:function(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
!forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
}return Array.prototype.slice.call(array);// create Array
},isTypedArray:function(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
getKeyframeOrder:function(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var i=0;i!==n;++i)result[i]=i;result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var i=0,dstOffset=0;dstOffset!==nValues;++i){var srcOffset=order[i]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
flattenJSON:function(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
var value=key[valuePropertyName];if(value===undefined)return;// no data
if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
}key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else{// otherwise push as-is
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}}};/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;}Object.assign(Interpolant.prototype,{evaluate:function(t){var pp=this.parameterPositions,i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
break seek;}}// prepare binary search on the right side of the index
right=pp.length;break linear_scan;}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(t>=t0)){// looping?
var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
t0=t1global;}// linear reverse scan
for(var giveUpAt=i1-2;;){if(t0===undefined){// before start
this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===giveUpAt)break;// this loop
t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
break seek;}}// prepare binary search on the left side of the index
right=i1;i1=0;break linear_scan;}// the interval is valid
break validate_interval;}// linear scan
// binary search
while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else{i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
return this.interpolate_(i1,t0,t,t1);},settings:null,// optional, subclass-specific settings structure
// Note: The indirection allows central control of many interpolants.
// --- Protected interface
DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_;},copySampleValue_:function(index){// copies a sample value to the result buffer
var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var i=0;i!==stride;++i){result[i]=values[offset+i];}return result;},// Template methods for derived classes:
interpolate_:function(i1,t0,t,t1){throw new Error("call to abstract method");// implementations shall return this.resultBuffer
},intervalChanged_:function(i1,t0,t1){// empty
}});//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Interpolant.prototype,{//( 0, t, t0 ), returns this.resultBuffer
beforeStart_:Interpolant.prototype.copySampleValue_,//( N-1, tN-1, t ), returns this.resultBuffer
afterEnd_:Interpolant.prototype.copySampleValue_});/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;}CubicInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding},intervalChanged_:function(i1,t0,t1){var pp=this.parameterPositions,iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
// f''(t0) = 0 a.k.a. Natural Spline
iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
// f''(tN) = 0, a.k.a. Natural Spline
iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;},interpolate_:function(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
for(var i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}});/**
 * @author tschw
 */function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}LinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}});/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}DiscreteInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function(i1,t0,t,t1){return this.copySampleValue_(i1-1);}});var KeyframeTrackPrototype;KeyframeTrackPrototype={TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodDiscrete:function(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodLinear:function(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:function(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);},setInterpolation:function(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else{throw new Error(message);// fatal, in this case
}}console.warn(message);return;}this.createInterpolant=factoryMethod;},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}},getValueSize:function(){return this.values.length/this.times.length;},// move all keyframes either forwards or backwards in time
shift:function(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;},// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale:function(timeScale){if(timeScale!==1.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;},// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim:function(startTime,endTime){var times=this.times,nKeys=times.length,from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime)++from;while(to!==-1&&times[to]>endTime)--to;++to;// inclusive -> exclusive bound
if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
if(from>=to)to=Math.max(to,1),from=to-1;var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;},// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate:function(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error("invalid value size in track",this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error("track is empty",this);valid=false;}var prevTime=null;for(var i=0;i!==nKeys;i++){var currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error("time is not a valid number",this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error("out of order keys",this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var i=0,n=values.length;i!==n;++i){var value=values[i];if(isNaN(value)){console.error("value is not a valid number",this,i,value);valid=false;break;}}}}return valid;},// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize:function(){var times=this.times,values=this.values,stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,writeIndex=1,lastIndex=times.length-1;for(var i=1;i<lastIndex;++i){var keep=false;var time=times[i];var timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
if(time!==timeNext&&(i!==1||time!==time[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
var offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else keep=true;}// in-place compaction
if(keep){if(i!==writeIndex){times[writeIndex]=times[i];var readOffset=i*stride,writeOffset=writeIndex*stride;for(var j=0;j!==stride;++j)values[writeOffset+j]=values[readOffset+j];}++writeIndex;}}// flush last keyframe (compaction looks ahead)
if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j)values[writeOffset+j]=values[readOffset+j];++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}return this;}};function KeyframeTrackConstructor(name,times,values,interpolation){if(name===undefined)throw new Error("track name is undefined");if(times===undefined||times.length===0){throw new Error("no keyframes in track named "+name);}this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);this.validate();this.optimize();}/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function VectorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}VectorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:VectorKeyframeTrack,ValueTypeName:'vector'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}QuaternionLinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=i1*stride,alpha=(t-t0)/(t1-t0);for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}});/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function QuaternionKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}QuaternionKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:'quaternion',// ValueBufferType is inherited
DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodLinear:function(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:undefined// not yet implemented
});/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function NumberKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}NumberKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:NumberKeyframeTrack,ValueTypeName:'number'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function StringKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}StringKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:StringKeyframeTrack,ValueTypeName:'string',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined});/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function BooleanKeyframeTrack(name,times,values){KeyframeTrackConstructor.call(this,name,times,values);}BooleanKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:BooleanKeyframeTrack,ValueTypeName:'bool',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined// Note: Actually this track could have a optimized / compressed
// representation of a single value and a custom interpolant that
// computes "firstValue ^ isOdd( index )".
});/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function ColorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}ColorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:ColorKeyframeTrack,ValueTypeName:'color'// ValueBufferType is inherited
// DefaultInterpolation is inherited
// Note: Very basic implementation and nothing special yet.
// However, this is the place for color space parameterization.
});/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function KeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.apply(this,arguments);}KeyframeTrack.prototype=KeyframeTrackPrototype;KeyframeTrackPrototype.constructor=KeyframeTrack;// Static methods:
Object.assign(KeyframeTrack,{// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
parse:function(json){if(json.type===undefined){throw new Error("track type undefined, can not parse");}var trackType=KeyframeTrack._getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
if(trackType.parse!==undefined){return trackType.parse(json);}else{// by default, we asssume a constructor compatible with the base
return new trackType(json.name,json.times,json.values,json.interpolation);}},toJSON:function(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
if(trackType.toJSON!==undefined){json=trackType.toJSON(track);}else{// by default, we assume the data can be serialized as-is
json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
return json;},_getTrackTypeForValueTypeName:function(typeName){switch(typeName.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack;}throw new Error("Unsupported typeName: "+typeName);}});/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */function AnimationClip(name,duration,tracks){this.name=name;this.tracks=tracks;this.duration=duration!==undefined?duration:-1;this.uuid=_Math.generateUUID();// this means it should figure out its duration by scanning the tracks
if(this.duration<0){this.resetDuration();}this.optimize();}Object.assign(AnimationClip,{parse:function(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var i=0,n=jsonTracks.length;i!==n;++i){tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));}return new AnimationClip(json.name,json.duration,tracks);},toJSON:function(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks};for(var i=0,n=clipTracks.length;i!==n;++i){tracks.push(KeyframeTrack.toJSON(clipTracks[i]));}return json;},CreateFromMorphTargetSequence:function(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var i=0;i<numMorphTargets;i++){var times=[];var values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
// last frame as well for perfect loop.
if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[i].name+']',times,values).scale(1.0/fps));}return new AnimationClip(name,-1,tracks);},findByName:function(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var i=0;i<clipArray.length;i++){if(clipArray[i].name===name){return clipArray[i];}}return null;},CreateClipsFromMorphTargetSequences:function(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(var i=0,il=morphTargets.length;i<il;i++){var morphTarget=morphTargets[i];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var name in animationToMorphTargets){clips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));}return clips;},// parse the animation.hierarchy format
parseAnimation:function(animation,bones){if(!animation){console.error("  no animation in JSONLoader data");return null;}var addNonemptyTrack=function(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';// automatic length determination in AnimationClip.
var duration=animation.length||-1;var fps=animation.fps||30;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
if(!animationKeys||animationKeys.length===0)continue;// process morph targets in a way exactly compatible
// with AnimationHandler.init( animation )
if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
var morphTargetNames={};for(var k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var m=0;m!==animationKeys[k].morphTargets.length;++m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else{// ...assume skeletal animation
var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new AnimationClip(clipName,duration,tracks);return clip;}});Object.assign(AnimationClip.prototype,{resetDuration:function(){var tracks=this.tracks,duration=0;for(var i=0,n=tracks.length;i!==n;++i){var track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;},trim:function(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].trim(0,this.duration);}return this;},optimize:function(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].optimize();}return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function MaterialLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.textures={};}Object.assign(MaterialLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.setResponseType('json');loader.load(url,function(json){onLoad(scope.parse(json));},onProgress,onError);},setTextures:function(value){this.textures=value;},parse:function(json){var textures=this.textures;function getTexture(name){if(textures[name]===undefined){console.warn('THREE.MaterialLoader: Undefined texture',name);}return textures[name];}var material=new Materials[json.type]();if(json.uuid!==undefined)material.uuid=json.uuid;if(json.name!==undefined)material.name=json.name;if(json.color!==undefined)material.color.setHex(json.color);if(json.roughness!==undefined)material.roughness=json.roughness;if(json.metalness!==undefined)material.metalness=json.metalness;if(json.emissive!==undefined)material.emissive.setHex(json.emissive);if(json.specular!==undefined)material.specular.setHex(json.specular);if(json.shininess!==undefined)material.shininess=json.shininess;if(json.clearCoat!==undefined)material.clearCoat=json.clearCoat;if(json.clearCoatRoughness!==undefined)material.clearCoatRoughness=json.clearCoatRoughness;if(json.uniforms!==undefined)material.uniforms=json.uniforms;if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;if(json.vertexColors!==undefined)material.vertexColors=json.vertexColors;if(json.fog!==undefined)material.fog=json.fog;if(json.shading!==undefined)material.shading=json.shading;if(json.blending!==undefined)material.blending=json.blending;if(json.side!==undefined)material.side=json.side;if(json.opacity!==undefined)material.opacity=json.opacity;if(json.transparent!==undefined)material.transparent=json.transparent;if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;if(json.depthTest!==undefined)material.depthTest=json.depthTest;if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;if(json.wireframe!==undefined)material.wireframe=json.wireframe;if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;if(json.skinning!==undefined)material.skinning=json.skinning;if(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;// for PointsMaterial
if(json.size!==undefined)material.size=json.size;if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;// maps
if(json.map!==undefined)material.map=getTexture(json.map);if(json.alphaMap!==undefined){material.alphaMap=getTexture(json.alphaMap);material.transparent=true;}if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);if(json.normalScale!==undefined){var normalScale=json.normalScale;if(Array.isArray(normalScale)===false){// Blender exporter used to export a scalar. See #7459
normalScale=[normalScale,normalScale];}material.normalScale=new Vector2().fromArray(normalScale);}if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);return material;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function BufferGeometryLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(BufferGeometryLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.setResponseType('json');loader.load(url,function(json){onLoad(scope.parse(json));},onProgress,onError);},parse:function(json){var geometry=new BufferGeometry();var index=json.data.index;if(index!==undefined){var typedArray=new TYPED_ARRAYS[index.type](index.array);geometry.setIndex(new BufferAttribute(typedArray,1));}var attributes=json.data.attributes;for(var key in attributes){var attribute=attributes[key];var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);geometry.addAttribute(key,new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized));}var groups=json.data.groups||json.data.drawcalls||json.data.offsets;if(groups!==undefined){for(var i=0,n=groups.length;i!==n;++i){var group=groups[i];geometry.addGroup(group.start,group.count,group.materialIndex);}}var boundingSphere=json.data.boundingSphere;if(boundingSphere!==undefined){var center=new Vector3();if(boundingSphere.center!==undefined){center.fromArray(boundingSphere.center);}geometry.boundingSphere=new Sphere(center,boundingSphere.radius);}return geometry;}});var TYPED_ARRAYS={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};/**
 * @author alteredq / http://alteredqualia.com/
 */function Loader(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};}Loader.Handlers={handlers:[],add:function(regex,loader){this.handlers.push(regex,loader);},get:function(file){var handlers=this.handlers;for(var i=0,l=handlers.length;i<l;i+=2){var regex=handlers[i];var loader=handlers[i+1];if(regex.test(file)){return loader;}}return null;}};Object.assign(Loader.prototype,{crossOrigin:undefined,extractUrlBase:function(url){var parts=url.split('/');if(parts.length===1)return'./';parts.pop();return parts.join('/')+'/';},initMaterials:function(materials,texturePath,crossOrigin){var array=[];for(var i=0;i<materials.length;++i){array[i]=this.createMaterial(materials[i],texturePath,crossOrigin);}return array;},createMaterial:function(){var BlendingMode={NoBlending:NoBlending,NormalBlending:NormalBlending,AdditiveBlending:AdditiveBlending,SubtractiveBlending:SubtractiveBlending,MultiplyBlending:MultiplyBlending,CustomBlending:CustomBlending};var color=new Color();var textureLoader=new TextureLoader();var materialLoader=new MaterialLoader();return function createMaterial(m,texturePath,crossOrigin){// convert from old material format
var textures={};function loadTexture(path,repeat,offset,wrap,anisotropy){var fullPath=texturePath+path;var loader=Loader.Handlers.get(fullPath);var texture;if(loader!==null){texture=loader.load(fullPath);}else{textureLoader.setCrossOrigin(crossOrigin);texture=textureLoader.load(fullPath);}if(repeat!==undefined){texture.repeat.fromArray(repeat);if(repeat[0]!==1)texture.wrapS=RepeatWrapping;if(repeat[1]!==1)texture.wrapT=RepeatWrapping;}if(offset!==undefined){texture.offset.fromArray(offset);}if(wrap!==undefined){if(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;if(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;if(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;if(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;}if(anisotropy!==undefined){texture.anisotropy=anisotropy;}var uuid=_Math.generateUUID();textures[uuid]=texture;return uuid;}//
var json={uuid:_Math.generateUUID(),type:'MeshLambertMaterial'};for(var name in m){var value=m[name];switch(name){case'DbgColor':case'DbgIndex':case'opticalDensity':case'illumination':break;case'DbgName':json.name=value;break;case'blending':json.blending=BlendingMode[value];break;case'colorAmbient':case'mapAmbient':console.warn('THREE.Loader.createMaterial:',name,'is no longer supported.');break;case'colorDiffuse':json.color=color.fromArray(value).getHex();break;case'colorSpecular':json.specular=color.fromArray(value).getHex();break;case'colorEmissive':json.emissive=color.fromArray(value).getHex();break;case'specularCoef':json.shininess=value;break;case'shading':if(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';if(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';if(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';break;case'mapDiffuse':json.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);break;case'mapDiffuseRepeat':case'mapDiffuseOffset':case'mapDiffuseWrap':case'mapDiffuseAnisotropy':break;case'mapEmissive':json.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);break;case'mapEmissiveRepeat':case'mapEmissiveOffset':case'mapEmissiveWrap':case'mapEmissiveAnisotropy':break;case'mapLight':json.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);break;case'mapLightRepeat':case'mapLightOffset':case'mapLightWrap':case'mapLightAnisotropy':break;case'mapAO':json.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);break;case'mapAORepeat':case'mapAOOffset':case'mapAOWrap':case'mapAOAnisotropy':break;case'mapBump':json.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);break;case'mapBumpScale':json.bumpScale=value;break;case'mapBumpRepeat':case'mapBumpOffset':case'mapBumpWrap':case'mapBumpAnisotropy':break;case'mapNormal':json.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);break;case'mapNormalFactor':json.normalScale=[value,value];break;case'mapNormalRepeat':case'mapNormalOffset':case'mapNormalWrap':case'mapNormalAnisotropy':break;case'mapSpecular':json.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);break;case'mapSpecularRepeat':case'mapSpecularOffset':case'mapSpecularWrap':case'mapSpecularAnisotropy':break;case'mapMetalness':json.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);break;case'mapMetalnessRepeat':case'mapMetalnessOffset':case'mapMetalnessWrap':case'mapMetalnessAnisotropy':break;case'mapRoughness':json.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);break;case'mapRoughnessRepeat':case'mapRoughnessOffset':case'mapRoughnessWrap':case'mapRoughnessAnisotropy':break;case'mapAlpha':json.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);break;case'mapAlphaRepeat':case'mapAlphaOffset':case'mapAlphaWrap':case'mapAlphaAnisotropy':break;case'flipSided':json.side=BackSide;break;case'doubleSided':json.side=DoubleSide;break;case'transparency':console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');json.opacity=value;break;case'depthTest':case'depthWrite':case'colorWrite':case'opacity':case'reflectivity':case'transparent':case'visible':case'wireframe':json[name]=value;break;case'vertexColors':if(value===true)json.vertexColors=VertexColors;if(value==='face')json.vertexColors=FaceColors;break;default:console.error('THREE.Loader.createMaterial: Unsupported',name,value);break;}}if(json.type==='MeshBasicMaterial')delete json.emissive;if(json.type!=='MeshPhongMaterial')delete json.specular;if(json.opacity<1)json.transparent=true;materialLoader.setTextures(textures);return materialLoader.parse(json);};}()});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function JSONLoader(manager){if(typeof manager==='boolean'){console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');manager=undefined;}this.manager=manager!==undefined?manager:DefaultLoadingManager;this.withCredentials=false;}Object.assign(JSONLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var texturePath=this.texturePath&&typeof this.texturePath==="string"?this.texturePath:Loader.prototype.extractUrlBase(url);var loader=new FileLoader(this.manager);loader.setResponseType('json');loader.setWithCredentials(this.withCredentials);loader.load(url,function(json){var metadata=json.metadata;if(metadata!==undefined){var type=metadata.type;if(type!==undefined){if(type.toLowerCase()==='object'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.ObjectLoader instead.');return;}if(type.toLowerCase()==='scene'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.SceneLoader instead.');return;}}}var object=scope.parse(json,texturePath);onLoad(object.geometry,object.materials);},onProgress,onError);},setTexturePath:function(value){this.texturePath=value;},parse:function(){function parseModel(json,geometry){function isBitSet(value,position){return value&1<<position;}var i,j,fi,offset,zLength,colorIndex,normalIndex,uvIndex,materialIndex,type,isQuad,hasMaterial,hasFaceVertexUv,hasFaceNormal,hasFaceVertexNormal,hasFaceColor,hasFaceVertexColor,vertex,face,faceA,faceB,hex,normal,uvLayer,uv,u,v,faces=json.faces,vertices=json.vertices,normals=json.normals,colors=json.colors,scale=json.scale,nUvLayers=0;if(json.uvs!==undefined){// disregard empty arrays
for(i=0;i<json.uvs.length;i++){if(json.uvs[i].length)nUvLayers++;}for(i=0;i<nUvLayers;i++){geometry.faceVertexUvs[i]=[];}}offset=0;zLength=vertices.length;while(offset<zLength){vertex=new Vector3();vertex.x=vertices[offset++]*scale;vertex.y=vertices[offset++]*scale;vertex.z=vertices[offset++]*scale;geometry.vertices.push(vertex);}offset=0;zLength=faces.length;while(offset<zLength){type=faces[offset++];isQuad=isBitSet(type,0);hasMaterial=isBitSet(type,1);hasFaceVertexUv=isBitSet(type,3);hasFaceNormal=isBitSet(type,4);hasFaceVertexNormal=isBitSet(type,5);hasFaceColor=isBitSet(type,6);hasFaceVertexColor=isBitSet(type,7);// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
if(isQuad){faceA=new Face3();faceA.a=faces[offset];faceA.b=faces[offset+1];faceA.c=faces[offset+3];faceB=new Face3();faceB.a=faces[offset+1];faceB.b=faces[offset+2];faceB.c=faces[offset+3];offset+=4;if(hasMaterial){materialIndex=faces[offset++];faceA.materialIndex=materialIndex;faceB.materialIndex=materialIndex;}// to get face <=> uv index correspondence
fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];geometry.faceVertexUvs[i][fi+1]=[];for(j=0;j<4;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);if(j!==2)geometry.faceVertexUvs[i][fi].push(uv);if(j!==0)geometry.faceVertexUvs[i][fi+1].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;faceA.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);faceB.normal.copy(faceA.normal);}if(hasFaceVertexNormal){for(i=0;i<4;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);if(i!==2)faceA.vertexNormals.push(normal);if(i!==0)faceB.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];hex=colors[colorIndex];faceA.color.setHex(hex);faceB.color.setHex(hex);}if(hasFaceVertexColor){for(i=0;i<4;i++){colorIndex=faces[offset++];hex=colors[colorIndex];if(i!==2)faceA.vertexColors.push(new Color(hex));if(i!==0)faceB.vertexColors.push(new Color(hex));}}geometry.faces.push(faceA);geometry.faces.push(faceB);}else{face=new Face3();face.a=faces[offset++];face.b=faces[offset++];face.c=faces[offset++];if(hasMaterial){materialIndex=faces[offset++];face.materialIndex=materialIndex;}// to get face <=> uv index correspondence
fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];for(j=0;j<3;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);geometry.faceVertexUvs[i][fi].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;face.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);}if(hasFaceVertexNormal){for(i=0;i<3;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);face.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];face.color.setHex(colors[colorIndex]);}if(hasFaceVertexColor){for(i=0;i<3;i++){colorIndex=faces[offset++];face.vertexColors.push(new Color(colors[colorIndex]));}}geometry.faces.push(face);}}}function parseSkin(json,geometry){var influencesPerVertex=json.influencesPerVertex!==undefined?json.influencesPerVertex:2;if(json.skinWeights){for(var i=0,l=json.skinWeights.length;i<l;i+=influencesPerVertex){var x=json.skinWeights[i];var y=influencesPerVertex>1?json.skinWeights[i+1]:0;var z=influencesPerVertex>2?json.skinWeights[i+2]:0;var w=influencesPerVertex>3?json.skinWeights[i+3]:0;geometry.skinWeights.push(new Vector4(x,y,z,w));}}if(json.skinIndices){for(var i=0,l=json.skinIndices.length;i<l;i+=influencesPerVertex){var a=json.skinIndices[i];var b=influencesPerVertex>1?json.skinIndices[i+1]:0;var c=influencesPerVertex>2?json.skinIndices[i+2]:0;var d=influencesPerVertex>3?json.skinIndices[i+3]:0;geometry.skinIndices.push(new Vector4(a,b,c,d));}}geometry.bones=json.bones;if(geometry.bones&&geometry.bones.length>0&&(geometry.skinWeights.length!==geometry.skinIndices.length||geometry.skinIndices.length!==geometry.vertices.length)){console.warn('When skinning, number of vertices ('+geometry.vertices.length+'), skinIndices ('+geometry.skinIndices.length+'), and skinWeights ('+geometry.skinWeights.length+') should match.');}}function parseMorphing(json,geometry){var scale=json.scale;if(json.morphTargets!==undefined){for(var i=0,l=json.morphTargets.length;i<l;i++){geometry.morphTargets[i]={};geometry.morphTargets[i].name=json.morphTargets[i].name;geometry.morphTargets[i].vertices=[];var dstVertices=geometry.morphTargets[i].vertices;var srcVertices=json.morphTargets[i].vertices;for(var v=0,vl=srcVertices.length;v<vl;v+=3){var vertex=new Vector3();vertex.x=srcVertices[v]*scale;vertex.y=srcVertices[v+1]*scale;vertex.z=srcVertices[v+2]*scale;dstVertices.push(vertex);}}}if(json.morphColors!==undefined&&json.morphColors.length>0){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var faces=geometry.faces;var morphColors=json.morphColors[0].colors;for(var i=0,l=faces.length;i<l;i++){faces[i].color.fromArray(morphColors,i*3);}}}function parseAnimations(json,geometry){var outputAnimations=[];// parse old style Bone/Hierarchy animations
var animations=[];if(json.animation!==undefined){animations.push(json.animation);}if(json.animations!==undefined){if(json.animations.length){animations=animations.concat(json.animations);}else{animations.push(json.animations);}}for(var i=0;i<animations.length;i++){var clip=AnimationClip.parseAnimation(animations[i],geometry.bones);if(clip)outputAnimations.push(clip);}// parse implicit morph animations
if(geometry.morphTargets){// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
var morphAnimationClips=AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets,10);outputAnimations=outputAnimations.concat(morphAnimationClips);}if(outputAnimations.length>0)geometry.animations=outputAnimations;}return function(json,texturePath){if(json.data!==undefined){// Geometry 4.0 spec
json=json.data;}if(json.scale!==undefined){json.scale=1.0/json.scale;}else{json.scale=1.0;}var geometry=new Geometry();parseModel(json,geometry);parseSkin(json,geometry);parseMorphing(json,geometry);parseAnimations(json,geometry);geometry.computeFaceNormals();geometry.computeBoundingSphere();if(json.materials===undefined||json.materials.length===0){return{geometry:geometry};}else{var materials=Loader.prototype.initMaterials(json.materials,texturePath,this.crossOrigin);return{geometry:geometry,materials:materials};}};}()});/**
 * @author mrdoob / http://mrdoob.com/
 */function ObjectLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.texturePath='';}Object.assign(ObjectLoader.prototype,{load:function(url,onLoad,onProgress,onError){if(this.texturePath===''){this.texturePath=url.substring(0,url.lastIndexOf('/')+1);}var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){var json=null;try{json=JSON.parse(text);}catch(error){if(onError!==undefined)onError(error);console.error('THREE:ObjectLoader: Can\'t parse '+url+'.',error.message);return;}var metadata=json.metadata;if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){console.error('THREE.ObjectLoader: Can\'t load '+url+'. Use THREE.JSONLoader instead.');return;}scope.parse(json,onLoad);},onProgress,onError);},setTexturePath:function(value){this.texturePath=value;},setCrossOrigin:function(value){this.crossOrigin=value;},parse:function(json,onLoad){var geometries=this.parseGeometries(json.geometries);var images=this.parseImages(json.images,function(){if(onLoad!==undefined)onLoad(object);});var textures=this.parseTextures(json.textures,images);var materials=this.parseMaterials(json.materials,textures);var object=this.parseObject(json.object,geometries,materials);if(json.animations){object.animations=this.parseAnimations(json.animations);}if(json.images===undefined||json.images.length===0){if(onLoad!==undefined)onLoad(object);}return object;},parseGeometries:function(json){var geometries={};if(json!==undefined){var geometryLoader=new JSONLoader();var bufferGeometryLoader=new BufferGeometryLoader();for(var i=0,l=json.length;i<l;i++){var geometry;var data=json[i];switch(data.type){case'PlaneGeometry':case'PlaneBufferGeometry':geometry=new Geometries[data.type](data.width,data.height,data.widthSegments,data.heightSegments);break;case'BoxGeometry':case'BoxBufferGeometry':case'CubeGeometry':// backwards compatible
geometry=new Geometries[data.type](data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);break;case'CircleGeometry':case'CircleBufferGeometry':geometry=new Geometries[data.type](data.radius,data.segments,data.thetaStart,data.thetaLength);break;case'CylinderGeometry':case'CylinderBufferGeometry':geometry=new Geometries[data.type](data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'ConeGeometry':case'ConeBufferGeometry':geometry=new Geometries[data.type](data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'SphereGeometry':case'SphereBufferGeometry':geometry=new Geometries[data.type](data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);break;case'DodecahedronGeometry':case'IcosahedronGeometry':case'OctahedronGeometry':case'TetrahedronGeometry':geometry=new Geometries[data.type](data.radius,data.detail);break;case'RingGeometry':case'RingBufferGeometry':geometry=new Geometries[data.type](data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);break;case'TorusGeometry':case'TorusBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc);break;case'TorusKnotGeometry':case'TorusKnotBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q);break;case'LatheGeometry':case'LatheBufferGeometry':geometry=new Geometries[data.type](data.points,data.segments,data.phiStart,data.phiLength);break;case'BufferGeometry':geometry=bufferGeometryLoader.parse(data);break;case'Geometry':geometry=geometryLoader.parse(data,this.texturePath).geometry;break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+data.type+'"');continue;}geometry.uuid=data.uuid;if(data.name!==undefined)geometry.name=data.name;geometries[data.uuid]=geometry;}}return geometries;},parseMaterials:function(json,textures){var materials={};if(json!==undefined){var loader=new MaterialLoader();loader.setTextures(textures);for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.type==='MultiMaterial'){// Deprecated
var array=[];for(var j=0;j<data.materials.length;j++){array.push(loader.parse(data.materials[j]));}materials[data.uuid]=array;}else{materials[data.uuid]=loader.parse(data);}}}return materials;},parseAnimations:function(json){var animations=[];for(var i=0;i<json.length;i++){var clip=AnimationClip.parse(json[i]);animations.push(clip);}return animations;},parseImages:function(json,onLoad){var scope=this;var images={};function loadImage(url){scope.manager.itemStart(url);return loader.load(url,function(){scope.manager.itemEnd(url);},undefined,function(){scope.manager.itemEnd(url);scope.manager.itemError(url);});}if(json!==undefined&&json.length>0){var manager=new LoadingManager(onLoad);var loader=new ImageLoader(manager);loader.setCrossOrigin(this.crossOrigin);for(var i=0,l=json.length;i<l;i++){var image=json[i];var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url)?image.url:scope.texturePath+image.url;images[image.uuid]=loadImage(path);}}return images;},parseTextures:function(json,images){function parseConstant(value,type){if(typeof value==='number')return value;console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);return type[value];}var textures={};if(json!==undefined){for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.image===undefined){console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);}if(images[data.image]===undefined){console.warn('THREE.ObjectLoader: Undefined image',data.image);}var texture=new Texture(images[data.image]);texture.needsUpdate=true;texture.uuid=data.uuid;if(data.name!==undefined)texture.name=data.name;if(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING);if(data.offset!==undefined)texture.offset.fromArray(data.offset);if(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);if(data.wrap!==undefined){texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING);texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING);}if(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER);if(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER);if(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;if(data.flipY!==undefined)texture.flipY=data.flipY;textures[data.uuid]=texture;}}return textures;},parseObject:function(){var matrix=new Matrix4();return function parseObject(data,geometries,materials){var object;function getGeometry(name){if(geometries[name]===undefined){console.warn('THREE.ObjectLoader: Undefined geometry',name);}return geometries[name];}function getMaterial(name){if(name===undefined)return undefined;if(Array.isArray(name)){var array=[];for(var i=0,l=name.length;i<l;i++){var uuid=name[i];if(materials[uuid]===undefined){console.warn('THREE.ObjectLoader: Undefined material',uuid);}array.push(materials[uuid]);}return array;}if(materials[name]===undefined){console.warn('THREE.ObjectLoader: Undefined material',name);}return materials[name];}switch(data.type){case'Scene':object=new Scene();if(data.background!==undefined){if(Number.isInteger(data.background)){object.background=new Color(data.background);}}if(data.fog!==undefined){if(data.fog.type==='Fog'){object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);}else if(data.fog.type==='FogExp2'){object.fog=new FogExp2(data.fog.color,data.fog.density);}}break;case'PerspectiveCamera':object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);if(data.focus!==undefined)object.focus=data.focus;if(data.zoom!==undefined)object.zoom=data.zoom;if(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;if(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;if(data.view!==undefined)object.view=Object.assign({},data.view);break;case'OrthographicCamera':object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);break;case'AmbientLight':object=new AmbientLight(data.color,data.intensity);break;case'DirectionalLight':object=new DirectionalLight(data.color,data.intensity);break;case'PointLight':object=new PointLight(data.color,data.intensity,data.distance,data.decay);break;case'RectAreaLight':object=new RectAreaLight(data.color,data.intensity,data.width,data.height);break;case'SpotLight':object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case'HemisphereLight':object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case'SkinnedMesh':console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');case'Mesh':var geometry=getGeometry(data.geometry);var material=getMaterial(data.material);if(geometry.bones&&geometry.bones.length>0){object=new SkinnedMesh(geometry,material);}else{object=new Mesh(geometry,material);}break;case'LOD':object=new LOD();break;case'Line':object=new Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);break;case'LineLoop':object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));break;case'LineSegments':object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case'PointCloud':case'Points':object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case'Sprite':object=new Sprite(getMaterial(data.material));break;case'Group':object=new Group();break;default:object=new Object3D();}object.uuid=data.uuid;if(data.name!==undefined)object.name=data.name;if(data.matrix!==undefined){matrix.fromArray(data.matrix);matrix.decompose(object.position,object.quaternion,object.scale);}else{if(data.position!==undefined)object.position.fromArray(data.position);if(data.rotation!==undefined)object.rotation.fromArray(data.rotation);if(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);if(data.scale!==undefined)object.scale.fromArray(data.scale);}if(data.castShadow!==undefined)object.castShadow=data.castShadow;if(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;if(data.shadow){if(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;if(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;if(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);if(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);}if(data.visible!==undefined)object.visible=data.visible;if(data.userData!==undefined)object.userData=data.userData;if(data.children!==undefined){for(var child in data.children){object.add(this.parseObject(data.children[child],geometries,materials));}}if(data.type==='LOD'){var levels=data.levels;for(var l=0;l<levels.length;l++){var level=levels[l];var child=object.getObjectByProperty('uuid',level.object);if(child!==undefined){object.addLevel(child,level.distance);}}}return object;};}()});var TEXTURE_MAPPING={UVMapping:UVMapping,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,SphericalReflectionMapping:SphericalReflectionMapping,CubeUVReflectionMapping:CubeUVReflectionMapping,CubeUVRefractionMapping:CubeUVRefractionMapping};var TEXTURE_WRAPPING={RepeatWrapping:RepeatWrapping,ClampToEdgeWrapping:ClampToEdgeWrapping,MirroredRepeatWrapping:MirroredRepeatWrapping};var TEXTURE_FILTER={NearestFilter:NearestFilter,NearestMipMapNearestFilter:NearestMipMapNearestFilter,NearestMipMapLinearFilter:NearestMipMapLinearFilter,LinearFilter:LinearFilter,LinearMipMapNearestFilter:LinearMipMapNearestFilter,LinearMipMapLinearFilter:LinearMipMapLinearFilter};/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTangentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **//**************************************************************
 *	Abstract Curve base class
 **************************************************************/function Curve(){this.arcLengthDivisions=200;}Object.assign(Curve.prototype,{// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint:function(){console.warn('THREE.Curve: .getPoint() not implemented.');return null;},// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt:function(u){var t=this.getUtoTmapping(u);return this.getPoint(t);},// Get sequence of points using getPoint( t )
getPoints:function(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;},// Get sequence of points using getPointAt( u )
getSpacedPoints:function(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;},// Get total curve arc length
getLength:function(){var lengths=this.getLengths();return lengths[lengths.length-1];},// Get list of cumulative segment lengths
getLengths:function(divisions){if(divisions===undefined)divisions=this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var p,sum=0;cache.push(0);for(p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
},updateArcLengths:function(){this.needsUpdate=true;this.getLengths();},// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping:function(u,distance){var arcLengths=this.getLengths();var i=0,il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
}}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
var t=(i+segmentFraction)/(il-1);return t;},// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent:function(t){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var vec=pt2.clone().sub(pt1);return vec.normalize();},getTangentAt:function(u){var t=this.getUtoTmapping(u);return this.getTangent(t);},computeFrenetFrames:function(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4();var i,u,theta;// compute the tangent vectors for each segment on the curve
for(i=0;i<=segments;i++){u=i/segments;tangents[i]=this.getTangentAt(u);tangents[i].normalize();}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(i=1;i<=segments;i++){normals[i]=normals[i-1].clone();binormals[i]=binormals[i-1].clone();vec.crossVectors(tangents[i-1],tangents[i]);if(vec.length()>Number.EPSILON){vec.normalize();theta=Math.acos(_Math.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors
normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[i].crossVectors(tangents[i],normals[i]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(closed===true){theta=Math.acos(_Math.clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){theta=-theta;}for(i=1;i<=segments;i++){// twist a little...
normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));binormals[i].crossVectors(tangents[i],normals[i]);}}return{tangents:tangents,normals:normals,binormals:binormals};}});function LineCurve(v1,v2){Curve.call(this);this.v1=v1;this.v2=v2;}LineCurve.prototype=Object.create(Curve.prototype);LineCurve.prototype.constructor=LineCurve;LineCurve.prototype.isLineCurve=true;LineCurve.prototype.getPoint=function(t){if(t===1){return this.v2.clone();}var point=this.v2.clone().sub(this.v1);point.multiplyScalar(t).add(this.v1);return point;};// Line curve is linear, so we can overwrite default getPointAt
LineCurve.prototype.getPointAt=function(u){return this.getPoint(u);};LineCurve.prototype.getTangent=function(t){var tangent=this.v2.clone().sub(this.v1);return tangent.normalize();};/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **//**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/function CurvePath(){Curve.call(this);this.curves=[];this.autoClose=false;// Automatically closes the path
}CurvePath.prototype=Object.assign(Object.create(Curve.prototype),{constructor:CurvePath,add:function(curve){this.curves.push(curve);},closePath:function(){// Add a line curve if start and end of lines are not connected
var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}},// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint:function(t){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
},// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength:function(){var lens=this.getCurveLengths();return lens[lens.length-1];},// cacheLengths must be recalculated.
updateArcLengths:function(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();},// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths:function(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
// Push sums into cached array
var lengths=[],sums=0;for(var i=0,l=this.curves.length;i<l;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;},getSpacedPoints:function(divisions){if(divisions===undefined)divisions=40;var points=[];for(var i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;},getPoints:function(divisions){divisions=divisions||12;var points=[],last;for(var i=0,curves=this.curves;i<curves.length;i++){var curve=curves[i];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&curve.isLineCurve?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;},/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************//// Generate geometry from path points (for Line or Points objects)
createPointsGeometry:function(divisions){var pts=this.getPoints(divisions);return this.createGeometry(pts);},// Generate geometry from equidistant sampling along the path
createSpacedPointsGeometry:function(divisions){var pts=this.getSpacedPoints(divisions);return this.createGeometry(pts);},createGeometry:function(points){var geometry=new Geometry();for(var i=0,l=points.length;i<l;i++){var point=points[i];geometry.vertices.push(new Vector3(point.x,point.y,point.z||0));}return geometry;}});function EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){Curve.call(this);this.aX=aX;this.aY=aY;this.xRadius=xRadius;this.yRadius=yRadius;this.aStartAngle=aStartAngle;this.aEndAngle=aEndAngle;this.aClockwise=aClockwise;this.aRotation=aRotation||0;}EllipseCurve.prototype=Object.create(Curve.prototype);EllipseCurve.prototype.constructor=EllipseCurve;EllipseCurve.prototype.isEllipseCurve=true;EllipseCurve.prototype.getPoint=function(t){var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
while(deltaAngle<0)deltaAngle+=twoPi;while(deltaAngle>twoPi)deltaAngle-=twoPi;if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return new Vector2(x,y);};function SplineCurve(points/* array of Vector2 */){Curve.call(this);this.points=points===undefined?[]:points;}SplineCurve.prototype=Object.create(Curve.prototype);SplineCurve.prototype.constructor=SplineCurve;SplineCurve.prototype.isSplineCurve=true;SplineCurve.prototype.getPoint=function(t){var points=this.points;var point=(points.length-1)*t;var intPoint=Math.floor(point);var weight=point-intPoint;var point0=points[intPoint===0?intPoint:intPoint-1];var point1=points[intPoint];var point2=points[intPoint>points.length-2?points.length-1:intPoint+1];var point3=points[intPoint>points.length-3?points.length-1:intPoint+2];return new Vector2(CatmullRom(weight,point0.x,point1.x,point2.x,point3.x),CatmullRom(weight,point0.y,point1.y,point2.y,point3.y));};function CubicBezierCurve(v0,v1,v2,v3){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}CubicBezierCurve.prototype=Object.create(Curve.prototype);CubicBezierCurve.prototype.constructor=CubicBezierCurve;CubicBezierCurve.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;return new Vector2(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));};function QuadraticBezierCurve(v0,v1,v2){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;}QuadraticBezierCurve.prototype=Object.create(Curve.prototype);QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;QuadraticBezierCurve.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2;return new Vector2(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));};var PathPrototype=Object.assign(Object.create(CurvePath.prototype),{fromPoints:function(vectors){this.moveTo(vectors[0].x,vectors[0].y);for(var i=1,l=vectors.length;i<l;i++){this.lineTo(vectors[i].x,vectors[i].y);}},moveTo:function(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
},lineTo:function(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);},quadraticCurveTo:function(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},bezierCurveTo:function(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},splineThru:function(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);},arc:function(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);},absarc:function(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);},ellipse:function(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);},absellipse:function(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/function Path(points){CurvePath.call(this);this.currentPoint=new Vector2();if(points){this.fromPoints(points);}}Path.prototype=PathPrototype;PathPrototype.constructor=Path;/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.
function Shape(){Path.apply(this,arguments);this.holes=[];}Shape.prototype=Object.assign(Object.create(PathPrototype),{constructor:Shape,getPointsHoles:function(divisions){var holesPts=[];for(var i=0,l=this.holes.length;i<l;i++){holesPts[i]=this.holes[i].getPoints(divisions);}return holesPts;},// Get points of shape and holes (keypoints based on segments parameter)
extractAllPoints:function(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};},extractPoints:function(divisions){return this.extractAllPoints(divisions);}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/function ShapePath(){this.subPaths=[];this.currentPath=null;}Object.assign(ShapePath.prototype,{moveTo:function(x,y){this.currentPath=new Path();this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);},lineTo:function(x,y){this.currentPath.lineTo(x,y);},quadraticCurveTo:function(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);},bezierCurveTo:function(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);},splineThru:function(pts){this.currentPath.splineThru(pts);},toShapes:function(isCCW,noHoles){function toShapesNoHoles(inSubpaths){var shapes=[];for(var i=0,l=inSubpaths.length;i<l;i++){var tmpPath=inSubpaths[i];var tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);}return shapes;}function isPointInsidePolygon(inPt,inPolygon){var polyLen=inPolygon.length;// inPt on polygon contour => immediate success    or
// toggling of inside/outside at every single! intersection point of an edge
//  with the horizontal line through inPt, left of inPt
//  not counting lowerY endpoints of edges and whole edges on that line
var inside=false;for(var p=polyLen-1,q=0;q<polyLen;p=q++){var edgeLowPt=inPolygon[p];var edgeHighPt=inPolygon[q];var edgeDx=edgeHighPt.x-edgeLowPt.x;var edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>Number.EPSILON){// not parallel
if(edgeDy<0){edgeLowPt=inPolygon[q];edgeDx=-edgeDx;edgeHighPt=inPolygon[p];edgeDy=-edgeDy;}if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
// continue;				// no intersection or edgeLowPt => doesn't count !!!
}else{var perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return true;// inPt is on contour ?
if(perpEdge<0)continue;inside=!inside;// true intersection left of inPt
}}else{// parallel or collinear
if(inPt.y!==edgeLowPt.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
// continue;
}}return inside;}var isClockWise=ShapeUtils.isClockWise;var subPaths=this.subPaths;if(subPaths.length===0)return[];if(noHoles===true)return toShapesNoHoles(subPaths);var solid,tmpPath,tmpShape,shapes=[];if(subPaths.length===1){tmpPath=subPaths[0];tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);return shapes;}var holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;// console.log("Holes first", holesFirst);
var betterShapeHoles=[];var newShapes=[];var newShapeHoles=[];var mainIdx=0;var tmpPoints;newShapes[mainIdx]=undefined;newShapeHoles[mainIdx]=[];for(var i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();solid=isClockWise(tmpPoints);solid=isCCW?!solid:solid;if(solid){if(!holesFirst&&newShapes[mainIdx])mainIdx++;newShapes[mainIdx]={s:new Shape(),p:tmpPoints};newShapes[mainIdx].s.curves=tmpPath.curves;if(holesFirst)mainIdx++;newShapeHoles[mainIdx]=[];//console.log('cw', i);
}else{newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});//console.log('ccw', i);
}}// only Holes? -> probably all Shapes with wrong orientation
if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){var ambiguous=false;var toChange=[];for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){betterShapeHoles[sIdx]=[];}for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){var sho=newShapeHoles[sIdx];for(var hIdx=0;hIdx<sho.length;hIdx++){var ho=sho[hIdx];var hole_unassigned=true;for(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});if(hole_unassigned){hole_unassigned=false;betterShapeHoles[s2Idx].push(ho);}else{ambiguous=true;}}}if(hole_unassigned){betterShapeHoles[sIdx].push(ho);}}}// console.log("ambiguous: ", ambiguous);
if(toChange.length>0){// console.log("to change: ", toChange);
if(!ambiguous)newShapeHoles=betterShapeHoles;}}var tmpHoles;for(var i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes.push(tmpShape);tmpHoles=newShapeHoles[i];for(var j=0,jl=tmpHoles.length;j<jl;j++){tmpShape.holes.push(tmpHoles[j].h);}}//console.log("shape", shapes);
return shapes;}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */function Font(data){this.data=data;}Object.assign(Font.prototype,{isFont:true,generateShapes:function(text,size,divisions){function createPaths(text){var chars=String(text).split('');var scale=size/data.resolution;var line_height=(data.boundingBox.yMax-data.boundingBox.yMin+data.underlineThickness)*scale;var offsetX=0,offsetY=0;var paths=[];for(var i=0;i<chars.length;i++){var char=chars[i];if(char==='\n'){offsetX=0;offsetY-=line_height;}else{var ret=createPath(char,scale,offsetX,offsetY);offsetX+=ret.offsetX;paths.push(ret.path);}}return paths;}function createPath(c,scale,offsetX,offsetY){var glyph=data.glyphs[c]||data.glyphs['?'];if(!glyph)return;var path=new ShapePath();var pts=[];var x,y,cpx,cpy,cpx0,cpy0,cpx1,cpy1,cpx2,cpy2,laste;if(glyph.o){var outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));for(var i=0,l=outline.length;i<l;){var action=outline[i++];switch(action){case'm':// moveTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.moveTo(x,y);break;case'l':// lineTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.lineTo(x,y);break;case'q':// quadraticCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;path.quadraticCurveTo(cpx1,cpy1,cpx,cpy);laste=pts[pts.length-1];if(laste){cpx0=laste.x;cpy0=laste.y;for(var i2=1;i2<=divisions;i2++){var t=i2/divisions;QuadraticBezier(t,cpx0,cpx1,cpx);QuadraticBezier(t,cpy0,cpy1,cpy);}}break;case'b':// bezierCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;cpx2=outline[i++]*scale+offsetX;cpy2=outline[i++]*scale+offsetY;path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);laste=pts[pts.length-1];if(laste){cpx0=laste.x;cpy0=laste.y;for(var i2=1;i2<=divisions;i2++){var t=i2/divisions;CubicBezier(t,cpx0,cpx1,cpx2,cpx);CubicBezier(t,cpy0,cpy1,cpy2,cpy);}}break;}}}return{offsetX:glyph.ha*scale,path:path};}//
if(size===undefined)size=100;if(divisions===undefined)divisions=4;var data=this.data;var paths=createPaths(text);var shapes=[];for(var p=0,pl=paths.length;p<pl;p++){Array.prototype.push.apply(shapes,paths[p].toShapes());}return shapes;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function FontLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(FontLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(this.manager);loader.load(url,function(text){var json;try{json=JSON.parse(text);}catch(e){console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');json=JSON.parse(text.substring(65,text.length-2));}var font=scope.parse(json);if(onLoad)onLoad(font);},onProgress,onError);},parse:function(json){return new Font(json);}});var context;var AudioContext={getContext:function(){if(context===undefined){context=new(window.AudioContext||window.webkitAudioContext)();}return context;},setContext:function(value){context=value;}};/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */function AudioLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(AudioLoader.prototype,{load:function(url,onLoad,onProgress,onError){var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var context=AudioContext.getContext();context.decodeAudioData(buffer,function(audioBuffer){onLoad(audioBuffer);});},onProgress,onError);}});/**
 * @author mrdoob / http://mrdoob.com/
 */function StereoCamera(){this.type='StereoCamera';this.aspect=1;this.eyeSep=0.064;this.cameraL=new PerspectiveCamera();this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=false;this.cameraR=new PerspectiveCamera();this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=false;}Object.assign(StereoCamera.prototype,{update:function(){var instance,focus,fov,aspect,near,far,zoom,eyeSep;var eyeRight=new Matrix4();var eyeLeft=new Matrix4();return function update(camera){var needsUpdate=instance!==this||focus!==camera.focus||fov!==camera.fov||aspect!==camera.aspect*this.aspect||near!==camera.near||far!==camera.far||zoom!==camera.zoom||eyeSep!==this.eyeSep;if(needsUpdate){instance=this;focus=camera.focus;fov=camera.fov;aspect=camera.aspect*this.aspect;near=camera.near;far=camera.far;zoom=camera.zoom;// Off-axis stereoscopic effect based on
// http://paulbourke.net/stereographics/stereorender/
var projectionMatrix=camera.projectionMatrix.clone();eyeSep=this.eyeSep/2;var eyeSepOnProjection=eyeSep*near/focus;var ymax=near*Math.tan(_Math.DEG2RAD*fov*0.5)/zoom;var xmin,xmax;// translate xOffset
eyeLeft.elements[12]=-eyeSep;eyeRight.elements[12]=eyeSep;// for left eye
xmin=-ymax*aspect+eyeSepOnProjection;xmax=ymax*aspect+eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraL.projectionMatrix.copy(projectionMatrix);// for right eye
xmin=-ymax*aspect-eyeSepOnProjection;xmax=ymax*aspect-eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraR.projectionMatrix.copy(projectionMatrix);}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);};}()});/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */function CubeCamera(near,far,cubeResolution){Object3D.call(this);this.type='CubeCamera';var fov=90,aspect=1;var cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.up.set(0,-1,0);cameraPX.lookAt(new Vector3(1,0,0));this.add(cameraPX);var cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.up.set(0,-1,0);cameraNX.lookAt(new Vector3(-1,0,0));this.add(cameraNX);var cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.up.set(0,0,1);cameraPY.lookAt(new Vector3(0,1,0));this.add(cameraPY);var cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.up.set(0,0,-1);cameraNY.lookAt(new Vector3(0,-1,0));this.add(cameraNY);var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new Vector3(0,0,1));this.add(cameraPZ);var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new Vector3(0,0,-1));this.add(cameraNZ);var options={format:RGBFormat,magFilter:LinearFilter,minFilter:LinearFilter};this.renderTarget=new WebGLRenderTargetCube(cubeResolution,cubeResolution,options);this.renderTarget.texture.name="CubeCamera";this.updateCubeMap=function(renderer,scene){if(this.parent===null)this.updateMatrixWorld();var renderTarget=this.renderTarget;var generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderTarget.activeCubeFace=0;renderer.render(scene,cameraPX,renderTarget);renderTarget.activeCubeFace=1;renderer.render(scene,cameraNX,renderTarget);renderTarget.activeCubeFace=2;renderer.render(scene,cameraPY,renderTarget);renderTarget.activeCubeFace=3;renderer.render(scene,cameraNY,renderTarget);renderTarget.activeCubeFace=4;renderer.render(scene,cameraPZ,renderTarget);renderTarget.texture.generateMipmaps=generateMipmaps;renderTarget.activeCubeFace=5;renderer.render(scene,cameraNZ,renderTarget);renderer.setRenderTarget(null);};}CubeCamera.prototype=Object.create(Object3D.prototype);CubeCamera.prototype.constructor=CubeCamera;/**
 * @author mrdoob / http://mrdoob.com/
 */function ArrayCamera(array){PerspectiveCamera.call(this);this.enabled=false;this.cameras=array||[];}ArrayCamera.prototype=Object.assign(Object.create(PerspectiveCamera.prototype),{constructor:ArrayCamera,isArrayCamera:true});/**
 * @author mrdoob / http://mrdoob.com/
 */function AudioListener(){Object3D.call(this);this.type='AudioListener';this.context=AudioContext.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;}AudioListener.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:AudioListener,getInput:function(){return this.gain;},removeFilter:function(){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);this.gain.connect(this.context.destination);this.filter=null;}},getFilter:function(){return this.filter;},setFilter:function(value){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);}else{this.gain.disconnect(this.context.destination);}this.filter=value;this.gain.connect(this.filter);this.filter.connect(this.context.destination);},getMasterVolume:function(){return this.gain.gain.value;},setMasterVolume:function(value){this.gain.gain.value=value;},updateMatrixWorld:function(){var position=new Vector3();var quaternion=new Quaternion();var scale=new Vector3();var orientation=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);var listener=this.context.listener;var up=this.up;this.matrixWorld.decompose(position,quaternion,scale);orientation.set(0,0,-1).applyQuaternion(quaternion);if(listener.positionX){listener.positionX.setValueAtTime(position.x,this.context.currentTime);listener.positionY.setValueAtTime(position.y,this.context.currentTime);listener.positionZ.setValueAtTime(position.z,this.context.currentTime);listener.forwardX.setValueAtTime(orientation.x,this.context.currentTime);listener.forwardY.setValueAtTime(orientation.y,this.context.currentTime);listener.forwardZ.setValueAtTime(orientation.z,this.context.currentTime);listener.upX.setValueAtTime(up.x,this.context.currentTime);listener.upY.setValueAtTime(up.y,this.context.currentTime);listener.upZ.setValueAtTime(up.z,this.context.currentTime);}else{listener.setPosition(position.x,position.y,position.z);listener.setOrientation(orientation.x,orientation.y,orientation.z,up.x,up.y,up.z);}};}()});/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */function Audio(listener){Object3D.call(this);this.type='Audio';this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());this.autoplay=false;this.buffer=null;this.loop=false;this.startTime=0;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.sourceType='empty';this.filters=[];}Audio.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Audio,getOutput:function(){return this.gain;},setNodeSource:function(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;},setBuffer:function(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;},play:function(){if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}var source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.onended=this.onEnded.bind(this);source.playbackRate.setValueAtTime(this.playbackRate,this.startTime);source.start(0,this.startTime);this.isPlaying=true;this.source=source;return this.connect();},pause:function(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.source.stop();this.startTime=this.context.currentTime;this.isPlaying=false;return this;},stop:function(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.source.stop();this.startTime=0;this.isPlaying=false;return this;},connect:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].connect(this.filters[i]);}this.filters[this.filters.length-1].connect(this.getOutput());}else{this.source.connect(this.getOutput());}return this;},disconnect:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].disconnect(this.filters[i]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else{this.source.disconnect(this.getOutput());}return this;},getFilters:function(){return this.filters;},setFilters:function(value){if(!value)value=[];if(this.isPlaying===true){this.disconnect();this.filters=value;this.connect();}else{this.filters=value;}return this;},getFilter:function(){return this.getFilters()[0];},setFilter:function(filter){return this.setFilters(filter?[filter]:[]);},setPlaybackRate:function(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime);}return this;},getPlaybackRate:function(){return this.playbackRate;},onEnded:function(){this.isPlaying=false;},getLoop:function(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;},setLoop:function(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;},getVolume:function(){return this.gain.gain.value;},setVolume:function(value){this.gain.gain.value=value;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function PositionalAudio(listener){Audio.call(this,listener);this.panner=this.context.createPanner();this.panner.connect(this.gain);}PositionalAudio.prototype=Object.assign(Object.create(Audio.prototype),{constructor:PositionalAudio,getOutput:function(){return this.panner;},getRefDistance:function(){return this.panner.refDistance;},setRefDistance:function(value){this.panner.refDistance=value;},getRolloffFactor:function(){return this.panner.rolloffFactor;},setRolloffFactor:function(value){this.panner.rolloffFactor=value;},getDistanceModel:function(){return this.panner.distanceModel;},setDistanceModel:function(value){this.panner.distanceModel=value;},getMaxDistance:function(){return this.panner.maxDistance;},setMaxDistance:function(value){this.panner.maxDistance=value;},updateMatrixWorld:function(){var position=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);position.setFromMatrixPosition(this.matrixWorld);this.panner.setPosition(position.x,position.y,position.z);};}()});/**
 * @author mrdoob / http://mrdoob.com/
 */function AudioAnalyser(audio,fftSize){this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize!==undefined?fftSize:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser);}Object.assign(AudioAnalyser.prototype,{getFrequencyData:function(){this.analyser.getByteFrequencyData(this.data);return this.data;},getAverageFrequency:function(){var value=0,data=this.getFrequencyData();for(var i=0;i<data.length;i++){value+=data[i];}return value/data.length;}});/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function PropertyMixer(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;var bufferType=Float64Array,mixFunction;switch(typeName){case'quaternion':mixFunction=this._slerp;break;case'string':case'bool':bufferType=Array;mixFunction=this._select;break;default:mixFunction=this._lerp;}this.buffer=new bufferType(valueSize*4);// layout: [ incoming | accu0 | accu1 | orig ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
this._mixBufferRegion=mixFunction;this.cumulativeWeight=0;this.useCount=0;this.referenceCount=0;}Object.assign(PropertyMixer.prototype,{// accumulate data in the 'incoming' region into 'accu<i>'
accumulate:function(accuIndex,weight){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
var buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride,currentWeight=this.cumulativeWeight;if(currentWeight===0){// accuN := incoming * weight
for(var i=0;i!==stride;++i){buffer[offset+i]=buffer[i];}currentWeight=weight;}else{// accuN := accuN + incoming * weight
currentWeight+=weight;var mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride);}this.cumulativeWeight=currentWeight;},// apply the state of 'accu<i>' to the binding when accus differ
apply:function(accuIndex){var stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,binding=this.binding;this.cumulativeWeight=0;if(weight<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
var originalValueOffset=stride*3;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride);}for(var i=stride,e=stride+stride;i!==e;++i){if(buffer[i]!==buffer[i+stride]){// value has changed -> update scene graph
binding.setValue(buffer,offset);break;}}},// remember the state of the bound property and copy it to both accus
saveOriginalState:function(){var binding=this.binding;var buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*3;binding.getValue(buffer,originalValueOffset);// accu[0..1] := orig -- initially detect changes against the original
for(var i=stride,e=originalValueOffset;i!==e;++i){buffer[i]=buffer[originalValueOffset+i%stride];}this.cumulativeWeight=0;},// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState:function(){var originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset);},// mix functions
_select:function(buffer,dstOffset,srcOffset,t,stride){if(t>=0.5){for(var i=0;i!==stride;++i){buffer[dstOffset+i]=buffer[srcOffset+i];}}},_slerp:function(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);},_lerp:function(buffer,dstOffset,srcOffset,t,stride){var s=1-t;for(var i=0;i!==stride;++i){var j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;}}});/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function Composite(targetGroup,path,optionalParsedPath){var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);}Object.assign(Composite.prototype,{getValue:function(array,offset){this.bind();// bind all binding
var firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
if(binding!==undefined)binding.getValue(array,offset);},setValue:function(array,offset){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].setValue(array,offset);}},bind:function(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].bind();}},unbind:function(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].unbind();}}});function PropertyBinding(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;}Object.assign(PropertyBinding,{Composite:Composite,create:function(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else{return new PropertyBinding.Composite(root,path,parsedPath);}},parseTrackName:function(){// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
var directoryRe=/((?:[\w-]+[\/:])*)/;// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
var nodeRe=/([\w-\.]+)?/;// Object on target node, and accessor. Name may contain only word
// characters. Accessor may contain any character except closing bracket.
var objectRe=/(?:\.([\w-]+)(?:\[(.+)\])?)?/;// Property and accessor. May contain only word characters. Accessor may
// contain any non-bracket characters.
var propertyRe=/\.([\w-]+)(?:\[(.+)\])?/;var trackRe=new RegExp(''+'^'+directoryRe.source+nodeRe.source+objectRe.source+propertyRe.source+'$');var supportedObjectNames=['material','materials','bones'];return function(trackName){var matches=trackRe.exec(trackName);if(!matches){throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);}var results={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],// required
propertyIndex:matches[6]};var lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');if(lastDot!==undefined&&lastDot!==-1){var objectName=results.nodeName.substring(lastDot+1);// Object names must be checked against a whitelist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
if(supportedObjectNames.indexOf(objectName)!==-1){results.nodeName=results.nodeName.substring(0,lastDot);results.objectName=objectName;}}if(results.propertyName===null||results.propertyName.length===0){throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);}return results;};}(),findNode:function(root,nodeName){if(!nodeName||nodeName===""||nodeName==="root"||nodeName==="."||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
if(root.skeleton){var searchSkeleton=function(skeleton){for(var i=0;i<skeleton.bones.length;i++){var bone=skeleton.bones[i];if(bone.name===nodeName){return bone;}}return null;};var bone=searchSkeleton(root.skeleton);if(bone){return bone;}}// search into node subtree.
if(root.children){var searchNodeSubtree=function(children){for(var i=0;i<children.length;i++){var childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}var result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};var subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;}});Object.assign(PropertyBinding.prototype,{// prototype, continued
// these are used to "bind" a nonexistent property
_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function getValue_direct(buffer,offset){buffer[offset]=this.node[this.propertyName];},function getValue_array(buffer,offset){var source=this.resolvedProperty;for(var i=0,n=source.length;i!==n;++i){buffer[offset++]=source[i];}},function getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];},function getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}],SetterByBindingTypeAndVersioning:[[// Direct
function setValue_direct(buffer,offset){this.node[this.propertyName]=buffer[offset];},function setValue_direct_setNeedsUpdate(buffer,offset){this.node[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.node[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// EntireArray
function setValue_array(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}},function setValue_array_setNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.needsUpdate=true;},function setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}],[// ArrayElement
function setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];},function setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// HasToFromArray
function setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);},function setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;},function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}]],getValue:function getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
},setValue:function getValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);},// create getter / setter pair for a property in the scene graph
bind:function(){var targetObject=this.node,parsedPath=this.parsedPath,objectName=parsedPath.objectName,propertyName=parsedPath.propertyName,propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
if(!targetObject){console.error("  trying to update node for track: "+this.path+" but it wasn't found.");return;}if(objectName){var objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(objectName){case'materials':if(!targetObject.material){console.error('  can not bind to material as node does not have a material',this);return;}if(!targetObject.material.materials){console.error('  can not bind to material.materials as node.material does not have a materials array',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('  can not bind to bones as node does not have a skeleton',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
for(var i=0;i<targetObject.length;i++){if(targetObject[i].name===objectIndex){objectIndex=i;break;}}break;default:if(targetObject[objectName]===undefined){console.error('  can not bind to objectName of node, undefined',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error("  trying to bind to objectIndex of objectName, but is undefined:",this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
var nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){var nodeName=parsedPath.nodeName;console.error("  trying to update property for track: "+nodeName+'.'+propertyName+" but it wasn't found.",targetObject);return;}// determine versioning scheme
var versioning=this.Versioning.None;if(targetObject.needsUpdate!==undefined){// material
versioning=this.Versioning.NeedsUpdate;this.targetObject=targetObject;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
versioning=this.Versioning.MatrixWorldNeedsUpdate;this.targetObject=targetObject;}// determine how the property gets bound
var bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
if(propertyName==="morphTargetInfluences"){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!targetObject.geometry){console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry',this);return;}if(!targetObject.geometry.morphTargets){console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets',this);return;}for(var i=0;i<this.node.geometry.morphTargets.length;i++){if(targetObject.geometry.morphTargets[i].name===propertyIndex){propertyIndex=i;break;}}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if(Array.isArray(nodeProperty)){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else{this.propertyName=propertyName;}// select getter / setter
this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];},unbind:function(){this.node=null;// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}});//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(PropertyBinding.prototype,{// initial state of these methods that calls 'bind'
_getValue_unbound:PropertyBinding.prototype.getValue,_setValue_unbound:PropertyBinding.prototype.setValue});/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 * 	-	Add objects you would otherwise pass as 'root' to the
 * 		constructor or the .clipAction method of AnimationMixer.
 *
 * 	-	Instead pass this object as 'root'.
 *
 * 	-	You can also add and remove objects later when the mixer
 * 		is running.
 *
 * Note:
 *
 *  	Objects of this class appear as one object to the mixer,
 *  	so cache control of the individual objects must be done
 *  	on the group.
 *
 * Limitation:
 *
 * 	- 	The animated properties must be compatible among the
 * 		all objects in the group.
 *
 *  -	A single property can either be controlled through a
 *  	target group or directly, but not both.
 *
 * @author tschw
 */function AnimationObjectGroup(var_args){this.uuid=_Math.generateUUID();// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;// threshold
// note: read by PropertyBinding.Composite
var indices={};this._indicesByUUID=indices;// for bookkeeping
for(var i=0,n=arguments.length;i!==n;++i){indices[arguments[i].uuid]=i;}this._paths=[];// inside: string
this._parsedPaths=[];// inside: { we don't care, here }
this._bindings=[];// inside: Array< PropertyBinding >
this._bindingsIndicesByPath={};// inside: indices in these arrays
var scope=this;this.stats={objects:{get total(){return scope._objects.length;},get inUse(){return this.total-scope.nCachedObjects_;}},get bindingsPerObject(){return scope._bindings.length;}};}Object.assign(AnimationObjectGroup.prototype,{isAnimationObjectGroup:true,add:function(var_args){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid],knownObject=undefined;if(index===undefined){// unknown object -> add it to the ACTIVE region
index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));}}else if(index<nCachedObjects){knownObject=objects[index];// move existing object to the ACTIVE region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],binding=bindingsForPath[index];bindingsForPath[index]=lastCached;if(binding===undefined){// since we do not bother to create new bindings
// for objects that are cached, the binding may
// or may not exist
binding=new PropertyBinding(object,paths[j],parsedPaths[j]);}bindingsForPath[firstActiveIndex]=binding;}}else if(objects[index]!==knownObject){console.error("Different objects with the same UUID "+"detected. Clean the caches or recreate your "+"infrastructure when reloading scenes...");}// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=nCachedObjects;},remove:function(var_args){var objects=this._objects,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined&&index>=nCachedObjects){// move existing object into the CACHED region
var lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive;bindingsForPath[lastCachedIndex]=binding;}}}// for arguments
this.nCachedObjects_=nCachedObjects;},// remove & forget
uncache:function(var_args){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined){delete indicesByUUID[uuid];if(index<nCachedObjects){// object is cached, shrink the CACHED region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];// last cached object takes this object's place
indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;// last object goes to the activated slot and pop
indicesByUUID[lastObject.uuid]=firstActiveIndex;objects[firstActiveIndex]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached;bindingsForPath[firstActiveIndex]=last;bindingsForPath.pop();}}else{// object is active, just swap with the last and pop
var lastIndex=--nObjects,lastObject=objects[lastIndex];indicesByUUID[lastObject.uuid]=index;objects[index]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j];bindingsForPath[index]=bindingsForPath[lastIndex];bindingsForPath.pop();}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=nCachedObjects;},// Internal interface used by befriended PropertyBinding.Composite:
subscribe_:function(path,parsedPath){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path],bindings=this._bindings;if(index!==undefined)return bindings[index];var paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length;indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(var i=nCachedObjects,n=objects.length;i!==n;++i){var object=objects[i];bindingsForPath[i]=new PropertyBinding(object,path,parsedPath);}return bindingsForPath;},unsubscribe_:function(path){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(index!==undefined){var paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path[lastBindingsIndex];indicesByPath[lastBindingsPath]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop();}}});/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */function AnimationAction(mixer,clip,localRoot){this._mixer=mixer;this._clip=clip;this._localRoot=localRoot||null;var tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks);var interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(var i=0;i!==nTracks;++i){var interpolant=tracks[i].createInterpolant(null);interpolants[i]=interpolant;interpolant.settings=interpolantSettings;}this._interpolantSettings=interpolantSettings;this._interpolants=interpolants;// bound by the mixer
// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=new Array(nTracks);this._cacheIndex=null;// for the memory manager
this._byClipCacheIndex=null;// for the memory manager
this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=LoopRepeat;this._loopCount=-1;// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null;// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;// no. of repetitions when looping
this.paused=false;// true -> zero effective time scale
this.enabled=true;// false -> zero effective weight
this.clampWhenFinished=false;// keep feeding the last frame?
this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
this.zeroSlopeAtEnd=true;// clips for start, loop and end
}Object.assign(AnimationAction.prototype,{// State & Scheduling
play:function(){this._mixer._activateAction(this);return this;},stop:function(){this._mixer._deactivateAction(this);return this.reset();},reset:function(){this.paused=false;this.enabled=true;this.time=0;// restart clip
this._loopCount=-1;// forget previous loops
this._startTime=null;// forget scheduling
return this.stopFading().stopWarping();},isRunning:function(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this);},// return true when play has been called
isScheduled:function(){return this._mixer._isActiveAction(this);},startAt:function(time){this._startTime=time;return this;},setLoop:function(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this;},// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight:function(weight){this.weight=weight;// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?weight:0;return this.stopFading();},// return the weight considering fading and .enabled
getEffectiveWeight:function(){return this._effectiveWeight;},fadeIn:function(duration){return this._scheduleFading(duration,0,1);},fadeOut:function(duration){return this._scheduleFading(duration,1,0);},crossFadeFrom:function(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){var fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1.0,startEndRatio,duration);this.warp(endStartRatio,1.0,duration);}return this;},crossFadeTo:function(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp);},stopFading:function(){var weightInterpolant=this._weightInterpolant;if(weightInterpolant!==null){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(weightInterpolant);}return this;},// Time Scale Control
// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale:function(timeScale){this.timeScale=timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping();},// return the time scale considering warping and .paused
getEffectiveTimeScale:function(){return this._effectiveTimeScale;},setDuration:function(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping();},syncWith:function(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping();},halt:function(duration){return this.warp(this._effectiveTimeScale,0,duration);},warp:function(startTimeScale,endTimeScale,duration){var mixer=this._mixer,now=mixer.time,interpolant=this._timeScaleInterpolant,timeScale=this.timeScale;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._timeScaleInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;times[1]=now+duration;values[0]=startTimeScale/timeScale;values[1]=endTimeScale/timeScale;return this;},stopWarping:function(){var timeScaleInterpolant=this._timeScaleInterpolant;if(timeScaleInterpolant!==null){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(timeScaleInterpolant);}return this;},// Object Accessors
getMixer:function(){return this._mixer;},getClip:function(){return this._clip;},getRoot:function(){return this._localRoot||this._mixer._root;},// Interna
_update:function(time,deltaTime,timeDirection,accuIndex){// called by the mixer
if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
this._updateWeight(time);return;}var startTime=this._startTime;if(startTime!==null){// check for scheduled start of action
var timeRunning=(time-startTime)*timeDirection;if(timeRunning<0||timeDirection===0){return;// yet to come / don't decide when delta = 0
}// start
this._startTime=null;// unschedule
deltaTime=timeDirection*timeRunning;}// apply time scale and advance time
deltaTime*=this._updateTimeScale(time);var clipTime=this._updateTime(deltaTime);// note: _updateTime may disable the action resulting in
// an effective weight of 0
var weight=this._updateWeight(time);if(weight>0){var interpolants=this._interpolants;var propertyMixers=this._propertyBindings;for(var j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulate(accuIndex,weight);}}},_updateWeight:function(time){var weight=0;if(this.enabled){weight=this.weight;var interpolant=this._weightInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopFading();if(interpolantValue===0){// faded out, disable
this.enabled=false;}}}}this._effectiveWeight=weight;return weight;},_updateTimeScale:function(time){var timeScale=0;if(!this.paused){timeScale=this.timeScale;var interpolant=this._timeScaleInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopWarping();if(timeScale===0){// motion has halted, pause
this.paused=true;}else{// warp done - apply final time scale
this.timeScale=timeScale;}}}}this._effectiveTimeScale=timeScale;return timeScale;},_updateTime:function(deltaTime){var time=this.time+deltaTime;if(deltaTime===0)return time;var duration=this._clip.duration,loop=this.loop,loopCount=this._loopCount;if(loop===LoopOnce){if(loopCount===-1){// just started
this._loopCount=0;this._setEndings(true,true,false);}handle_stop:{if(time>=duration){time=duration;}else if(time<0){time=0;}else break handle_stop;if(this.clampWhenFinished)this.paused=true;else this.enabled=false;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime<0?-1:1});}}else{// repetitive Repeat or PingPong
var pingPong=loop===LoopPingPong;if(loopCount===-1){// just started
if(deltaTime>=0){loopCount=0;this._setEndings(true,this.repetitions===0,pingPong);}else{// when looping in reverse direction, the initial
// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(this.repetitions===0,true,pingPong);}}if(time>=duration||time<0){// wrap around
var loopDelta=Math.floor(time/duration);// signed
time-=duration*loopDelta;loopCount+=Math.abs(loopDelta);var pending=this.repetitions-loopCount;if(pending<0){// have to stop (switch state, clamp time, fire event)
if(this.clampWhenFinished)this.paused=true;else this.enabled=false;time=deltaTime>0?duration:0;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime>0?1:-1});}else{// keep running
if(pending===0){// entering the last round
var atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong);}else{this._setEndings(false,false,pingPong);}this._loopCount=loopCount;this._mixer.dispatchEvent({type:'loop',action:this,loopDelta:loopDelta});}}if(pingPong&&(loopCount&1)===1){// invert time for the "pong round"
this.time=time;return duration-time;}}this.time=time;return time;},_setEndings:function(atStart,atEnd,pingPong){var settings=this._interpolantSettings;if(pingPong){settings.endingStart=ZeroSlopeEnding;settings.endingEnd=ZeroSlopeEnding;}else{// assuming for LoopOnce atStart == atEnd == true
if(atStart){settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingStart=WrapAroundEnding;}if(atEnd){settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingEnd=WrapAroundEnding;}}},_scheduleFading:function(duration,weightNow,weightThen){var mixer=this._mixer,now=mixer.time,interpolant=this._weightInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._weightInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;values[0]=weightNow;times[1]=now+duration;values[1]=weightThen;return this;}});/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function AnimationMixer(root){this._root=root;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1.0;}Object.assign(AnimationMixer.prototype,EventDispatcher.prototype,{_bindAction:function(action,prototypeAction){var root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName,bindingsByName=bindingsByRoot[rootUuid];if(bindingsByName===undefined){bindingsByName={};bindingsByRoot[rootUuid]=bindingsByName;}for(var i=0;i!==nTracks;++i){var track=tracks[i],trackName=track.name,binding=bindingsByName[trackName];if(binding!==undefined){bindings[i]=binding;}else{binding=bindings[i];if(binding!==undefined){// existing binding, make sure the cache knows
if(binding._cacheIndex===null){++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);}continue;}var path=prototypeAction&&prototypeAction._propertyBindings[i].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);bindings[i]=binding;}interpolants[i].resultBuffer=binding.buffer;}},_activateAction:function(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
var rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid);}var bindings=action._propertyBindings;// increment reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(binding.useCount++===0){this._lendBinding(binding);binding.saveOriginalState();}}this._lendAction(action);}},_deactivateAction:function(action){if(this._isActiveAction(action)){var bindings=action._propertyBindings;// decrement reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.useCount===0){binding.restoreOriginalState();this._takeBackBinding(binding);}}this._takeBackAction(action);}},// Memory manager
_initMemoryManager:function(){this._actions=[];// 'nActiveActions' followed by inactive ones
this._nActiveActions=0;this._actionsByClip={};// inside:
// {
// 		knownActions: Array< AnimationAction >	- used as prototypes
// 		actionByRoot: AnimationAction			- lookup
// }
this._bindings=[];// 'nActiveBindings' followed by inactive ones
this._nActiveBindings=0;this._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >
this._controlInterpolants=[];// same game as above
this._nActiveControlInterpolants=0;var scope=this;this.stats={actions:{get total(){return scope._actions.length;},get inUse(){return scope._nActiveActions;}},bindings:{get total(){return scope._bindings.length;},get inUse(){return scope._nActiveBindings;}},controlInterpolants:{get total(){return scope._controlInterpolants.length;},get inUse(){return scope._nActiveControlInterpolants;}}};},// Memory management for AnimationAction objects
_isActiveAction:function(action){var index=action._cacheIndex;return index!==null&&index<this._nActiveActions;},_addInactiveAction:function(action,clipUuid,rootUuid){var actions=this._actions,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip===undefined){actionsForClip={knownActions:[action],actionByRoot:{}};action._byClipCacheIndex=0;actionsByClip[clipUuid]=actionsForClip;}else{var knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length;knownActions.push(action);}action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action;},_removeInactiveAction:function(action){var actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();action._cacheIndex=null;var clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;var actionByRoot=actionsForClip.actionByRoot,rootUuid=(action._localRoot||this._root).uuid;delete actionByRoot[rootUuid];if(knownActionsForClip.length===0){delete actionsByClip[clipUuid];}this._removeInactiveBindingsForAction(action);},_removeInactiveBindingsForAction:function(action){var bindings=action._propertyBindings;for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.referenceCount===0){this._removeInactiveBinding(binding);}}},_lendAction:function(action){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
var actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction;},_takeBackAction:function(action){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
var actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction;},// Memory management for PropertyMixer objects
_addInactiveBinding:function(binding,rootUuid,trackName){var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],bindings=this._bindings;if(bindingByName===undefined){bindingByName={};bindingsByRoot[rootUuid]=bindingByName;}bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding);},_removeInactiveBinding:function(binding){var bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex;bindings[cacheIndex]=lastInactiveBinding;bindings.pop();delete bindingByName[trackName];remove_empty_map:{for(var _ in bindingByName)break remove_empty_map;delete bindingsByRoot[rootUuid];}},_lendBinding:function(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding;},_takeBackBinding:function(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding;},// Memory management of Interpolants for weight and time scale
_lendControlInterpolant:function(){var interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++,interpolant=interpolants[lastActiveIndex];if(interpolant===undefined){interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);interpolant.__cacheIndex=lastActiveIndex;interpolants[lastActiveIndex]=interpolant;}return interpolant;},_takeBackControlInterpolant:function(interpolant){var interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant;},_controlInterpolantsResultBuffer:new Float32Array(1),// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction:function(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject!==null?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid],prototypeAction=null;if(actionsForClip!==undefined){var existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==undefined){return existingAction;}// we know the clip, so we don't have to parse all
// the bindings again but can just copy
prototypeAction=actionsForClip.knownActions[0];// also, take the clip from the prototype action
if(clipObject===null)clipObject=prototypeAction._clip;}// clip must be known when specified via string
if(clipObject===null)return null;// allocate all resources required to run it
var newAction=new AnimationAction(this,clipObject,optionalRoot);this._bindAction(newAction,prototypeAction);// and make the action known to the memory manager
this._addInactiveAction(newAction,clipUuid,rootUuid);return newAction;},// get an existing action
existingAction:function(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];if(actionsForClip!==undefined){return actionsForClip.actionByRoot[rootUuid]||null;}return null;},// deactivates all previously scheduled actions
stopAllAction:function(){var actions=this._actions,nActions=this._nActiveActions,bindings=this._bindings,nBindings=this._nActiveBindings;this._nActiveActions=0;this._nActiveBindings=0;for(var i=0;i!==nActions;++i){actions[i].reset();}for(var i=0;i!==nBindings;++i){bindings[i].useCount=0;}return this;},// advance the time and update apply the animation
update:function(deltaTime){deltaTime*=this.timeScale;var actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;// run active actions
for(var i=0;i!==nActions;++i){var action=actions[i];action._update(time,deltaTime,timeDirection,accuIndex);}// update scene graph
var bindings=this._bindings,nBindings=this._nActiveBindings;for(var i=0;i!==nBindings;++i){bindings[i].apply(accuIndex);}return this;},// return this mixer's root target object
getRoot:function(){return this._root;},// free all resources specific to a particular clip
uncacheClip:function(clip){var actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==undefined){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
var actionsToRemove=actionsForClip.knownActions;for(var i=0,n=actionsToRemove.length;i!==n;++i){var action=actionsToRemove[i];this._deactivateAction(action);var cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();this._removeInactiveBindingsForAction(action);}delete actionsByClip[clipUuid];}},// free all resources specific to a particular root target object
uncacheRoot:function(root){var rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(var clipUuid in actionsByClip){var actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];if(action!==undefined){this._deactivateAction(action);this._removeInactiveAction(action);}}var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==undefined){for(var trackName in bindingByName){var binding=bindingByName[trackName];binding.restoreOriginalState();this._removeInactiveBinding(binding);}}},// remove a targeted clip from the cache
uncacheAction:function(clip,optionalRoot){var action=this.existingAction(clip,optionalRoot);if(action!==null){this._deactivateAction(action);this._removeInactiveAction(action);}}});/**
 * @author mrdoob / http://mrdoob.com/
 */function Uniform(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}Uniform.prototype.clone=function(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());};/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InstancedBufferGeometry(){BufferGeometry.call(this);this.type='InstancedBufferGeometry';this.maxInstancedCount=undefined;}InstancedBufferGeometry.prototype=Object.assign(Object.create(BufferGeometry.prototype),{constructor:InstancedBufferGeometry,isInstancedBufferGeometry:true,addGroup:function(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex});},copy:function(source){var index=source.index;if(index!==null){this.setIndex(index.clone());}var attributes=source.attributes;for(var name in attributes){var attribute=attributes[name];this.addAttribute(name,attribute.clone());}var groups=source.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}return this;}});/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,normalized){this.uuid=_Math.generateUUID();this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}Object.defineProperties(InterleavedBufferAttribute.prototype,{count:{get:function(){return this.data.count;}},array:{get:function(){return this.data.array;}}});Object.assign(InterleavedBufferAttribute.prototype,{isInterleavedBufferAttribute:true,setX:function(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;},setY:function(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;},setZ:function(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;},setW:function(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;},getX:function(index){return this.data.array[index*this.data.stride+this.offset];},getY:function(index){return this.data.array[index*this.data.stride+this.offset+1];},getZ:function(index){return this.data.array[index*this.data.stride+this.offset+2];},getW:function(index){return this.data.array[index*this.data.stride+this.offset+3];},setXY:function(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;},setXYZ:function(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;},setXYZW:function(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}});/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InterleavedBuffer(array,stride){this.uuid=_Math.generateUUID();this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.dynamic=false;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0;}Object.defineProperty(InterleavedBuffer.prototype,'needsUpdate',{set:function(value){if(value===true)this.version++;}});Object.assign(InterleavedBuffer.prototype,{isInterleavedBuffer:true,setArray:function(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.stride:0;this.array=array;},setDynamic:function(value){this.dynamic=value;return this;},copy:function(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.dynamic=source.dynamic;return this;},copyAt:function(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(var i=0,l=this.stride;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},set:function(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},clone:function(){return new this.constructor().copy(this);},onUpload:function(callback){this.onUploadCallback=callback;return this;}});/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InstancedInterleavedBuffer(array,stride,meshPerAttribute){InterleavedBuffer.call(this,array,stride);this.meshPerAttribute=meshPerAttribute||1;}InstancedInterleavedBuffer.prototype=Object.assign(Object.create(InterleavedBuffer.prototype),{constructor:InstancedInterleavedBuffer,isInstancedInterleavedBuffer:true,copy:function(source){InterleavedBuffer.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}});/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InstancedBufferAttribute(array,itemSize,meshPerAttribute){BufferAttribute.call(this,array,itemSize);this.meshPerAttribute=meshPerAttribute||1;}InstancedBufferAttribute.prototype=Object.assign(Object.create(BufferAttribute.prototype),{constructor:InstancedBufferAttribute,isInstancedBufferAttribute:true,copy:function(source){BufferAttribute.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */function Raycaster(origin,direction,near,far){this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
this.near=near||0;this.far=far||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function(){console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');return this.Points;}}});}function ascSort(a,b){return a.distance-b.distance;}function intersectObject(object,raycaster,intersects,recursive){if(object.visible===false)return;object.raycast(raycaster,intersects);if(recursive===true){var children=object.children;for(var i=0,l=children.length;i<l;i++){intersectObject(children[i],raycaster,intersects,true);}}}Object.assign(Raycaster.prototype,{linePrecision:1,set:function(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
this.ray.set(origin,direction);},setFromCamera:function(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);}else{console.error('THREE.Raycaster: Unsupported camera type.');}},intersectObject:function(object,recursive){var intersects=[];intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;},intersectObjects:function(objects,recursive){var intersects=[];if(Array.isArray(objects)===false){console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');return intersects;}for(var i=0,l=objects.length;i<l;i++){intersectObject(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}});/**
 * @author alteredq / http://alteredqualia.com/
 */function Clock(autoStart){this.autoStart=autoStart!==undefined?autoStart:true;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}Object.assign(Clock.prototype,{start:function(){this.startTime=(typeof performance==='undefined'?Date:performance).now();// see #10732
this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;},stop:function(){this.getElapsedTime();this.running=false;},getElapsedTime:function(){this.getDelta();return this.elapsedTime;},getDelta:function(){var diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){var newTime=(typeof performance==='undefined'?Date:performance).now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}});/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */function Spherical(radius,phi,theta){this.radius=radius!==undefined?radius:1.0;this.phi=phi!==undefined?phi:0;// up / down towards top and bottom pole
this.theta=theta!==undefined?theta:0;// around the equator of the sphere
return this;}Object.assign(Spherical.prototype,{set:function(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;},clone:function(){return new this.constructor().copy(this);},copy:function(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;},// restrict phi to be betwee EPS and PI-EPS
makeSafe:function(){var EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;},setFromVector3:function(vec3){this.radius=vec3.length();if(this.radius===0){this.theta=0;this.phi=0;}else{this.theta=Math.atan2(vec3.x,vec3.z);// equator angle around y-up axis
this.phi=Math.acos(_Math.clamp(vec3.y/this.radius,-1,1));// polar angle
}return this;}});/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */function Cylindrical(radius,theta,y){this.radius=radius!==undefined?radius:1.0;// distance from the origin to a point in the x-z plane
this.theta=theta!==undefined?theta:0;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis
this.y=y!==undefined?y:0;// height above the x-z plane
return this;}Object.assign(Cylindrical.prototype,{set:function(radius,theta,y){this.radius=radius;this.theta=theta;this.y=y;return this;},clone:function(){return new this.constructor().copy(this);},copy:function(other){this.radius=other.radius;this.theta=other.theta;this.y=other.y;return this;},setFromVector3:function(vec3){this.radius=Math.sqrt(vec3.x*vec3.x+vec3.z*vec3.z);this.theta=Math.atan2(vec3.x,vec3.z);this.y=vec3.y;return this;}});/**
 * @author alteredq / http://alteredqualia.com/
 */function MorphBlendMesh(geometry,material){Mesh.call(this,geometry,material);this.animationsMap={};this.animationsList=[];// prepare default animation
// (all frames played together in 1 second)
var numFrames=this.geometry.morphTargets.length;var name="__default";var startFrame=0;var endFrame=numFrames-1;var fps=numFrames/1;this.createAnimation(name,startFrame,endFrame,fps);this.setAnimationWeight(name,1);}MorphBlendMesh.prototype=Object.create(Mesh.prototype);MorphBlendMesh.prototype.constructor=MorphBlendMesh;MorphBlendMesh.prototype.createAnimation=function(name,start,end,fps){var animation={start:start,end:end,length:end-start+1,fps:fps,duration:(end-start)/fps,lastFrame:0,currentFrame:0,active:false,time:0,direction:1,weight:1,directionBackwards:false,mirroredLoop:false};this.animationsMap[name]=animation;this.animationsList.push(animation);};MorphBlendMesh.prototype.autoCreateAnimations=function(fps){var pattern=/([a-z]+)_?(\d+)/i;var firstAnimation,frameRanges={};var geometry=this.geometry;for(var i=0,il=geometry.morphTargets.length;i<il;i++){var morph=geometry.morphTargets[i];var chunks=morph.name.match(pattern);if(chunks&&chunks.length>1){var name=chunks[1];if(!frameRanges[name])frameRanges[name]={start:Infinity,end:-Infinity};var range=frameRanges[name];if(i<range.start)range.start=i;if(i>range.end)range.end=i;if(!firstAnimation)firstAnimation=name;}}for(var name in frameRanges){var range=frameRanges[name];this.createAnimation(name,range.start,range.end,fps);}this.firstAnimation=firstAnimation;};MorphBlendMesh.prototype.setAnimationDirectionForward=function(name){var animation=this.animationsMap[name];if(animation){animation.direction=1;animation.directionBackwards=false;}};MorphBlendMesh.prototype.setAnimationDirectionBackward=function(name){var animation=this.animationsMap[name];if(animation){animation.direction=-1;animation.directionBackwards=true;}};MorphBlendMesh.prototype.setAnimationFPS=function(name,fps){var animation=this.animationsMap[name];if(animation){animation.fps=fps;animation.duration=(animation.end-animation.start)/animation.fps;}};MorphBlendMesh.prototype.setAnimationDuration=function(name,duration){var animation=this.animationsMap[name];if(animation){animation.duration=duration;animation.fps=(animation.end-animation.start)/animation.duration;}};MorphBlendMesh.prototype.setAnimationWeight=function(name,weight){var animation=this.animationsMap[name];if(animation){animation.weight=weight;}};MorphBlendMesh.prototype.setAnimationTime=function(name,time){var animation=this.animationsMap[name];if(animation){animation.time=time;}};MorphBlendMesh.prototype.getAnimationTime=function(name){var time=0;var animation=this.animationsMap[name];if(animation){time=animation.time;}return time;};MorphBlendMesh.prototype.getAnimationDuration=function(name){var duration=-1;var animation=this.animationsMap[name];if(animation){duration=animation.duration;}return duration;};MorphBlendMesh.prototype.playAnimation=function(name){var animation=this.animationsMap[name];if(animation){animation.time=0;animation.active=true;}else{console.warn("THREE.MorphBlendMesh: animation["+name+"] undefined in .playAnimation()");}};MorphBlendMesh.prototype.stopAnimation=function(name){var animation=this.animationsMap[name];if(animation){animation.active=false;}};MorphBlendMesh.prototype.update=function(delta){for(var i=0,il=this.animationsList.length;i<il;i++){var animation=this.animationsList[i];if(!animation.active)continue;var frameTime=animation.duration/animation.length;animation.time+=animation.direction*delta;if(animation.mirroredLoop){if(animation.time>animation.duration||animation.time<0){animation.direction*=-1;if(animation.time>animation.duration){animation.time=animation.duration;animation.directionBackwards=true;}if(animation.time<0){animation.time=0;animation.directionBackwards=false;}}}else{animation.time=animation.time%animation.duration;if(animation.time<0)animation.time+=animation.duration;}var keyframe=animation.start+_Math.clamp(Math.floor(animation.time/frameTime),0,animation.length-1);var weight=animation.weight;if(keyframe!==animation.currentFrame){this.morphTargetInfluences[animation.lastFrame]=0;this.morphTargetInfluences[animation.currentFrame]=1*weight;this.morphTargetInfluences[keyframe]=0;animation.lastFrame=animation.currentFrame;animation.currentFrame=keyframe;}var mix=animation.time%frameTime/frameTime;if(animation.directionBackwards)mix=1-mix;if(animation.currentFrame!==animation.lastFrame){this.morphTargetInfluences[animation.currentFrame]=mix*weight;this.morphTargetInfluences[animation.lastFrame]=(1-mix)*weight;}else{this.morphTargetInfluences[animation.currentFrame]=weight;}}};/**
 * @author alteredq / http://alteredqualia.com/
 */function ImmediateRenderObject(material){Object3D.call(this);this.material=material;this.render=function(renderCallback){};}ImmediateRenderObject.prototype=Object.create(Object3D.prototype);ImmediateRenderObject.prototype.constructor=ImmediateRenderObject;ImmediateRenderObject.prototype.isImmediateRenderObject=true;/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/function VertexNormalsHelper(object,size,hex,linewidth){this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xff0000;var width=linewidth!==undefined?linewidth:1;//
var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length*3;}else if(objGeometry&&objGeometry.isBufferGeometry){nNormals=objGeometry.attributes.normal.count;}//
var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
this.matrixAutoUpdate=false;this.update();}VertexNormalsHelper.prototype=Object.create(LineSegments.prototype);VertexNormalsHelper.prototype.constructor=VertexNormalsHelper;VertexNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){var keys=['a','b','c'];this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0,jl=face.vertexNormals.length;j<jl;j++){var vertex=vertices[face[keys[j]]];var normal=face.vertexNormals[j];v1.copy(vertex).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}}else if(objGeometry&&objGeometry.isBufferGeometry){var objPos=objGeometry.attributes.position;var objNorm=objGeometry.attributes.normal;var idx=0;// for simplicity, ignore index and drawcalls, and render every normal
for(var j=0,jl=objPos.count;j<jl;j++){v1.set(objPos.getX(j),objPos.getY(j),objPos.getZ(j)).applyMatrix4(matrixWorld);v2.set(objNorm.getX(j),objNorm.getY(j),objNorm.getZ(j));v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}position.needsUpdate=true;};}();/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/function SpotLightHelper(light){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;var geometry=new BufferGeometry();var positions=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var i=0,j=1,l=32;i<l;i++,j++){var p1=i/l*Math.PI*2;var p2=j/l*Math.PI*2;positions.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1);}geometry.addAttribute('position',new Float32BufferAttribute(positions,3));var material=new LineBasicMaterial({fog:false});this.cone=new LineSegments(geometry,material);this.add(this.cone);this.update();}SpotLightHelper.prototype=Object.create(Object3D.prototype);SpotLightHelper.prototype.constructor=SpotLightHelper;SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose();};SpotLightHelper.prototype.update=function(){var vector=new Vector3();var vector2=new Vector3();return function update(){var coneLength=this.light.distance?this.light.distance:1000;var coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength);vector.setFromMatrixPosition(this.light.matrixWorld);vector2.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(vector2.sub(vector));this.cone.material.color.copy(this.light.color);};}();/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */function SkeletonHelper(object){this.bones=this.getBoneList(object);var geometry=new BufferGeometry();var vertices=[];var colors=[];var color1=new Color(0,0,1);var color2=new Color(0,1,0);for(var i=0;i<this.bones.length;i++){var bone=this.bones[i];if(bone.parent&&bone.parent.isBone){vertices.push(0,0,0);vertices.push(0,0,0);colors.push(color1.r,color1.g,color1.b);colors.push(color2.r,color2.g,color2.b);}}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors,depthTest:false,depthWrite:false,transparent:true});LineSegments.call(this,geometry,material);this.root=object;this.matrix=object.matrixWorld;this.matrixAutoUpdate=false;this.update();}SkeletonHelper.prototype=Object.create(LineSegments.prototype);SkeletonHelper.prototype.constructor=SkeletonHelper;SkeletonHelper.prototype.getBoneList=function(object){var boneList=[];if(object&&object.isBone){boneList.push(object);}for(var i=0;i<object.children.length;i++){boneList.push.apply(boneList,this.getBoneList(object.children[i]));}return boneList;};SkeletonHelper.prototype.update=function(){var vector=new Vector3();var boneMatrix=new Matrix4();var matrixWorldInv=new Matrix4();return function update(){var geometry=this.geometry;var position=geometry.getAttribute('position');matrixWorldInv.getInverse(this.root.matrixWorld);for(var i=0,j=0;i<this.bones.length;i++){var bone=this.bones[i];if(bone.parent&&bone.parent.isBone){boneMatrix.multiplyMatrices(matrixWorldInv,bone.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j,vector.x,vector.y,vector.z);boneMatrix.multiplyMatrices(matrixWorldInv,bone.parent.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j+1,vector.x,vector.y,vector.z);j+=2;}}geometry.getAttribute('position').needsUpdate=true;};}();/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */function PointLightHelper(light,sphereSize){this.light=light;this.light.updateMatrixWorld();var geometry=new SphereBufferGeometry(sphereSize,4,2);var material=new MeshBasicMaterial({wireframe:true,fog:false});material.color.copy(this.light.color);Mesh.call(this,geometry,material);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=false;/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/}PointLightHelper.prototype=Object.create(Mesh.prototype);PointLightHelper.prototype.constructor=PointLightHelper;PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose();};PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color);/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/};/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 * @author WestLangley / http://github.com/WestLangley
 */function RectAreaLightHelper(light){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;var material=new LineBasicMaterial({color:light.color});var geometry=new BufferGeometry();geometry.addAttribute('position',new BufferAttribute(new Float32Array(5*3),3));this.add(new Line(geometry,material));this.update();}RectAreaLightHelper.prototype=Object.create(Object3D.prototype);RectAreaLightHelper.prototype.constructor=RectAreaLightHelper;RectAreaLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};RectAreaLightHelper.prototype.update=function(){var line=this.children[0];// update material
line.material.color.copy(this.light.color);// calculate new dimensions of the helper
var hx=this.light.width*0.5;var hy=this.light.height*0.5;var position=line.geometry.attributes.position;var array=position.array;// update vertices
array[0]=hx;array[1]=-hy;array[2]=0;array[3]=hx;array[4]=hy;array[5]=0;array[6]=-hx;array[7]=hy;array[8]=0;array[9]=-hx;array[10]=-hy;array[11]=0;array[12]=hx;array[13]=-hy;array[14]=0;position.needsUpdate=true;};/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */function HemisphereLightHelper(light,size){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;var geometry=new OctahedronBufferGeometry(size);geometry.rotateY(Math.PI*0.5);var material=new MeshBasicMaterial({vertexColors:VertexColors,wireframe:true});var position=geometry.getAttribute('position');var colors=new Float32Array(position.count*3);geometry.addAttribute('color',new BufferAttribute(colors,3));this.add(new Mesh(geometry,material));this.update();}HemisphereLightHelper.prototype=Object.create(Object3D.prototype);HemisphereLightHelper.prototype.constructor=HemisphereLightHelper;HemisphereLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};HemisphereLightHelper.prototype.update=function(){var vector=new Vector3();var color1=new Color();var color2=new Color();return function update(){var mesh=this.children[0];var colors=mesh.geometry.getAttribute('color');color1.copy(this.light.color);color2.copy(this.light.groundColor);for(var i=0,l=colors.count;i<l;i++){var color=i<l/2?color1:color2;colors.setXYZ(i,color.r,color.g,color.b);}mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());colors.needsUpdate=true;};}();/**
 * @author mrdoob / http://mrdoob.com/
 */function GridHelper(size,divisions,color1,color2){size=size||10;divisions=divisions||10;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var center=divisions/2;var step=size/divisions;var halfSize=size/2;var vertices=[],colors=[];for(var i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){vertices.push(-halfSize,0,k,halfSize,0,k);vertices.push(k,0,-halfSize,k,0,halfSize);var color=i===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}GridHelper.prototype=Object.create(LineSegments.prototype);GridHelper.prototype.constructor=GridHelper;/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */function PolarGridHelper(radius,radials,circles,divisions,color1,color2){radius=radius||10;radials=radials||16;circles=circles||8;divisions=divisions||64;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var vertices=[];var colors=[];var x,z;var v,i,j,r,color;// create the radials
for(i=0;i<=radials;i++){v=i/radials*(Math.PI*2);x=Math.sin(v)*radius;z=Math.cos(v)*radius;vertices.push(0,0,0);vertices.push(x,0,z);color=i&1?color1:color2;colors.push(color.r,color.g,color.b);colors.push(color.r,color.g,color.b);}// create the circles
for(i=0;i<=circles;i++){color=i&1?color1:color2;r=radius-radius/circles*i;for(j=0;j<divisions;j++){// first vertex
v=j/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);// second vertex
v=(j+1)/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);}}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}PolarGridHelper.prototype=Object.create(LineSegments.prototype);PolarGridHelper.prototype.constructor=PolarGridHelper;/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/function FaceNormalsHelper(object,size,hex,linewidth){// FaceNormalsHelper only supports THREE.Geometry
this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xffff00;var width=linewidth!==undefined?linewidth:1;//
var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length;}else{console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');}//
var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
this.matrixAutoUpdate=false;this.update();}FaceNormalsHelper.prototype=Object.create(LineSegments.prototype);FaceNormalsHelper.prototype.constructor=FaceNormalsHelper;FaceNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
var objGeometry=this.object.geometry;var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];var normal=face.normal;v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}position.needsUpdate=true;};}();/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */function DirectionalLightHelper(light,size){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;if(size===undefined)size=1;var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));var material=new LineBasicMaterial({fog:false});this.add(new Line(geometry,material));geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));this.add(new Line(geometry,material));this.update();}DirectionalLightHelper.prototype=Object.create(Object3D.prototype);DirectionalLightHelper.prototype.constructor=DirectionalLightHelper;DirectionalLightHelper.prototype.dispose=function(){var lightPlane=this.children[0];var targetLine=this.children[1];lightPlane.geometry.dispose();lightPlane.material.dispose();targetLine.geometry.dispose();targetLine.material.dispose();};DirectionalLightHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var v3=new Vector3();return function update(){v1.setFromMatrixPosition(this.light.matrixWorld);v2.setFromMatrixPosition(this.light.target.matrixWorld);v3.subVectors(v2,v1);var lightPlane=this.children[0];var targetLine=this.children[1];lightPlane.lookAt(v3);lightPlane.material.color.copy(this.light.color);targetLine.lookAt(v3);targetLine.scale.z=v3.length();};}();/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */function CameraHelper(camera){var geometry=new BufferGeometry();var material=new LineBasicMaterial({color:0xffffff,vertexColors:FaceColors});var vertices=[];var colors=[];var pointMap={};// colors
var colorFrustum=new Color(0xffaa00);var colorCone=new Color(0xff0000);var colorUp=new Color(0x00aaff);var colorTarget=new Color(0xffffff);var colorCross=new Color(0x333333);// near
addLine("n1","n2",colorFrustum);addLine("n2","n4",colorFrustum);addLine("n4","n3",colorFrustum);addLine("n3","n1",colorFrustum);// far
addLine("f1","f2",colorFrustum);addLine("f2","f4",colorFrustum);addLine("f4","f3",colorFrustum);addLine("f3","f1",colorFrustum);// sides
addLine("n1","f1",colorFrustum);addLine("n2","f2",colorFrustum);addLine("n3","f3",colorFrustum);addLine("n4","f4",colorFrustum);// cone
addLine("p","n1",colorCone);addLine("p","n2",colorCone);addLine("p","n3",colorCone);addLine("p","n4",colorCone);// up
addLine("u1","u2",colorUp);addLine("u2","u3",colorUp);addLine("u3","u1",colorUp);// target
addLine("c","t",colorTarget);addLine("p","c",colorCross);// cross
addLine("cn1","cn2",colorCross);addLine("cn3","cn4",colorCross);addLine("cf1","cf2",colorCross);addLine("cf3","cf4",colorCross);function addLine(a,b,color){addPoint(a,color);addPoint(b,color);}function addPoint(id,color){vertices.push(0,0,0);colors.push(color.r,color.g,color.b);if(pointMap[id]===undefined){pointMap[id]=[];}pointMap[id].push(vertices.length/3-1);}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));LineSegments.call(this,geometry,material);this.camera=camera;if(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();this.matrix=camera.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=pointMap;this.update();}CameraHelper.prototype=Object.create(LineSegments.prototype);CameraHelper.prototype.constructor=CameraHelper;CameraHelper.prototype.update=function(){var geometry,pointMap;var vector=new Vector3();var camera=new Camera();function setPoint(point,x,y,z){vector.set(x,y,z).unproject(camera);var points=pointMap[point];if(points!==undefined){var position=geometry.getAttribute('position');for(var i=0,l=points.length;i<l;i++){position.setXYZ(points[i],vector.x,vector.y,vector.z);}}}return function update(){geometry=this.geometry;pointMap=this.pointMap;var w=1,h=1;// we need just camera projection matrix
// world matrix must be identity
camera.projectionMatrix.copy(this.camera.projectionMatrix);// center / target
setPoint("c",0,0,-1);setPoint("t",0,0,1);// near
setPoint("n1",-w,-h,-1);setPoint("n2",w,-h,-1);setPoint("n3",-w,h,-1);setPoint("n4",w,h,-1);// far
setPoint("f1",-w,-h,1);setPoint("f2",w,-h,1);setPoint("f3",-w,h,1);setPoint("f4",w,h,1);// up
setPoint("u1",w*0.7,h*1.1,-1);setPoint("u2",-w*0.7,h*1.1,-1);setPoint("u3",0,h*2,-1);// cross
setPoint("cf1",-w,0,1);setPoint("cf2",w,0,1);setPoint("cf3",0,-h,1);setPoint("cf4",0,h,1);setPoint("cn1",-w,0,-1);setPoint("cn2",w,0,-1);setPoint("cn3",0,-h,-1);setPoint("cn4",0,h,-1);geometry.getAttribute('position').needsUpdate=true;};}();/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */function BoxHelper(object,color){this.object=object;if(color===undefined)color=0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=new Float32Array(8*3);var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.addAttribute('position',new BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));this.matrixAutoUpdate=false;this.update();}BoxHelper.prototype=Object.create(LineSegments.prototype);BoxHelper.prototype.constructor=BoxHelper;BoxHelper.prototype.update=function(){var box=new Box3();return function update(object){if(object!==undefined){console.warn('THREE.BoxHelper: .update() has no longer arguments.');}if(this.object!==undefined){box.setFromObject(this.object);}if(box.isEmpty())return;var min=box.min;var max=box.max;/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/var position=this.geometry.attributes.position;var array=position.array;array[0]=max.x;array[1]=max.y;array[2]=max.z;array[3]=min.x;array[4]=max.y;array[5]=max.z;array[6]=min.x;array[7]=min.y;array[8]=max.z;array[9]=max.x;array[10]=min.y;array[11]=max.z;array[12]=max.x;array[13]=max.y;array[14]=min.z;array[15]=min.x;array[16]=max.y;array[17]=min.z;array[18]=min.x;array[19]=min.y;array[20]=min.z;array[21]=max.x;array[22]=min.y;array[23]=min.z;position.needsUpdate=true;this.geometry.computeBoundingSphere();};}();BoxHelper.prototype.setFromObject=function(object){this.object=object;this.update();return this;};/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */var lineGeometry;var coneGeometry;function ArrowHelper(dir,origin,length,color,headLength,headWidth){// dir is assumed to be normalized
Object3D.call(this);if(color===undefined)color=0xffff00;if(length===undefined)length=1;if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;if(lineGeometry===undefined){lineGeometry=new BufferGeometry();lineGeometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));coneGeometry=new CylinderBufferGeometry(0,0.5,1,5,1);coneGeometry.translate(0,-0.5,0);}this.position.copy(origin);this.line=new Line(lineGeometry,new LineBasicMaterial({color:color}));this.line.matrixAutoUpdate=false;this.add(this.line);this.cone=new Mesh(coneGeometry,new MeshBasicMaterial({color:color}));this.cone.matrixAutoUpdate=false;this.add(this.cone);this.setDirection(dir);this.setLength(length,headLength,headWidth);}ArrowHelper.prototype=Object.create(Object3D.prototype);ArrowHelper.prototype.constructor=ArrowHelper;ArrowHelper.prototype.setDirection=function(){var axis=new Vector3();var radians;return function setDirection(dir){// dir is assumed to be normalized
if(dir.y>0.99999){this.quaternion.set(0,0,0,1);}else if(dir.y<-0.99999){this.quaternion.set(1,0,0,0);}else{axis.set(dir.z,0,-dir.x).normalize();radians=Math.acos(dir.y);this.quaternion.setFromAxisAngle(axis,radians);}};}();ArrowHelper.prototype.setLength=function(length,headLength,headWidth){if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;this.line.scale.set(1,Math.max(0,length-headLength),1);this.line.updateMatrix();this.cone.scale.set(headWidth,headLength,headWidth);this.cone.position.y=length;this.cone.updateMatrix();};ArrowHelper.prototype.setColor=function(color){this.line.material.color.copy(color);this.cone.material.color.copy(color);};/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */function AxisHelper(size){size=size||1;var vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size];var colors=[1,0,0,1,0.6,0,0,1,0,0.6,1,0,0,0,1,0,0.6,1];var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}AxisHelper.prototype=Object.create(LineSegments.prototype);AxisHelper.prototype.constructor=AxisHelper;/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 *//*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return{initCatmullRom:function(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
var tmp=new Vector3();var px=new CubicPoly();var py=new CubicPoly();var pz=new CubicPoly();function CatmullRomCurve3(p/* array of Vector3 */){Curve.call(this);this.points=p||[];this.closed=false;}CatmullRomCurve3.prototype=Object.create(Curve.prototype);CatmullRomCurve3.prototype.constructor=CatmullRomCurve3;CatmullRomCurve3.prototype.getPoint=function(t){var points=this.points;var l=points.length;if(l<2)console.log('duh, you need at least 2 points');var point=(l-(this.closed?0:1))*t;var intPoint=Math.floor(point);var weight=point-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/points.length)+1)*points.length;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p1,p2,p3;// 4 points
if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else{// extrapolate first point
tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}p1=points[intPoint%l];p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else{// extrapolate last point
tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.type===undefined||this.type==='centripetal'||this.type==='chordal'){// init Centripetal / Chordal Catmull-Rom
var pow=this.type==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.type==='catmullrom'){var tension=this.tension!==undefined?this.tension:0.5;px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,tension);}return new Vector3(px.calc(weight),py.calc(weight),pz.calc(weight));};function CubicBezierCurve3(v0,v1,v2,v3){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}CubicBezierCurve3.prototype=Object.create(Curve.prototype);CubicBezierCurve3.prototype.constructor=CubicBezierCurve3;CubicBezierCurve3.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;return new Vector3(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));};function QuadraticBezierCurve3(v0,v1,v2){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;}QuadraticBezierCurve3.prototype=Object.create(Curve.prototype);QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3;QuadraticBezierCurve3.prototype.getPoint=function(t){var v0=this.v0,v1=this.v1,v2=this.v2;return new Vector3(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));};function LineCurve3(v1,v2){Curve.call(this);this.v1=v1;this.v2=v2;}LineCurve3.prototype=Object.create(Curve.prototype);LineCurve3.prototype.constructor=LineCurve3;LineCurve3.prototype.getPoint=function(t){if(t===1){return this.v2.clone();}var vector=new Vector3();vector.subVectors(this.v2,this.v1);// diff
vector.multiplyScalar(t);vector.add(this.v1);return vector;};function ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){EllipseCurve.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);}ArcCurve.prototype=Object.create(EllipseCurve.prototype);ArcCurve.prototype.constructor=ArcCurve;/**
 * @author alteredq / http://alteredqualia.com/
 */var SceneUtils={createMultiMaterialObject:function(geometry,materials){var group=new Group();for(var i=0,l=materials.length;i<l;i++){group.add(new Mesh(geometry,materials[i]));}return group;},detach:function(child,parent,scene){child.applyMatrix(parent.matrixWorld);parent.remove(child);scene.add(child);},attach:function(child,scene,parent){var matrixWorldInverse=new Matrix4();matrixWorldInverse.getInverse(parent.matrixWorld);child.applyMatrix(matrixWorldInverse);scene.remove(child);parent.add(child);}};/**
 * @author mrdoob / http://mrdoob.com/
 */function Face4(a,b,c,d,normal,color,materialIndex){console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');return new Face3(a,b,c,normal,color,materialIndex);}var LineStrip=0;var LinePieces=1;function MeshFaceMaterial(materials){console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');return materials;}function MultiMaterial(materials){if(materials===undefined)materials=[];console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');materials.isMultiMaterial=true;materials.materials=materials;materials.clone=function(){return materials.slice();};return materials;}function PointCloud(geometry,material){console.warn('THREE.PointCloud has been renamed to THREE.Points.');return new Points(geometry,material);}function Particle(material){console.warn('THREE.Particle has been renamed to THREE.Sprite.');return new Sprite(material);}function ParticleSystem(geometry,material){console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');return new Points(geometry,material);}function PointCloudMaterial(parameters){console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleBasicMaterial(parameters){console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleSystemMaterial(parameters){console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function Vertex(x,y,z){console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');return new Vector3(x,y,z);}//
function DynamicBufferAttribute(array,itemSize){console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');return new BufferAttribute(array,itemSize).setDynamic(true);}function Int8Attribute(array,itemSize){console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');return new Int8BufferAttribute(array,itemSize);}function Uint8Attribute(array,itemSize){console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');return new Uint8BufferAttribute(array,itemSize);}function Uint8ClampedAttribute(array,itemSize){console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');return new Uint8ClampedBufferAttribute(array,itemSize);}function Int16Attribute(array,itemSize){console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');return new Int16BufferAttribute(array,itemSize);}function Uint16Attribute(array,itemSize){console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');return new Uint16BufferAttribute(array,itemSize);}function Int32Attribute(array,itemSize){console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');return new Int32BufferAttribute(array,itemSize);}function Uint32Attribute(array,itemSize){console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');return new Uint32BufferAttribute(array,itemSize);}function Float32Attribute(array,itemSize){console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');return new Float32BufferAttribute(array,itemSize);}function Float64Attribute(array,itemSize){console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');return new Float64BufferAttribute(array,itemSize);}//
Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=Object.create(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
function ClosedSplineCurve3(points){console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';this.closed=true;}ClosedSplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);//
function SplineCurve3(points){console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}SplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);//
function Spline(points){console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}Spline.prototype=Object.create(CatmullRomCurve3.prototype);Object.assign(Spline.prototype,{initFromArray:function(a){console.error('THREE.Spline: .initFromArray() has been removed.');},getControlPointsArray:function(optionalTarget){console.error('THREE.Spline: .getControlPointsArray() has been removed.');},reparametrizeByArcLength:function(samplingCoef){console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');}});//
function BoundingBoxHelper(object,color){console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');return new BoxHelper(object,color);}function EdgesHelper(object,hex){console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');return new LineSegments(new EdgesGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};function WireframeHelper(object,hex){console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');return new LineSegments(new WireframeGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}//
function XHRLoader(manager){console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');return new FileLoader(manager);}function BinaryTextureLoader(manager){console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');return new DataTextureLoader(manager);}//
Object.assign(Box2.prototype,{center:function(optionalTarget){console.warn('THREE.Box2: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function(){console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function(box){console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},size:function(optionalTarget){console.warn('THREE.Box2: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Object.assign(Box3.prototype,{center:function(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionSphere:function(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);},size:function(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Line3.prototype.center=function(optionalTarget){console.warn('THREE.Line3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};_Math.random16=function(){console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');return Math.random();};Object.assign(Matrix3.prototype,{flattenToArrayOffset:function(array,offset){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},multiplyVector3:function(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);},multiplyVector3Array:function(a){console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');return this.applyToVector3Array(a);},applyToBuffer:function(buffer,offset,length){console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function(array,offset,length){console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');}});Object.assign(Matrix4.prototype,{extractPosition:function(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);},flattenToArrayOffset:function(array,offset){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},getPosition:function(){var v1;return function getPosition(){if(v1===undefined)v1=new Vector3();console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return v1.setFromMatrixColumn(this,3);};}(),setRotationFromQuaternion:function(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);},multiplyToArray:function(){console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');},multiplyVector3:function(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector4:function(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector3Array:function(a){console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');return this.applyToVector3Array(a);},rotateAxis:function(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);},crossVector:function(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},translate:function(){console.error('THREE.Matrix4: .translate() has been removed.');},rotateX:function(){console.error('THREE.Matrix4: .rotateX() has been removed.');},rotateY:function(){console.error('THREE.Matrix4: .rotateY() has been removed.');},rotateZ:function(){console.error('THREE.Matrix4: .rotateZ() has been removed.');},rotateByAxis:function(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');},applyToBuffer:function(buffer,offset,length){console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function(array,offset,length){console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');},makeFrustum:function(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);}});Plane.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};Object.assign(Ray.prototype,{isIntersectionBox:function(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionPlane:function(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);},isIntersectionSphere:function(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);}});Object.assign(Shape.prototype,{extrude:function(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);},makeGeometry:function(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);}});Object.assign(Vector2.prototype,{fromAttribute:function(attribute,index,offset){console.error('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);}});Object.assign(Vector3.prototype,{setEulerFromRotationMatrix:function(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');},setEulerFromQuaternion:function(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');},getPositionFromMatrix:function(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);},getScaleFromMatrix:function(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);},getColumnFromMatrix:function(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);},applyProjection:function(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);},fromAttribute:function(attribute,index,offset){console.error('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);}});Object.assign(Vector4.prototype,{fromAttribute:function(attribute,index,offset){console.error('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);}});//
Geometry.prototype.computeTangents=function(){console.warn('THREE.Geometry: .computeTangents() has been removed.');};Object.assign(Object3D.prototype,{getChildByName:function(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);},renderDepth:function(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');},translate:function(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);}});Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});Object.defineProperties(LOD.prototype,{objects:{get:function(){console.warn('THREE.LOD: .objects has been renamed to .levels.');return this.levels;}}});Object.defineProperty(Skeleton.prototype,'useVertexTexture',{get:function(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');},set:function(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');}});Object.defineProperty(Curve.prototype,'__arcLengthDivisions',{get:function(){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');return this.arcLengthDivisions;},set:function(value){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');this.arcLengthDivisions=value;}});//
PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn("THREE.PerspectiveCamera.setLens is deprecated. "+"Use .setFocalLength and .filmGauge for a photographic setup.");if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
Object.defineProperties(Light.prototype,{onlyShadow:{set:function(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
Object.defineProperties(BufferAttribute.prototype,{length:{get:function(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}}});Object.assign(BufferGeometry.prototype,{addIndex:function(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);},addDrawCall:function(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);},clearDrawCalls:function(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();},computeTangents:function(){console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');},computeOffsets:function(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');}});Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});//
Object.defineProperties(Uniform.prototype,{dynamic:{set:function(){console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');}},onUpdate:{value:function(){console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');return this;}}});//
Object.defineProperties(Material.prototype,{wrapAround:{get:function(){console.warn('THREE.Material: .wrapAround has been removed.');},set:function(){console.warn('THREE.Material: .wrapAround has been removed.');}},wrapRGB:{get:function(){console.warn('THREE.Material: .wrapRGB has been removed.');return new Color();}}});Object.defineProperties(MeshPhongMaterial.prototype,{metal:{get:function(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');return false;},set:function(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');}}});Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
Object.assign(WebGLRenderer.prototype,{getCurrentRenderTarget:function(){console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');return this.getRenderTarget();},supportsFloatTextures:function(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');},supportsHalfFloatTextures:function(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');},supportsStandardDerivatives:function(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');},supportsCompressedTextureS3TC:function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');},supportsCompressedTexturePVRTC:function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');},supportsBlendMinMax:function(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');},supportsVertexTextures:function(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;},supportsInstancedArrays:function(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');},enableScissorTest:function(boolean){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(boolean);},initMaterial:function(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');},addPrePlugin:function(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');},addPostPlugin:function(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');},updateShadowMap:function(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');}});Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function(){return this.shadowMap.type;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function(){return this.shadowMap.cullFace;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');this.shadowMap.cullFace=value;}}});Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function(){return this.renderReverseSided?CullFaceFront:CullFaceBack;},set:function(cullFace){var value=cullFace!==CullFaceBack;console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to "+value+".");this.renderReverseSided=value;}}});//
Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
Audio.prototype.load=function(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');var scope=this;var audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;};AudioAnalyser.prototype.getData=function(){console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');return this.getFrequencyData();};//
var GeometryUtils={merge:function(geometry1,geometry2,materialIndexOffset){console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');var matrix;if(geometry2.isMesh){geometry2.matrixAutoUpdate&&geometry2.updateMatrix();matrix=geometry2.matrix;geometry2=geometry2.geometry;}geometry1.merge(geometry2,matrix,materialIndexOffset);},center:function(geometry){console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');return geometry.center();}};var ImageUtils={crossOrigin:undefined,loadTexture:function(url,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');var loader=new TextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(url,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;},loadTextureCube:function(urls,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');var loader=new CubeTextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(urls,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;},loadCompressedTexture:function(){console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');},loadCompressedTextureCube:function(){console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');}};//
function Projector(){console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');this.projectVector=function(vector,camera){console.warn('THREE.Projector: .projectVector() is now vector.project().');vector.project(camera);};this.unprojectVector=function(vector,camera){console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');vector.unproject(camera);};this.pickingRay=function(){console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');};}//
function CanvasRenderer(){console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');this.domElement=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');this.clear=function(){};this.render=function(){};this.setClearColor=function(){};this.setSize=function(){};}

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return data; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_d3__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_events__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_events__);



var event = new __WEBPACK_IMPORTED_MODULE_1_events__["EventEmitter"]();
var data = {
    map: {
        geojson: undefined, //for svg
        points_h: undefined, //high
        points_l: undefined, //low
        points_uh: undefined, //ultra high,
        markers: undefined, //positions / cities + counties
        provinces: undefined
    },
    map_postfab: {
        points_h: undefined,
        points_l: undefined,
        points_uh: undefined
    },
    ready: false
};
//grab json

//split points into datastructures for further biz
function postfab_points(name, unit) {
    var pts = data.map[name];
    data.map_postfab[name] = {};
    for (var i = 0; i < pts.length; i++) {
        if (!data.map_postfab[name][pts[i].id]) {
            data.map_postfab[name][pts[i].id] = [];
        }
        var cur = pts[i];
        data.map_postfab[name][pts[i].id].push(pts[i]);
        if (unit) {
            if (i % 100 == 0) {
                console.log(i / pts.length);
            }
            var count = 0;
            for (var j = 0; j < pts.length; j++) {
                //find four n
                //stupid code
                var n = pts[j];
                if (n !== cur && n.id == cur.id && (n.x + unit == cur.x || n.x - unit == cur.x) && (n.y + unit == cur.y || n.y - unit == cur.y)) {
                    count++;
                }
                if (count >= 4) {
                    break;
                }
            }
            if (count < 4) {
                cur.border = true;
            }
        }
    }
}

function loadAll(data, cb) {
    var l = [];
    (function load_recur(i) {
        i >= data.length ? cb(l) : __WEBPACK_IMPORTED_MODULE_0_d3__["json"](data[i], function (e, c) {
            l[i] = c;
            load_recur(i + 1);
        });
    })(0);
}

loadAll(["mapdata/china.json", "mapdata/combined.json", "mapdata/particles/map-highres.json", "mapdata/particles/map-mres.json", "mapdata/particles/map-uhighres.json"], d => {
    data.map.geojson = d[0];
    data.map.markers = d[1];
    data.map.points_h = d[2];
    data.map.points_l = d[3];
    data.map.points_uh = d[4];

    postfab_points("points_h");
    postfab_points("points_l", 5);
    postfab_points("points_uh");

    console.log("p.uh\nlength=", data.map.points_uh.length, " [CAP] ");
    console.log("p.h\nlength=", data.map.points_h.length);
    console.log("p.l\nlength=", data.map.points_l.length);

    data.map.provinces = {};
    for (var i = 0; i < data.map.geojson.features.length; i++) {
        var prop = data.map.geojson.features[i].properties;
        prop.id = parseInt(prop.id);
        data.map.provinces[prop.id] = prop;
    }

    data.ready = true;
    event.emit("ready");
});

/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var Pointable = __webpack_require__(4),
    glMatrix = __webpack_require__(2),
    vec3 = glMatrix.vec3,
    mat3 = glMatrix.mat3,
    mat4 = glMatrix.mat4,
    _ = __webpack_require__(0);

var Bone = module.exports = function (finger, data) {
  this.finger = finger;

  this._center = null, this._matrix = null;

  /**
  * An integer code for the name of this bone.
  *
  * * 0 -- metacarpal
  * * 1 -- proximal
  * * 2 -- medial
  * * 3 -- distal
  * * 4 -- arm
  *
  * @member type
  * @type {number}
  * @memberof Leap.Bone.prototype
  */
  this.type = data.type;

  /**
   * The position of the previous, or base joint of the bone closer to the wrist.
   * @type {vector3}
   */
  this.prevJoint = data.prevJoint;

  /**
   * The position of the next joint, or the end of the bone closer to the finger tip.
   * @type {vector3}
   */
  this.nextJoint = data.nextJoint;

  /**
   * The estimated width of the tool in millimeters.
   *
   * The reported width is the average width of the visible portion of the
   * tool from the hand to the tip. If the width isn't known,
   * then a value of 0 is returned.
   *
   * Pointable objects representing fingers do not have a width property.
   *
   * @member width
   * @type {number}
   * @memberof Leap.Pointable.prototype
   */
  this.width = data.width;

  var displacement = new Array(3);
  vec3.sub(displacement, data.nextJoint, data.prevJoint);

  this.length = vec3.length(displacement);

  /**
   *
   * These fully-specify the orientation of the bone.
   * See examples/threejs-bones.html for more info
   * Three vec3s:
   *  x (red): The rotation axis of the finger, pointing outwards.  (In general, away from the thumb )
   *  y (green): The "up" vector, orienting the top of the finger
   *  z (blue): The roll axis of the bone.
   *
   *  Most up vectors will be pointing the same direction, except for the thumb, which is more rightwards.
   *
   *  The thumb has one fewer bones than the fingers, but there are the same number of joints & joint-bases provided
   *  the first two appear in the same position, but only the second (proximal) rotates.
   *
   *  Normalized.
   */
  this.basis = data.basis;
};

Bone.prototype.left = function () {

  if (this._left) return this._left;

  this._left = mat3.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])) < 0;

  return this._left;
};

/**
 * The Affine transformation matrix describing the orientation of the bone, in global Leap-space.
 * It contains a 3x3 rotation matrix (in the "top left"), and center coordinates in the fourth column.
 *
 * Unlike the basis, the right and left hands have the same coordinate system.
 *
 */
Bone.prototype.matrix = function () {

  if (this._matrix) return this._matrix;

  var b = this.basis,
      t = this._matrix = mat4.create();

  // open transform mat4 from rotation mat3
  t[0] = b[0][0], t[1] = b[0][1], t[2] = b[0][2];
  t[4] = b[1][0], t[5] = b[1][1], t[6] = b[1][2];
  t[8] = b[2][0], t[9] = b[2][1], t[10] = b[2][2];

  t[3] = this.center()[0];
  t[7] = this.center()[1];
  t[11] = this.center()[2];

  if (this.left()) {
    // flip the basis to be right-handed
    t[0] *= -1;
    t[1] *= -1;
    t[2] *= -1;
  }

  return this._matrix;
};

/**
 * Helper method to linearly interpolate between the two ends of the bone.
 *
 * when t = 0, the position of prevJoint will be returned
 * when t = 1, the position of nextJoint will be returned
 */
Bone.prototype.lerp = function (out, t) {

  vec3.lerp(out, this.prevJoint, this.nextJoint, t);
};

/**
 *
 * The center position of the bone
 * Returns a vec3 array.
 *
 */
Bone.prototype.center = function () {

  if (this._center) return this._center;

  var center = vec3.create();
  this.lerp(center, 0.5);
  this._center = center;
  return center;
};

// The negative of the z-basis
Bone.prototype.direction = function () {

  return [this.basis[2][0] * -1, this.basis[2][1] * -1, this.basis[2][2] * -1];
};

/***/ }),
/* 51 */
/***/ (function(module, exports) {

var CircularBuffer = module.exports = function (size) {
  this.pos = 0;
  this._buf = [];
  this.size = size;
};

CircularBuffer.prototype.get = function (i) {
  if (i == undefined) i = 0;
  if (i >= this.size) return undefined;
  if (i >= this._buf.length) return undefined;
  return this._buf[(this.pos - i - 1) % this.size];
};

CircularBuffer.prototype.push = function (o) {
  this._buf[this.pos % this.size] = o;
  return this.pos++;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var chooseProtocol = __webpack_require__(55).chooseProtocol,
    EventEmitter = __webpack_require__(3).EventEmitter,
    _ = __webpack_require__(0);

var BaseConnection = module.exports = function (opts) {
  this.opts = _.defaults(opts || {}, {
    host: '127.0.0.1',
    enableGestures: false,
    scheme: this.getScheme(),
    port: this.getPort(),
    background: false,
    optimizeHMD: false,
    requestProtocolVersion: BaseConnection.defaultProtocolVersion
  });
  this.host = this.opts.host;
  this.port = this.opts.port;
  this.scheme = this.opts.scheme;
  this.protocolVersionVerified = false;
  this.background = null;
  this.optimizeHMD = null;
  this.on('ready', function () {
    this.enableGestures(this.opts.enableGestures);
    this.setBackground(this.opts.background);
    this.setOptimizeHMD(this.opts.optimizeHMD);

    if (this.opts.optimizeHMD) {
      console.log("Optimized for head mounted display usage.");
    } else {
      console.log("Optimized for desktop usage.");
    }
  });
};

// The latest available:
BaseConnection.defaultProtocolVersion = 6;

BaseConnection.prototype.getUrl = function () {
  return this.scheme + "//" + this.host + ":" + this.port + "/v" + this.opts.requestProtocolVersion + ".json";
};

BaseConnection.prototype.getScheme = function () {
  return 'ws:';
};

BaseConnection.prototype.getPort = function () {
  return 6437;
};

BaseConnection.prototype.setBackground = function (state) {
  this.opts.background = state;
  if (this.protocol && this.protocol.sendBackground && this.background !== this.opts.background) {
    this.background = this.opts.background;
    this.protocol.sendBackground(this, this.opts.background);
  }
};

BaseConnection.prototype.setOptimizeHMD = function (state) {
  this.opts.optimizeHMD = state;
  if (this.protocol && this.protocol.sendOptimizeHMD && this.optimizeHMD !== this.opts.optimizeHMD) {
    this.optimizeHMD = this.opts.optimizeHMD;
    this.protocol.sendOptimizeHMD(this, this.opts.optimizeHMD);
  }
};

BaseConnection.prototype.handleOpen = function () {
  if (!this.connected) {
    this.connected = true;
    this.emit('connect');
  }
};

BaseConnection.prototype.enableGestures = function (enabled) {
  this.gesturesEnabled = enabled ? true : false;
  this.send(this.protocol.encode({ "enableGestures": this.gesturesEnabled }));
};

BaseConnection.prototype.handleClose = function (code, reason) {
  if (!this.connected) return;
  this.disconnect();

  // 1001 - an active connection is closed
  // 1006 - cannot connect
  if (code === 1001 && this.opts.requestProtocolVersion > 1) {
    if (this.protocolVersionVerified) {
      this.protocolVersionVerified = false;
    } else {
      this.opts.requestProtocolVersion--;
    }
  }
  this.startReconnection();
};

BaseConnection.prototype.startReconnection = function () {
  var connection = this;
  if (!this.reconnectionTimer) {
    this.reconnectionTimer = setInterval(function () {
      connection.reconnect();
    }, 500);
  }
};

BaseConnection.prototype.stopReconnection = function () {
  this.reconnectionTimer = clearInterval(this.reconnectionTimer);
};

// By default, disconnect will prevent auto-reconnection.
// Pass in true to allow the reconnection loop not be interrupted continue
BaseConnection.prototype.disconnect = function (allowReconnect) {
  if (!allowReconnect) this.stopReconnection();
  if (!this.socket) return;
  this.socket.close();
  delete this.socket;
  delete this.protocol;
  delete this.background; // This is not persisted when reconnecting to the web socket server
  delete this.optimizeHMD;
  delete this.focusedState;
  if (this.connected) {
    this.connected = false;
    this.emit('disconnect');
  }
  return true;
};

BaseConnection.prototype.reconnect = function () {
  if (this.connected) {
    this.stopReconnection();
  } else {
    this.disconnect(true);
    this.connect();
  }
};

BaseConnection.prototype.handleData = function (data) {
  var message = JSON.parse(data);

  var messageEvent;
  if (this.protocol === undefined) {
    messageEvent = this.protocol = chooseProtocol(message);
    this.protocolVersionVerified = true;
    this.emit('ready');
  } else {
    messageEvent = this.protocol(message);
  }
  this.emit(messageEvent.type, messageEvent);
};

BaseConnection.prototype.connect = function () {
  if (this.socket) return;
  this.socket = this.setupSocket();
  return true;
};

BaseConnection.prototype.send = function (data) {
  this.socket.send(data);
};

BaseConnection.prototype.reportFocus = function (state) {
  if (!this.connected || this.focusedState === state) return;
  this.focusedState = state;
  this.emit(this.focusedState ? 'focus' : 'blur');
  if (this.protocol && this.protocol.sendFocused) {
    this.protocol.sendFocused(this, this.focusedState);
  }
};

_.extend(BaseConnection.prototype, EventEmitter.prototype);

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Dialog = module.exports = function (message, options) {
  this.options = options || {};
  this.message = message;

  this.createElement();
};

Dialog.prototype.createElement = function () {
  this.element = document.createElement('div');
  this.element.className = "leapjs-dialog";
  this.element.style.position = "fixed";
  this.element.style.top = '8px';
  this.element.style.left = 0;
  this.element.style.right = 0;
  this.element.style.textAlign = 'center';
  this.element.style.zIndex = 1000;

  var dialog = document.createElement('div');
  this.element.appendChild(dialog);
  dialog.style.className = "leapjs-dialog";
  dialog.style.display = "inline-block";
  dialog.style.margin = "auto";
  dialog.style.padding = "8px";
  dialog.style.color = "#222";
  dialog.style.background = "#eee";
  dialog.style.borderRadius = "4px";
  dialog.style.border = "1px solid #999";
  dialog.style.textAlign = "left";
  dialog.style.cursor = "pointer";
  dialog.style.whiteSpace = "nowrap";
  dialog.style.transition = "box-shadow 1s linear";
  dialog.innerHTML = this.message;

  if (this.options.onclick) {
    dialog.addEventListener('click', this.options.onclick);
  }

  if (this.options.onmouseover) {
    dialog.addEventListener('mouseover', this.options.onmouseover);
  }

  if (this.options.onmouseout) {
    dialog.addEventListener('mouseout', this.options.onmouseout);
  }

  if (this.options.onmousemove) {
    dialog.addEventListener('mousemove', this.options.onmousemove);
  }
};

Dialog.prototype.show = function () {
  document.body.appendChild(this.element);
  return this;
};

Dialog.prototype.hide = function () {
  document.body.removeChild(this.element);
  return this;
};

// Shows a DOM dialog box with links to developer.leapmotion.com to upgrade
// This will work whether or not the Leap is plugged in,
// As long as it is called after a call to .connect() and the 'ready' event has fired.
Dialog.warnOutOfDate = function (params) {
  params || (params = {});

  var url = "http://developer.leapmotion.com?";

  params.returnTo = window.location.href;

  for (var key in params) {
    url += key + '=' + encodeURIComponent(params[key]) + '&';
  }

  var dialog,
      onclick = function (event) {

    if (event.target.id != 'leapjs-decline-upgrade') {

      var popup = window.open(url, '_blank', 'height=800,width=1000,location=1,menubar=1,resizable=1,status=1,toolbar=1,scrollbars=1');

      if (window.focus) {
        popup.focus();
      }
    }

    dialog.hide();

    return true;
  },
      message = "This site requires Leap Motion Tracking V2." + "<button id='leapjs-accept-upgrade'  style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 16px;'>Upgrade</button>" + "<button id='leapjs-decline-upgrade' style='color: #444; transition: box-shadow 100ms linear; cursor: pointer; vertical-align: baseline; margin-left: 8px; '>Not Now</button>";

  dialog = new Dialog(message, {
    onclick: onclick,
    onmousemove: function (e) {
      if (e.target == document.getElementById('leapjs-decline-upgrade')) {
        document.getElementById('leapjs-decline-upgrade').style.color = '#000';
        document.getElementById('leapjs-decline-upgrade').style.boxShadow = '0px 0px 2px #5daa00';

        document.getElementById('leapjs-accept-upgrade').style.color = '#444';
        document.getElementById('leapjs-accept-upgrade').style.boxShadow = 'none';
      } else {
        document.getElementById('leapjs-accept-upgrade').style.color = '#000';
        document.getElementById('leapjs-accept-upgrade').style.boxShadow = '0px 0px 2px #5daa00';

        document.getElementById('leapjs-decline-upgrade').style.color = '#444';
        document.getElementById('leapjs-decline-upgrade').style.boxShadow = 'none';
      }
    },
    onmouseout: function () {
      document.getElementById('leapjs-decline-upgrade').style.color = '#444';
      document.getElementById('leapjs-decline-upgrade').style.boxShadow = 'none';
      document.getElementById('leapjs-accept-upgrade').style.color = '#444';
      document.getElementById('leapjs-accept-upgrade').style.boxShadow = 'none';
    }
  });

  return dialog.show();
};

// Tracks whether we've warned for lack of bones API.  This will be shown only for early private-beta members.
Dialog.hasWarnedBones = false;

Dialog.warnBones = function () {
  if (this.hasWarnedBones) return;
  this.hasWarnedBones = true;

  console.warn("Your Leap Service is out of date");

  if (!(typeof process !== 'undefined' && process.versions && process.versions.node)) {
    this.warnOutOfDate({ reason: 'bones' });
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var glMatrix = __webpack_require__(2),
    vec3 = glMatrix.vec3;

/**
 * Constructs a InteractionBox object.
 *
 * @class InteractionBox
 * @memberof Leap
 * @classdesc
 * The InteractionBox class represents a box-shaped region completely within
 * the field of view of the Leap Motion controller.
 *
 * The interaction box is an axis-aligned rectangular prism and provides
 * normalized coordinates for hands, fingers, and tools within this box.
 * The InteractionBox class can make it easier to map positions in the
 * Leap Motion coordinate system to 2D or 3D coordinate systems used
 * for application drawing.
 *
 * ![Interaction Box](images/Leap_InteractionBox.png)
 *
 * The InteractionBox region is defined by a center and dimensions along the x, y, and z axes.
 */
var InteractionBox = module.exports = function (data) {
  /**
   * Indicates whether this is a valid InteractionBox object.
   *
   * @member valid
   * @type {Boolean}
   * @memberof Leap.InteractionBox.prototype
   */
  this.valid = true;
  /**
   * The center of the InteractionBox in device coordinates (millimeters).
   * This point is equidistant from all sides of the box.
   *
   * @member center
   * @type {number[]}
   * @memberof Leap.InteractionBox.prototype
   */
  this.center = data.center;

  this.size = data.size;
  /**
   * The width of the InteractionBox in millimeters, measured along the x-axis.
   *
   * @member width
   * @type {number}
   * @memberof Leap.InteractionBox.prototype
   */
  this.width = data.size[0];
  /**
   * The height of the InteractionBox in millimeters, measured along the y-axis.
   *
   * @member height
   * @type {number}
   * @memberof Leap.InteractionBox.prototype
   */
  this.height = data.size[1];
  /**
   * The depth of the InteractionBox in millimeters, measured along the z-axis.
   *
   * @member depth
   * @type {number}
   * @memberof Leap.InteractionBox.prototype
   */
  this.depth = data.size[2];
};

/**
 * Converts a position defined by normalized InteractionBox coordinates
 * into device coordinates in millimeters.
 *
 * This function performs the inverse of normalizePoint().
 *
 * @method denormalizePoint
 * @memberof Leap.InteractionBox.prototype
 * @param {number[]} normalizedPosition The input position in InteractionBox coordinates.
 * @returns {number[]} The corresponding denormalized position in device coordinates.
 */
InteractionBox.prototype.denormalizePoint = function (normalizedPosition) {
  return vec3.fromValues((normalizedPosition[0] - 0.5) * this.size[0] + this.center[0], (normalizedPosition[1] - 0.5) * this.size[1] + this.center[1], (normalizedPosition[2] - 0.5) * this.size[2] + this.center[2]);
};

/**
 * Normalizes the coordinates of a point using the interaction box.
 *
 * Coordinates from the Leap Motion frame of reference (millimeters) are
 * converted to a range of [0..1] such that the minimum value of the
 * InteractionBox maps to 0 and the maximum value of the InteractionBox maps to 1.
 *
 * @method normalizePoint
 * @memberof Leap.InteractionBox.prototype
 * @param {number[]} position The input position in device coordinates.
 * @param {Boolean} clamp Whether or not to limit the output value to the range [0,1]
 * when the input position is outside the InteractionBox. Defaults to true.
 * @returns {number[]} The normalized position.
 */
InteractionBox.prototype.normalizePoint = function (position, clamp) {
  var vec = vec3.fromValues((position[0] - this.center[0]) / this.size[0] + 0.5, (position[1] - this.center[1]) / this.size[1] + 0.5, (position[2] - this.center[2]) / this.size[2] + 0.5);

  if (clamp) {
    vec[0] = Math.min(Math.max(vec[0], 0), 1);
    vec[1] = Math.min(Math.max(vec[1], 0), 1);
    vec[2] = Math.min(Math.max(vec[2], 0), 1);
  }
  return vec;
};

/**
 * Writes a brief, human readable description of the InteractionBox object.
 *
 * @method toString
 * @memberof Leap.InteractionBox.prototype
 * @returns {String} A description of the InteractionBox object as a string.
 */
InteractionBox.prototype.toString = function () {
  return "InteractionBox [ width:" + this.width + " | height:" + this.height + " | depth:" + this.depth + " ]";
};

/**
 * An invalid InteractionBox object.
 *
 * You can use this InteractionBox instance in comparisons testing
 * whether a given InteractionBox instance is valid or invalid. (You can also use the
 * InteractionBox.valid property.)
 *
 * @static
 * @type {Leap.InteractionBox}
 * @name Invalid
 * @memberof Leap.InteractionBox
 */
InteractionBox.Invalid = { valid: false };

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var Frame = __webpack_require__(24),
    Hand = __webpack_require__(11),
    Pointable = __webpack_require__(4),
    Finger = __webpack_require__(10),
    _ = __webpack_require__(0),
    EventEmitter = __webpack_require__(3).EventEmitter;

var Event = function (data) {
  this.type = data.type;
  this.state = data.state;
};

exports.chooseProtocol = function (header) {
  var protocol;
  switch (header.version) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      protocol = JSONProtocol(header);
      protocol.sendBackground = function (connection, state) {
        connection.send(protocol.encode({ background: state }));
      };
      protocol.sendFocused = function (connection, state) {
        connection.send(protocol.encode({ focused: state }));
      };
      protocol.sendOptimizeHMD = function (connection, state) {
        connection.send(protocol.encode({ optimizeHMD: state }));
      };
      break;
    default:
      throw "unrecognized version";
  }
  return protocol;
};

var JSONProtocol = exports.JSONProtocol = function (header) {

  var protocol = function (frameData) {

    if (frameData.event) {

      return new Event(frameData.event);
    } else {

      protocol.emit('beforeFrameCreated', frameData);

      var frame = new Frame(frameData);

      protocol.emit('afterFrameCreated', frame, frameData);

      return frame;
    }
  };

  protocol.encode = function (message) {
    return JSON.stringify(message);
  };
  protocol.version = header.version;
  protocol.serviceVersion = header.serviceVersion;
  protocol.versionLong = 'Version ' + header.version;
  protocol.type = 'protocol';

  _.extend(protocol, EventEmitter.prototype);

  return protocol;
};

/***/ }),
/* 56 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = render;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_d3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_d3__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_three__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_webpack_zepto__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_webpack_zepto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_webpack_zepto__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__styles_map_less__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__styles_map_less___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__styles_map_less__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__input_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__global_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__data_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__math_particlesys_js__ = __webpack_require__(122);









var selection_title = __WEBPACK_IMPORTED_MODULE_2_webpack_zepto__("<div class='selection_title'>国家</div>");
selection_title.appendTo(__WEBPACK_IMPORTED_MODULE_2_webpack_zepto__("body"));

var container = __WEBPACK_IMPORTED_MODULE_2_webpack_zepto__(`<div class='labelContainer'></div>`);
container.appendTo(__WEBPACK_IMPORTED_MODULE_2_webpack_zepto__("body"));

var svg = __WEBPACK_IMPORTED_MODULE_0_d3__["select"]("svg");
var projector = __WEBPACK_IMPORTED_MODULE_0_d3__["geoMercator"]().center([105.5, 38.7]).scale(800).translate([1080 / 2, 1080 / 2]);

var scene = new __WEBPACK_IMPORTED_MODULE_1_three__["a" /* Scene */]();
var camera = new __WEBPACK_IMPORTED_MODULE_1_three__["b" /* PerspectiveCamera */](50, 1, 0.1, 6000);
var renderer = new __WEBPACK_IMPORTED_MODULE_1_three__["c" /* WebGLRenderer */]({ antialias: true, alpha: true, canvas: document.querySelector('#canvasMap') });
var raycaster = new __WEBPACK_IMPORTED_MODULE_1_three__["d" /* Raycaster */]();
var mouse = new __WEBPACK_IMPORTED_MODULE_1_three__["e" /* Vector2 */]();

var plane = new __WEBPACK_IMPORTED_MODULE_1_three__["f" /* Mesh */](new __WEBPACK_IMPORTED_MODULE_1_three__["g" /* PlaneGeometry */](1080, 1080), new __WEBPACK_IMPORTED_MODULE_1_three__["h" /* MeshBasicMaterial */]({ color: 0xffaaff, transparent: true, opacity: 0.0 }));

function setup() {

    var geoPathGenerator = __WEBPACK_IMPORTED_MODULE_0_d3__["geoPath"]().projection(projector);
    svg.append("g").attr("class", "map states").selectAll("path").data(__WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.geojson.features).enter().append("path").attr("d", geoPathGenerator);

    camera.position.set(0, 0, 1080 + 80);
    camera.position.tx = 0;
    camera.position.ty = 0;
    camera.position.tz = 0;

    plane.position.z = 0;
    scene.add(camera);
    scene.add(plane);

    renderer.setClearColor(0x000000, 0);
    renderer.setSize(1080, 1080);

    setupProvinces();
}

__WEBPACK_IMPORTED_MODULE_6__data_js__["b" /* event */].on("ready", setup);

function render() {

    if (!__WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].ready) return;

    if (__WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].flying) {
        Map_State.Selection_Spot = undefined;
        if (__WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].highlock) {
            Map_State.Mode = -1;
            Map_State.Selection = -1;
            camera.position.ty = 0;
            camera.position.tx = 0;
            camera.position.tz = 1080;
        } else {
            Map_State.Mode = 0; //Province Selection
            camera.position.ty = (-__WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].ey + 1080 / 2) * 0.9;
            camera.position.tx = (+__WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].ex - 1080 / 2) * 0.9;
            camera.position.tz = __WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].ez / 1.5 + 30;
        }
    } else if (!__WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].highlock && Map_State.Mode >= 0) {
        //good pos
        Map_State.Mode = 1;
    }

    ease(camera.position, 'tx', 'x');
    ease(camera.position, 'ty', 'y');
    ease(camera.position, 'tz', 'z');

    if (Map_State.Mode >= 0 && __WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].flying) {

        //raycast
        mouse.x = __WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].ex / 1080 * 2 - 1;
        mouse.y = 1 - __WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].ey / 1080 * 2;
        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObject(plane);
        if (intersects.length) {
            var point = intersects[0].point;
            var x = point.x + 1080 / 2;
            var y = 1080 / 2 - point.y;
            var elems = document.elementsFromPoint(x, y);
            for (var i = 0; i < elems.length; i++) {
                if (elems[i].tagName.toUpperCase() == "PATH") {
                    // console.log("hit", elems[i].__data__.properties.id);
                    // test_set_highlight(parseInt())
                    var hit = parseInt(elems[i].__data__.properties.id);
                    Map_State.Selection = hit;
                    break;
                }
            }
        }
    }

    if (Map_State.Mode == 1 && Map_State.Selection_Spot) {
        selection_title.text(Map_State.Selection_Spot.name);
    } else if (Map_State.Mode >= 0) {
        if (__WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.provinces[Map_State.Selection]) {
            selection_title.text(__WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.provinces[Map_State.Selection].name);
        }
    } else if (Map_State.Mode == -1) {
        selection_title.text("全国数据");
    }

    renderProvinces();
    renderer.render(scene, camera);
}

var Map_State = {
    Mode: -1,
    Selection: -1,
    Selection_Spot: undefined
};

var Provinces = {};

function setupProvinces() {
    for (var i in __WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map_postfab.points_l) {
        var pv = new Province(__WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.provinces[i], __WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map_postfab.points_l[i]);
        Provinces[i] = pv;
    }
}

function renderProvinces() {
    for (var i in Provinces) {
        Provinces[i].render();
    }
}

class position_2d {
    constructor(pos) {
        this.cp_vector = projector(pos);
        this.vec3 = new __WEBPACK_IMPORTED_MODULE_1_three__["i" /* Vector3 */](this.cp_vector[0] - 1080 / 2, 1080 / 2 - this.cp_vector[1], 0);
        this.vec2 = undefined;
    }

    update2d() {
        this.vec2 = new __WEBPACK_IMPORTED_MODULE_1_three__["i" /* Vector3 */](this.vec3.x, this.vec3.y, this.vec3.z).project(camera);
    }
}

class Province extends position_2d {
    //point cloud
    //0.05 + Math.random() * 0.1
    constructor(d, points) {
        super(d.cp);

        this.data = d;
        this.name = this.data.name;
        this.points = points;
        this.id = d.id;

        this.spotsArr = [];
        this.spots = {};
        this.spotCount = 0;
        for (var i = 0; i < __WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.markers.cities.length; i++) {
            var cur = __WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.markers.cities[i];
            if (cur.area == this.name) {
                this.spots[cur.name] = new Spot(cur, 'city');
                this.spotsArr.push(this.spots[cur.name]);
                this.spotCount++;
            }
        }

        for (var i = 0; i < __WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.markers.counties.length; i++) {
            var cur = __WEBPACK_IMPORTED_MODULE_6__data_js__["a" /* data */].map.markers.counties[i];
            if (cur.area == this.name) {
                this.spots[cur.name] = new Spot(cur, 'county');
                this.spotsArr.push(this.spots[cur.name]);
                this.spotCount++;
            }
        }

        this.collisionRemoval = new Array(this.spotCount);

        this.color = {
            o: 1, to: 1, h: 0.55, s: 1, l: 0.5, tl: 1, ol: 1
        };
        this.psys = new __WEBPACK_IMPORTED_MODULE_7__math_particlesys_js__["a" /* ParticleSys */](points.length);
        this.three_material = new __WEBPACK_IMPORTED_MODULE_1_three__["j" /* PointsMaterial */]({
            size: 3, sizeAttenuation: true,
            // vertexColors: THREE.VertexColors,
            color: new __WEBPACK_IMPORTED_MODULE_1_three__["k" /* Color */](0.2, 0.2, 0.2),
            blending: __WEBPACK_IMPORTED_MODULE_1_three__["l" /* AdditiveBlending */],
            depthTest: false,
            transparent: false
        });
        this.three_geometry = new __WEBPACK_IMPORTED_MODULE_1_three__["m" /* Geometry */]();
        for (var i = 0; i < points.length; i++) {
            var pt = points[i];
            this.psys.Points[i].x = pt.x - 1080 / 2;
            this.psys.Points[i].y = 1080 / 2 - pt.y;
            this.psys.Points[i].z = 0;

            this.three_geometry.colors.push(new __WEBPACK_IMPORTED_MODULE_1_three__["k" /* Color */](1, 1, 1));
            this.three_geometry.vertices.push(new __WEBPACK_IMPORTED_MODULE_1_three__["i" /* Vector3 */](this.psys.Points[i].x, this.psys.Points[i].y, this.psys.Points[i].z));
        }
        this.three_pointCloud = new __WEBPACK_IMPORTED_MODULE_1_three__["n" /* Points */](this.three_geometry, this.three_material);
        scene.add(this.three_pointCloud);

        if (!/香港|澳门|台湾/.test(this.name)) {
            this.label = __WEBPACK_IMPORTED_MODULE_2_webpack_zepto__(`<div class='label'>${this.name}</div>`).css({
                'transform-origin': "50% 50%",
                transform: "translate3d(540px, 540px, 0px)",
                position: "absolute"
            }).appendTo(container).get(0);
        }
        this.selection = 0;
        this.tselection = 0;
    }

    render() {
        super.update2d();
        if (this.label) {
            var scale = this.selection * 0.3 + 1;
            this.label.style.opacity = (0.5 - this.selection / 2) * (Map_State.Mode >= 0 ? 1 : 0);
            this.label.style.transform = `translate3d(${(this.vec2.x + 1) / 2 * 1080}px, ${(1 - this.vec2.y) / 2 * 1080}px, -1px) scale(${scale}, ${scale})`;
            this.label.style.backgroundColor = `rgba(0, 0, 0, ${this.selection})`;
        }
        this.tselection = 0;
        if (this.id == Map_State.Selection) {
            //selected!
            this.three_material.tsize = Math.min(1, Math.max(Math.sqrt(camera.position.z / 150 - 0.7), 0.01)) * (5 + 2 * Math.abs(Math.sin(t * 20)));
            this.color.to = 1; // - camera.position.z / 1000;
            this.color.tl = 2; //camera.position.z / 100;
            this.tselection = 1;
        } else if (!__WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].flying && Map_State.Mode >= 0) {
            this.three_material.tsize = 4;
            this.color.tl = 0.2;
            this.color.to = 0;
        } else {
            this.color.tl = 0.4;
            this.color.to = 1;
            this.three_material.tsize = 4 + Math.abs(Math.sin(this.data.cp[0] / 2) * 3);
        }

        ease(this, 'tselection', 'selection', 0.1, 0.01);
        ease(this.color, 'to', 'o', 0.1, 0.001);
        ease(this.color, 'tl', 'ol', 0.1, 0.001);
        var hsl = hsl_raw(this.color.h, this.color.s * this.color.o, this.color.l * this.color.ol);
        this.three_material.color.setRGB(hsl[0], hsl[1], hsl[2]);
        ease(this.three_material, "tsize", "size", 0.08, 0.01);
        // this.psys.update();
        // for (var i = 0; i < this.psys.Points.length; i++) {
        //     var p = this.psys.Points[i];
        //     this.three_geometry.vertices[i].x = p.x;
        //     this.three_geometry.vertices[i].y = p.y;
        //     this.three_geometry.vertices[i].z = p.z;
        //     // this.three_geometry.colors[i].r = p.r;
        //     // this.three_geometry.colors[i].g = p.g;
        //     // this.three_geometry.colors[i].b = p.b;
        // }

        // var dt = [];
        if (this.tselection && Map_State.Mode == 1) {
            var minsq = 99999;
            var minid = undefined;
            for (var i in this.spots) {
                if (this.spots.hasOwnProperty(i)) {
                    this.spots[i].update2d();
                    var dx = (this.spots[i].vec2.x + 1) / 2 * 1080 - __WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].ex;
                    var dy = (1 - this.spots[i].vec2.y) / 2 * 1080 - __WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].ey;
                    var val = dx * dx + dy * dy;
                    // console.log(val);
                    if (val < 100 * 100 && val < minsq) {
                        minsq = val;
                        minid = i;
                    }
                }
            }
            if (minid) {
                this.spots[minid].selecting = true;
            }
        }

        // var strategy = layoutTool.layoutAnnealing();
        // var result = strategy(dt);
        // var count = 0;

        for (var i in this.spots) {
            this.spots[i].update2d();
            this.spots[i].show = this.tselection;
            if (this.spots.hasOwnProperty(i)) {
                // this.spots[i].vec2.x = result[count].x;
                // this.spots[i].vec2.y = result[count].y;
                this.spots[i].render();
                // count++;
                this.spots[i].selecting = false; //restore
            }
        }
    }

}

//city, county
class Spot extends position_2d {

    constructor(data, type) {
        super(data.pos);
        this.data = data;
        this.type = type;

        this.selecting = false;
        this.selectionHold = 0;

        this.show = false;
        this.name = this.data.name;
        this.province = this.data.area;

        this.three_material = new __WEBPACK_IMPORTED_MODULE_1_three__["h" /* MeshBasicMaterial */]({
            opacity: 1,
            // blending: THREE.AdditiveBlending,
            // depthTest: false,
            color: new __WEBPACK_IMPORTED_MODULE_1_three__["k" /* Color */](1, 1, 1),
            transparent: true
        });
        this.three_geometry = new __WEBPACK_IMPORTED_MODULE_1_three__["o" /* CircleGeometry */](1, 90);
        this.three_mesh = new __WEBPACK_IMPORTED_MODULE_1_three__["f" /* Mesh */](this.three_geometry, this.three_material);

        this.three_mesh.position.x = this.vec3.x;
        this.three_mesh.position.y = this.vec3.y;
        this.three_mesh.position.z = 2;

        scene.add(this.three_mesh);

        this.three_selection_material = new __WEBPACK_IMPORTED_MODULE_1_three__["h" /* MeshBasicMaterial */]({
            opacity: 1,
            // blending: THREE.AdditiveBlending,
            // depthTest: false,
            color: new __WEBPACK_IMPORTED_MODULE_1_three__["k" /* Color */](1, 1, 1),
            transparent: true
        });

        this.three_selection_geometry = new __WEBPACK_IMPORTED_MODULE_1_three__["o" /* CircleGeometry */](9, 90);
        this.three_selection_mesh = new __WEBPACK_IMPORTED_MODULE_1_three__["f" /* Mesh */](this.three_selection_geometry, this.three_selection_material);

        this.three_selection_mesh.position.x = this.vec3.x;
        this.three_selection_mesh.position.y = this.vec3.y;
        this.three_selection_mesh.position.z = 1;
        this.three_selection_mesh.scale.setLength(0.1);

        scene.add(this.three_selection_mesh);

        this.label = __WEBPACK_IMPORTED_MODULE_2_webpack_zepto__(`<div class='label-tiny'>${this.name}</div>`).css({
            'transform-origin': "50% 50%",
            transform: "translate3d(540px, 540px, 0px)",
            position: "absolute"
        }).appendTo(container).get(0);
        this.selection = 0;
        this.tselection = 0;

        this.meshScale = 0;
        this.tmeshScale = 0;
        if (this.type == 'city') {
            this.color = {
                th: 0.55, ts: 1, tl: 0.5,
                h: 0.55, s: 1, l: 0.5
            };
            this.colorScheme = {
                th: 0.55, ts: 1, tl: 0.5,
                h: 0.55, s: 1, l: 0.5
            };
            this.scale = 3;
        } else {
            this.color = {
                th: 0.4, ts: 1, tl: 0.5,
                h: 0.4, s: 1, l: 0.5
            };
            this.colorScheme = {
                th: 0.4, ts: 1, tl: 0.5,
                h: 0.4, s: 1, l: 0.5
            };
            this.scale = 2;
        }
    }

    render() {
        ease(this, 'tselection', 'selection', 0.1, 0.01);

        var ox = Math.sin(t * 50 + this.vec2.x * 4);
        var offset = 1 + 0.3 * ox;

        if (this.show) {
            this.color.th = this.colorScheme.th;
            this.color.ts = this.colorScheme.ts;
            this.color.tl = this.colorScheme.tl;

            this.tmeshScale = this.scale * (offset * (0.5 + this.selection * 0.7)) * 1.5;
            this.label.style.display = 'block';
            var scale = this.selection * 0.3 + 1;
            this.label.style.opacity = 1;
            this.label.style.transform = `translate3d(${(this.vec2.x + 1) / 2 * 1080}px, ${(1 - this.vec2.y) / 2 * 1080 + 30}px, -1px) scale(${scale}, ${scale})`;
            this.label.style.backgroundColor = `rgba(0, 0, 0, 1)`;
            if (this.tselection) {
                this.label.style.zIndex = 888888;
            } else {
                this.label.style.zIndex = 10;
            }
        } else if (__WEBPACK_IMPORTED_MODULE_4__input_js__["c" /* mouse */].flying || Map_State.Mode < 0) {
            this.tmeshScale = offset * offset;
            this.color.ts = 1;
            this.color.tl = 2;
            this.label.style.display = 'none';
        } else {
            this.tmeshScale = 1;
            this.color.ts = 0.8;
            this.color.tl = .1;
            this.three_material.color.setRGB(0.3, 0.3, 0.3);
            this.label.style.display = 'none';
        }

        ease(this.color, 'th', 'h');
        ease(this.color, 'ts', 's');
        ease(this.color, 'tl', 'l');
        ease(this, 'tmeshScale', 'meshScale');

        var rgb = hsl_raw(this.color.h, this.color.s, this.color.l);
        this.three_material.color.setRGB(rgb[0], rgb[1], rgb[2]);
        this.three_mesh.scale.set(this.meshScale, this.meshScale, this.meshScale);

        if (this.selecting && !this.tselection) {
            this.selectionHold += (2 - this.selectionHold) * 0.03;
            if (this.selectionHold > 1.8) {
                Map_State.Selection_Spot = this.data;
            }
        } else {
            this.selectionHold += (0.1 - this.selectionHold) * 0.1;
        }

        if (this.data == Map_State.Selection_Spot) {
            this.tselection = 1;
        } else {
            this.tselection = 0;
        }

        ease(this, 'tselection', 'selection');
        this.three_selection_mesh.scale.setLength(this.selectionHold + this.selection);
    }

}

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = render;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__global_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stick_js__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_webpack_zepto__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_webpack_zepto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_webpack_zepto__);




var img = document.createElement("img");
img.src = '/images/map 2.png';

function render() {
    pushMatrix(__WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */], () => {
        __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].strokeStyle = "#000";
        __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].translate(1080 / 2, 1080 / 2);
        __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].beginPath();
        __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].arc(0, 0, 1080 / 2, 0, Math.PI * 2);
        __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].stroke();

        pushMatrix(__WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */], () => {
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].translate(-1080 / 2 + 50, -1080 / 2 + 150);
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].scale(0.9, 0.9);
            // ctx2d.drawImage(img, 55, 55);
        });

        // ctx2d.rotate(t * 2);

        // for (var i = 0; i < 360; i += 1) {
        //     var deg = i / 360 * Math.PI * 2;
        //     ctx2d.strokeStyle = "#02c2f2";
        //     pushMatrix(ctx2d, () => {
        //         ctx2d.beginPath();
        //         ctx2d.rotate(deg);
        //         let j = Math.sin(t * 40 + deg * 10) * Math.cos(t * 30 - deg * 3) * 10;
        //         ctx2d.moveTo(1080 / 2 - j - 55, 0);
        //         ctx2d.lineTo(1080 / 2 + j - 55, 0);
        //         ctx2d.stroke();
        //     });
        // }

        var targetDeg = Math.atan2(__WEBPACK_IMPORTED_MODULE_0__global_js__["c" /* mouse */].ey - 1080 / 2, __WEBPACK_IMPORTED_MODULE_0__global_js__["c" /* mouse */].ex - 1080 / 2);
        var radius = 1 - distsq(__WEBPACK_IMPORTED_MODULE_0__global_js__["c" /* mouse */].ey, __WEBPACK_IMPORTED_MODULE_0__global_js__["c" /* mouse */].ex, 1080 / 2, 1080 / 2) / 291600;
        var offset = t % Math.PI;
        for (var i = 0; i < 360; i += 1) {
            var deg = i / 360 * Math.PI * 2 + offset;
            __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].strokeStyle = "#02c2f2";
            pushMatrix(__WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */], () => {
                let j = Math.pow(Math.cos((deg - targetDeg) / 2), 500);
                // j *= Math.cos(t * 30);
                // ctx2d.strokeStyle = hsl(0.55, j / 3 + 0.4, 1);
                __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].lineWidth = j + 1;
                __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].beginPath();
                __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].rotate(deg);
                __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].moveTo(1080 / 2, 0);
                __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].lineTo(1080 / 2 - 5 - j * radius * radius * 50, 0);
                __WEBPACK_IMPORTED_MODULE_0__global_js__["b" /* ctx2d */].stroke();
            });
        }
        holder_time_l.render();
        holder_left.render();
        holder_right.render();
    });
}

var holder_left = new __WEBPACK_IMPORTED_MODULE_1__stick_js__["a" /* stickHolder */](["城市常住人口|万人", "公共财政预算收入|亿元", "食品工业产值|亿元", "食品生产经营单位数|家", "食品工业产值年增幅|%", "食品工业产值占地区生产总值比重|%", "食品安全经费决算金额|万元", "食品执法车辆总数|辆", "执法装备价值|万元", "食品安全工作考核占比|%", "检查食品生产经营主体次数|家次", "抽检数量|批次", "办案数量|件", "涉案货值|万元", "罚没款金额|万元", "刑事立案数量|件", "追究刑责人数|人", "抽检合格率|%", "创建工作知晓度|%", "当地食品安全总体满意度|%", "受理投诉举报数量|件", "办结投诉举报数量|件"]);

var holder_right = new __WEBPACK_IMPORTED_MODULE_1__stick_js__["a" /* stickHolder */](["农产品质量安全监管工作在县级人民政府绩效考核体系中的比重|%", "关于农产品质量安全纳入财政预算的资金规摸|万元", "县级监管/协管人员|名", "乡镇级监管/协管人员|名", "村级监管/协管人员|名", "群众满意度|%", "质量安全水平|%", "全县设有监管机构的乡镇数|个", "定性检测检测产品数量|个", "定量检测检测产品数量|个", "检测产品数量|个", "“三品一标”产品数量|个", "“三品一标”产地面积占耕地面积比|%", "“三园两场”数量|个", "标准化生产基地面积 总面积占比|%", "标准化生产园（场）占比|%", "纳入追溯平台管理的农产品生产经营主体|个", "纳入监管信息平台管理的农业投入品生产经营主体|个", "组织开展农产品质量安全培训|人次", "开展农产品质量安全执法|次", "开展农产品质量安全宣传|次"], 180, 0.3);

var holder_time_l = new __WEBPACK_IMPORTED_MODULE_1__stick_js__["a" /* stickHolder */](["全览| ", "创县| ", "创城 - 第三批| ", "创城 - 第二批| ", "创城 - 第一批| "], 70, 0);

holder_left.setup();
holder_time_l.setup();
holder_right.setup();

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(124);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(27)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/index.js!./main.less", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/index.js!./main.less");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var BaseConnection = module.exports = __webpack_require__(52),
    _ = __webpack_require__(0);

var BrowserConnection = module.exports = function (opts) {
  BaseConnection.call(this, opts);
  var connection = this;
  this.on('ready', function () {
    connection.startFocusLoop();
  });
  this.on('disconnect', function () {
    connection.stopFocusLoop();
  });
};

_.extend(BrowserConnection.prototype, BaseConnection.prototype);

BrowserConnection.__proto__ = BaseConnection;

BrowserConnection.prototype.useSecure = function () {
  return location.protocol === 'https:';
};

BrowserConnection.prototype.getScheme = function () {
  return this.useSecure() ? 'wss:' : 'ws:';
};

BrowserConnection.prototype.getPort = function () {
  return this.useSecure() ? 6436 : 6437;
};

BrowserConnection.prototype.setupSocket = function () {
  var connection = this;
  var socket = new WebSocket(this.getUrl());
  socket.onopen = function () {
    connection.handleOpen();
  };
  socket.onclose = function (data) {
    connection.handleClose(data['code'], data['reason']);
  };
  socket.onmessage = function (message) {
    connection.handleData(message.data);
  };
  socket.onerror = function (error) {

    // attempt to degrade to ws: after one failed attempt for older Leap Service installations.
    if (connection.useSecure() && connection.scheme === 'wss:') {
      connection.scheme = 'ws:';
      connection.port = 6437;
      connection.disconnect();
      connection.connect();
    }
  };
  return socket;
};

BrowserConnection.prototype.startFocusLoop = function () {
  if (this.focusDetectorTimer) return;
  var connection = this;
  var propertyName = null;
  if (typeof document.hidden !== "undefined") {
    propertyName = "hidden";
  } else if (typeof document.mozHidden !== "undefined") {
    propertyName = "mozHidden";
  } else if (typeof document.msHidden !== "undefined") {
    propertyName = "msHidden";
  } else if (typeof document.webkitHidden !== "undefined") {
    propertyName = "webkitHidden";
  } else {
    propertyName = undefined;
  }

  if (connection.windowVisible === undefined) {
    connection.windowVisible = propertyName === undefined ? true : document[propertyName] === false;
  }

  var focusListener = window.addEventListener('focus', function (e) {
    connection.windowVisible = true;
    updateFocusState();
  });

  var blurListener = window.addEventListener('blur', function (e) {
    connection.windowVisible = false;
    updateFocusState();
  });

  this.on('disconnect', function () {
    window.removeEventListener('focus', focusListener);
    window.removeEventListener('blur', blurListener);
  });

  var updateFocusState = function () {
    var isVisible = propertyName === undefined ? true : document[propertyName] === false;
    connection.reportFocus(isVisible && connection.windowVisible);
  };

  // save 100ms when resuming focus
  updateFocusState();

  this.focusDetectorTimer = setInterval(updateFocusState, 100);
};

BrowserConnection.prototype.stopFocusLoop = function () {
  if (!this.focusDetectorTimer) return;
  clearTimeout(this.focusDetectorTimer);
  delete this.focusDetectorTimer;
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var WebSocket = __webpack_require__(120),
    BaseConnection = __webpack_require__(52),
    _ = __webpack_require__(0);

var NodeConnection = module.exports = function (opts) {
  BaseConnection.call(this, opts);
  var connection = this;
  this.on('ready', function () {
    connection.reportFocus(true);
  });
};

_.extend(NodeConnection.prototype, BaseConnection.prototype);

NodeConnection.__proto__ = BaseConnection;

NodeConnection.prototype.setupSocket = function () {
  var connection = this;
  var socket = new WebSocket(this.getUrl());
  socket.on('open', function () {
    connection.handleOpen();
  });
  socket.on('message', function (m) {
    connection.handleData(m);
  });
  socket.on('close', function (code, reason) {
    connection.handleClose(code, reason);
  });
  socket.on('error', function () {
    connection.startReconnection();
  });
  return socket;
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Frame = __webpack_require__(24),
    Hand = __webpack_require__(11),
    Pointable = __webpack_require__(4),
    Finger = __webpack_require__(10),
    CircularBuffer = __webpack_require__(51),
    Pipeline = __webpack_require__(114),
    EventEmitter = __webpack_require__(3).EventEmitter,
    gestureListener = __webpack_require__(25).gestureListener,
    Dialog = __webpack_require__(53),
    _ = __webpack_require__(0);

/**
 * Constructs a Controller object.
 *
 * When creating a Controller object, you may optionally pass in options
 * to set the host , set the port, enable gestures, or select the frame event type.
 *
 * ```javascript
 * var controller = new Leap.Controller({
 *   host: '127.0.0.1',
 *   port: 6437,
 *   enableGestures: true,
 *   frameEventName: 'animationFrame'
 * });
 * ```
 *
 * @class Controller
 * @memberof Leap
 * @classdesc
 * The Controller class is your main interface to the Leap Motion Controller.
 *
 * Create an instance of this Controller class to access frames of tracking data
 * and configuration information. Frame data can be polled at any time using the
 * [Controller.frame]{@link Leap.Controller#frame}() function. Call frame() or frame(0) to get the most recent
 * frame. Set the history parameter to a positive integer to access previous frames.
 * A controller stores up to 60 frames in its frame history.
 *
 * Polling is an appropriate strategy for applications which already have an
 * intrinsic update loop, such as a game.
 *
 * loopWhileDisconnected defaults to true, and maintains a 60FPS frame rate even when Leap Motion is not streaming
 * data at that rate (such as no hands in frame).  This is important for VR/WebGL apps which rely on rendering for
 * regular visual updates, including from other input devices.  Flipping this to false should be considered an
 * optimization for very specific use-cases.
 *
 *
 */

var Controller = module.exports = function (opts) {
  var inNode = typeof process !== 'undefined' && process.versions && process.versions.node,
      controller = this;

  opts = _.defaults(opts || {}, {
    inNode: inNode
  });

  this.inNode = opts.inNode;

  opts = _.defaults(opts || {}, {
    frameEventName: this.useAnimationLoop() ? 'animationFrame' : 'deviceFrame',
    suppressAnimationLoop: !this.useAnimationLoop(),
    loopWhileDisconnected: true,
    useAllPlugins: false,
    checkVersion: true
  });

  this.animationFrameRequested = false;
  this.onAnimationFrame = function (timestamp) {
    if (controller.lastConnectionFrame.valid) {
      controller.emit('animationFrame', controller.lastConnectionFrame);
    }
    controller.emit('frameEnd', timestamp);
    if (controller.loopWhileDisconnected && (controller.connection.focusedState !== false || // loop while undefined, pre-ready.
    controller.connection.opts.background)) {
      window.requestAnimationFrame(controller.onAnimationFrame);
    } else {
      controller.animationFrameRequested = false;
    }
  };
  this.suppressAnimationLoop = opts.suppressAnimationLoop;
  this.loopWhileDisconnected = opts.loopWhileDisconnected;
  this.frameEventName = opts.frameEventName;
  this.useAllPlugins = opts.useAllPlugins;
  this.history = new CircularBuffer(200);
  this.lastFrame = Frame.Invalid;
  this.lastValidFrame = Frame.Invalid;
  this.lastConnectionFrame = Frame.Invalid;
  this.accumulatedGestures = [];
  this.checkVersion = opts.checkVersion;
  if (opts.connectionType === undefined) {
    this.connectionType = this.inBrowser() ? __webpack_require__(110) : __webpack_require__(111);
  } else {
    this.connectionType = opts.connectionType;
  }
  this.connection = new this.connectionType(opts);
  this.streamingCount = 0;
  this.devices = {};
  this.plugins = {};
  this._pluginPipelineSteps = {};
  this._pluginExtendedMethods = {};
  if (opts.useAllPlugins) this.useRegisteredPlugins();
  this.setupFrameEvents(opts);
  this.setupConnectionEvents();

  this.startAnimationLoop(); // immediately when started
};

Controller.prototype.gesture = function (type, cb) {
  var creator = gestureListener(this, type);
  if (cb !== undefined) {
    creator.stop(cb);
  }
  return creator;
};

/*
 * @returns the controller
 */
Controller.prototype.setBackground = function (state) {
  this.connection.setBackground(state);
  return this;
};

Controller.prototype.setOptimizeHMD = function (state) {
  this.connection.setOptimizeHMD(state);
  return this;
};

Controller.prototype.inBrowser = function () {
  return !this.inNode;
};

Controller.prototype.useAnimationLoop = function () {
  return this.inBrowser() && !this.inBackgroundPage();
};

Controller.prototype.inBackgroundPage = function () {
  // http://developer.chrome.com/extensions/extension#method-getBackgroundPage
  return typeof chrome !== "undefined" && chrome.extension && chrome.extension.getBackgroundPage && chrome.extension.getBackgroundPage() === window;
};

/*
 * @returns the controller
 */
Controller.prototype.connect = function () {
  this.connection.connect();
  return this;
};

Controller.prototype.streaming = function () {
  return this.streamingCount > 0;
};

Controller.prototype.connected = function () {
  return !!this.connection.connected;
};

Controller.prototype.startAnimationLoop = function () {
  if (!this.suppressAnimationLoop && !this.animationFrameRequested) {
    this.animationFrameRequested = true;
    window.requestAnimationFrame(this.onAnimationFrame);
  }
};

/*
 * @returns the controller
 */
Controller.prototype.disconnect = function () {
  this.connection.disconnect();
  return this;
};

/**
 * Returns a frame of tracking data from the Leap.
 *
 * Use the optional history parameter to specify which frame to retrieve.
 * Call frame() or frame(0) to access the most recent frame; call frame(1) to
 * access the previous frame, and so on. If you use a history value greater
 * than the number of stored frames, then the controller returns an invalid frame.
 *
 * @method frame
 * @memberof Leap.Controller.prototype
 * @param {number} history The age of the frame to return, counting backwards from
 * the most recent frame (0) into the past and up to the maximum age (59).
 * @returns {Leap.Frame} The specified frame; or, if no history
 * parameter is specified, the newest frame. If a frame is not available at
 * the specified history position, an invalid Frame is returned.
 **/
Controller.prototype.frame = function (num) {
  return this.history.get(num) || Frame.Invalid;
};

Controller.prototype.loop = function (callback) {
  if (callback) {
    if (typeof callback === 'function') {
      this.on(this.frameEventName, callback);
    } else {
      // callback is actually of the form: {eventName: callback}
      this.setupFrameEvents(callback);
    }
  }

  return this.connect();
};

Controller.prototype.addStep = function (step) {
  if (!this.pipeline) this.pipeline = new Pipeline(this);
  this.pipeline.addStep(step);
};

// this is run on every deviceFrame
Controller.prototype.processFrame = function (frame) {
  if (frame.gestures) {
    this.accumulatedGestures = this.accumulatedGestures.concat(frame.gestures);
  }
  // lastConnectionFrame is used by the animation loop
  this.lastConnectionFrame = frame;
  this.startAnimationLoop(); // Only has effect if loopWhileDisconnected: false
  this.emit('deviceFrame', frame);
};

// on a this.deviceEventName (usually 'animationFrame' in browsers), this emits a 'frame'
Controller.prototype.processFinishedFrame = function (frame) {
  this.lastFrame = frame;
  if (frame.valid) {
    this.lastValidFrame = frame;
  }
  frame.controller = this;
  frame.historyIdx = this.history.push(frame);
  if (frame.gestures) {
    frame.gestures = this.accumulatedGestures;
    this.accumulatedGestures = [];
    for (var gestureIdx = 0; gestureIdx != frame.gestures.length; gestureIdx++) {
      this.emit("gesture", frame.gestures[gestureIdx], frame);
    }
  }
  if (this.pipeline) {
    frame = this.pipeline.run(frame);
    if (!frame) frame = Frame.Invalid;
  }
  this.emit('frame', frame);
  this.emitHandEvents(frame);
};

/**
 * The controller will emit 'hand' events for every hand on each frame.  The hand in question will be passed
 * to the event callback.
 *
 * @param frame
 */
Controller.prototype.emitHandEvents = function (frame) {
  for (var i = 0; i < frame.hands.length; i++) {
    this.emit('hand', frame.hands[i]);
  }
};

Controller.prototype.setupFrameEvents = function (opts) {
  if (opts.frame) {
    this.on('frame', opts.frame);
  }
  if (opts.hand) {
    this.on('hand', opts.hand);
  }
};

/**
  Controller events.  The old 'deviceConnected' and 'deviceDisconnected' have been depricated -
  use 'deviceStreaming' and 'deviceStopped' instead, except in the case of an unexpected disconnect.

  There are 4 pairs of device events recently added/changed:
  -deviceAttached/deviceRemoved - called when a device's physical connection to the computer changes
  -deviceStreaming/deviceStopped - called when a device is paused or resumed.
  -streamingStarted/streamingStopped - called when there is/is no longer at least 1 streaming device.
									  Always comes after deviceStreaming.
  
  The first of all of the above event pairs is triggered as appropriate upon connection.  All of
  these events receives an argument with the most recent info about the device that triggered it.
  These events will always be fired in the order they are listed here, with reverse ordering for the
  matching shutdown call. (ie, deviceStreaming always comes after deviceAttached, and deviceStopped 
  will come before deviceRemoved).
  
  -deviceConnected/deviceDisconnected - These are considered deprecated and will be removed in
  the next revision.  In contrast to the other events and in keeping with it's original behavior,
  it will only be fired when a device begins streaming AFTER a connection has been established.
  It is not paired, and receives no device info.  Nearly identical functionality to
  streamingStarted/Stopped if you need to port.
*/
Controller.prototype.setupConnectionEvents = function () {
  var controller = this;
  this.connection.on('frame', function (frame) {
    controller.processFrame(frame);
  });
  // either deviceFrame or animationFrame:
  this.on(this.frameEventName, function (frame) {
    controller.processFinishedFrame(frame);
  });

  // here we backfill the 0.5.0 deviceEvents as best possible
  // backfill begin streaming events
  var backfillStreamingStartedEventsHandler = function () {
    if (controller.connection.opts.requestProtocolVersion < 5 && controller.streamingCount == 0) {
      controller.streamingCount = 1;
      var info = {
        attached: true,
        streaming: true,
        type: 'unknown',
        id: "Lx00000000000"
      };
      controller.devices[info.id] = info;

      controller.emit('deviceAttached', info);
      controller.emit('deviceStreaming', info);
      controller.emit('streamingStarted', info);
      controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler);
    }
  };

  var backfillStreamingStoppedEvents = function () {
    if (controller.streamingCount > 0) {
      for (var deviceId in controller.devices) {
        controller.emit('deviceStopped', controller.devices[deviceId]);
        controller.emit('deviceRemoved', controller.devices[deviceId]);
      }
      // only emit streamingStopped once, with the last device
      controller.emit('streamingStopped', controller.devices[deviceId]);

      controller.streamingCount = 0;

      for (var deviceId in controller.devices) {
        delete controller.devices[deviceId];
      }
    }
  };
  // Delegate connection events
  this.connection.on('focus', function () {

    if (controller.loopWhileDisconnected) {

      controller.startAnimationLoop();
    }

    controller.emit('focus');
  });
  this.connection.on('blur', function () {
    controller.emit('blur');
  });
  this.connection.on('protocol', function (protocol) {

    protocol.on('beforeFrameCreated', function (frameData) {
      controller.emit('beforeFrameCreated', frameData);
    });

    protocol.on('afterFrameCreated', function (frame, frameData) {
      controller.emit('afterFrameCreated', frame, frameData);
    });

    controller.emit('protocol', protocol);
  });

  this.connection.on('ready', function () {

    if (controller.checkVersion && !controller.inNode) {
      // show dialog only to web users
      controller.checkOutOfDate();
    }

    controller.emit('ready');
  });

  this.connection.on('connect', function () {
    controller.emit('connect');
    controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler);
    controller.connection.on('frame', backfillStreamingStartedEventsHandler);
  });

  this.connection.on('disconnect', function () {
    controller.emit('disconnect');
    backfillStreamingStoppedEvents();
  });

  // this does not fire when the controller is manually disconnected
  // or for Leap Service v1.2.0+
  this.connection.on('deviceConnect', function (evt) {
    if (evt.state) {
      controller.emit('deviceConnected');
      controller.connection.removeListener('frame', backfillStreamingStartedEventsHandler);
      controller.connection.on('frame', backfillStreamingStartedEventsHandler);
    } else {
      controller.emit('deviceDisconnected');
      backfillStreamingStoppedEvents();
    }
  });

  // Does not fire for Leap Service pre v1.2.0
  this.connection.on('deviceEvent', function (evt) {
    var info = evt.state,
        oldInfo = controller.devices[info.id];

    //Grab a list of changed properties in the device info
    var changed = {};
    for (var property in info) {
      //If a property i doesn't exist the cache, or has changed...
      if (!oldInfo || !oldInfo.hasOwnProperty(property) || oldInfo[property] != info[property]) {
        changed[property] = true;
      }
    }

    //Update the device list
    controller.devices[info.id] = info;

    //Fire events based on change list
    if (changed.attached) {
      controller.emit(info.attached ? 'deviceAttached' : 'deviceRemoved', info);
    }

    if (!changed.streaming) return;

    if (info.streaming) {
      controller.streamingCount++;
      controller.emit('deviceStreaming', info);
      if (controller.streamingCount == 1) {
        controller.emit('streamingStarted', info);
      }
      //if attached & streaming both change to true at the same time, that device was streaming
      //already when we connected.
      if (!changed.attached) {
        controller.emit('deviceConnected');
      }
    }
    //Since when devices are attached all fields have changed, don't send events for streaming being false.
    else if (!(changed.attached && info.attached)) {
        controller.streamingCount--;
        controller.emit('deviceStopped', info);
        if (controller.streamingCount == 0) {
          controller.emit('streamingStopped', info);
        }
        controller.emit('deviceDisconnected');
      }
  });

  this.on('newListener', function (event, listener) {
    if (event == 'deviceConnected' || event == 'deviceDisconnected') {
      console.warn(event + " events are depricated.  Consider using 'streamingStarted/streamingStopped' or 'deviceStreaming/deviceStopped' instead");
    }
  });
};

// Checks if the protocol version is the latest, if if not, shows the dialog.
Controller.prototype.checkOutOfDate = function () {
  console.assert(this.connection && this.connection.protocol);

  var serviceVersion = this.connection.protocol.serviceVersion;
  var protocolVersion = this.connection.protocol.version;
  var defaultProtocolVersion = this.connectionType.defaultProtocolVersion;

  if (defaultProtocolVersion > protocolVersion) {

    console.warn("Your Protocol Version is v" + protocolVersion + ", this app was designed for v" + defaultProtocolVersion);

    Dialog.warnOutOfDate({
      sV: serviceVersion,
      pV: protocolVersion
    });
    return true;
  } else {
    return false;
  }
};

Controller._pluginFactories = {};

/*
 * Registers a plugin, making is accessible to controller.use later on.
 *
 * @member plugin
 * @memberof Leap.Controller.prototype
 * @param {String} name The name of the plugin (usually camelCase).
 * @param {function} factory A factory method which will return an instance of a plugin.
 * The factory receives an optional hash of options, passed in via controller.use.
 *
 * Valid keys for the object include frame, hand, finger, tool, and pointable.  The value
 * of each key can be either a function or an object.  If given a function, that function
 * will be called once for every instance of the object, with that instance injected as an
 * argument.  This allows decoration of objects with additional data:
 *
 * ```javascript
 * Leap.Controller.plugin('testPlugin', function(options){
 *   return {
 *     frame: function(frame){
 *       frame.foo = 'bar';
 *     }
 *   }
 * });
 * ```
 *
 * When hand is used, the callback is called for every hand in `frame.hands`.  Note that
 * hand objects are recreated with every new frame, so that data saved on the hand will not
 * persist.
 *
 * ```javascript
 * Leap.Controller.plugin('testPlugin', function(){
 *   return {
 *     hand: function(hand){
 *       console.log('testPlugin running on hand ' + hand.id);
 *     }
 *   }
 * });
 * ```
 *
 * A factory can return an object to add custom functionality to Frames, Hands, or Pointables.
 * The methods are added directly to the object's prototype.  Finger and Tool cannot be used here, Pointable
 * must be used instead.
 * This is encouraged for calculations which may not be necessary on every frame.
 * Memoization is also encouraged, for cases where the method may be called many times per frame by the application.
 *
 * ```javascript
 * // This plugin allows hand.usefulData() to be called later.
 * Leap.Controller.plugin('testPlugin', function(){
 *   return {
 *     hand: {
 *       usefulData: function(){
 *         console.log('usefulData on hand', this.id);
 *         // memoize the results on to the hand, preventing repeat work:
 *         this.x || this.x = someExpensiveCalculation();
 *         return this.x;
 *       }
 *     }
 *   }
 * });
 *
 * Note that the factory pattern allows encapsulation for every plugin instance.
 *
 * ```javascript
 * Leap.Controller.plugin('testPlugin', function(options){
 *   options || options = {}
 *   options.center || options.center = [0,0,0]
 *
 *   privatePrintingMethod = function(){
 *     console.log('privatePrintingMethod - options', options);
 *   }
 *
 *   return {
 *     pointable: {
 *       publicPrintingMethod: function(){
 *         privatePrintingMethod();
 *       }
 *     }
 *   }
 * });
 *
 */
Controller.plugin = function (pluginName, factory) {
  if (this._pluginFactories[pluginName]) {
    console.warn("Plugin \"" + pluginName + "\" already registered");
  }
  return this._pluginFactories[pluginName] = factory;
};

/*
 * Returns a list of registered plugins.
 * @returns {Array} Plugin Factories.
 */
Controller.plugins = function () {
  return _.keys(this._pluginFactories);
};

var setPluginCallbacks = function (pluginName, type, callback) {

  if (['beforeFrameCreated', 'afterFrameCreated'].indexOf(type) != -1) {

    // todo - not able to "unuse" a plugin currently
    this.on(type, callback);
  } else {

    if (!this.pipeline) this.pipeline = new Pipeline(this);

    if (!this._pluginPipelineSteps[pluginName]) this._pluginPipelineSteps[pluginName] = [];

    this._pluginPipelineSteps[pluginName].push(this.pipeline.addWrappedStep(type, callback));
  }
};

var setPluginMethods = function (pluginName, type, hash) {
  var klass;

  if (!this._pluginExtendedMethods[pluginName]) this._pluginExtendedMethods[pluginName] = [];

  switch (type) {
    case 'frame':
      klass = Frame;
      break;
    case 'hand':
      klass = Hand;
      break;
    case 'pointable':
      klass = Pointable;
      _.extend(Finger.prototype, hash);
      _.extend(Finger.Invalid, hash);
      break;
    case 'finger':
      klass = Finger;
      break;
    default:
      throw pluginName + ' specifies invalid object type "' + type + '" for prototypical extension';
  }

  _.extend(klass.prototype, hash);
  _.extend(klass.Invalid, hash);
  this._pluginExtendedMethods[pluginName].push([klass, hash]);
};

/*
 * Begin using a registered plugin.  The plugin's functionality will be added to all frames
 * returned by the controller (and/or added to the objects within the frame).
 *  - The order of plugin execution inside the loop will match the order in which use is called by the application.
 *  - The plugin be run for both deviceFrames and animationFrames.
 *
 *  If called a second time, the options will be merged with those of the already instantiated plugin.
 *
 * @method use
 * @memberOf Leap.Controller.prototype
 * @param pluginName
 * @param {Hash} Options to be passed to the plugin's factory.
 * @returns the controller
 */
Controller.prototype.use = function (pluginName, options) {
  var functionOrHash, pluginFactory, key, pluginInstance;

  pluginFactory = typeof pluginName == 'function' ? pluginName : Controller._pluginFactories[pluginName];

  if (!pluginFactory) {
    throw 'Leap Plugin ' + pluginName + ' not found.';
  }

  options || (options = {});

  if (this.plugins[pluginName]) {
    _.extend(this.plugins[pluginName], options);
    return this;
  }

  this.plugins[pluginName] = options;

  pluginInstance = pluginFactory.call(this, options);

  for (key in pluginInstance) {

    functionOrHash = pluginInstance[key];

    if (typeof functionOrHash === 'function') {

      setPluginCallbacks.call(this, pluginName, key, functionOrHash);
    } else {

      setPluginMethods.call(this, pluginName, key, functionOrHash);
    }
  }

  return this;
};

/*
 * Stop using a used plugin.  This will remove any of the plugin's pipeline methods (those called on every frame)
 * and remove any methods which extend frame-object prototypes.
 *
 * @method stopUsing
 * @memberOf Leap.Controller.prototype
 * @param pluginName
 * @returns the controller
 */
Controller.prototype.stopUsing = function (pluginName) {
  var steps = this._pluginPipelineSteps[pluginName],
      extMethodHashes = this._pluginExtendedMethods[pluginName],
      i = 0,
      klass,
      extMethodHash;

  if (!this.plugins[pluginName]) return;

  if (steps) {
    for (i = 0; i < steps.length; i++) {
      this.pipeline.removeStep(steps[i]);
    }
  }

  if (extMethodHashes) {
    for (i = 0; i < extMethodHashes.length; i++) {
      klass = extMethodHashes[i][0];
      extMethodHash = extMethodHashes[i][1];
      for (var methodName in extMethodHash) {
        delete klass.prototype[methodName];
        delete klass.Invalid[methodName];
      }
    }
  }

  delete this.plugins[pluginName];

  return this;
};

Controller.prototype.useRegisteredPlugins = function () {
  for (var plugin in Controller._pluginFactories) {
    this.use(plugin);
  }
};

_.extend(Controller.prototype, EventEmitter.prototype);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Leap is the global namespace of the Leap API.
 * @namespace Leap
 */
module.exports = {
  Controller: __webpack_require__(112),
  Frame: __webpack_require__(24),
  Gesture: __webpack_require__(25),
  Hand: __webpack_require__(11),
  Pointable: __webpack_require__(4),
  Finger: __webpack_require__(10),
  InteractionBox: __webpack_require__(54),
  CircularBuffer: __webpack_require__(51),
  UI: __webpack_require__(115),
  JSONProtocol: __webpack_require__(55).JSONProtocol,
  glMatrix: __webpack_require__(2),
  mat3: __webpack_require__(2).mat3,
  vec3: __webpack_require__(2).vec3,
  loopController: undefined,
  version: __webpack_require__(118),

  /**
   * Expose utility libraries for convenience
   * Use carefully - they may be subject to upgrade or removal in different versions of LeapJS.
   *
   */
  _: __webpack_require__(0),
  EventEmitter: __webpack_require__(3).EventEmitter,

  /**
   * The Leap.loop() function passes a frame of Leap data to your
   * callback function and then calls window.requestAnimationFrame() after
   * executing your callback function.
   *
   * Leap.loop() sets up the Leap controller and WebSocket connection for you.
   * You do not need to create your own controller when using this method.
   *
   * Your callback function is called on an interval determined by the client
   * browser. Typically, this is on an interval of 60 frames/second. The most
   * recent frame of Leap data is passed to your callback function. If the Leap
   * is producing frames at a slower rate than the browser frame rate, the same
   * frame of Leap data can be passed to your function in successive animation
   * updates.
   *
   * As an alternative, you can create your own Controller object and use a
   * {@link Controller#onFrame onFrame} callback to process the data at
   * the frame rate of the Leap device. See {@link Controller} for an
   * example.
   *
   * @method Leap.loop
   * @param {function} callback A function called when the browser is ready to
   * draw to the screen. The most recent {@link Frame} object is passed to
   * your callback function.
   *
   * ```javascript
   *    Leap.loop( function( frame ) {
   *        // ... your code here
   *    })
   * ```
   */
  loop: function (opts, callback) {
    if (opts && callback === undefined && {}.toString.call(opts) === '[object Function]') {
      callback = opts;
      opts = {};
    }

    if (this.loopController) {
      if (opts) {
        this.loopController.setupFrameEvents(opts);
      }
    } else {
      this.loopController = new this.Controller(opts);
    }

    this.loopController.loop(callback);
    return this.loopController;
  },

  /*
   * Convenience method for Leap.Controller.plugin
   */
  plugin: function (name, options) {
    this.Controller.plugin(name, options);
  }
};

/***/ }),
/* 114 */
/***/ (function(module, exports) {

var Pipeline = module.exports = function (controller) {
  this.steps = [];
  this.controller = controller;
};

Pipeline.prototype.addStep = function (step) {
  this.steps.push(step);
};

Pipeline.prototype.run = function (frame) {
  var stepsLength = this.steps.length;
  for (var i = 0; i != stepsLength; i++) {
    if (!frame) break;
    frame = this.steps[i](frame);
  }
  return frame;
};

Pipeline.prototype.removeStep = function (step) {
  var index = this.steps.indexOf(step);
  if (index === -1) throw "Step not found in pipeline";
  this.steps.splice(index, 1);
};

/*
 * Wraps a plugin callback method in method which can be run inside the pipeline.
 * This wrapper method loops the callback over objects within the frame as is appropriate,
 * calling the callback for each in turn.
 *
 * @method createStepFunction
 * @memberOf Leap.Controller.prototype
 * @param {Controller} The controller on which the callback is called.
 * @param {String} type What frame object the callback is run for and receives.
 *       Can be one of 'frame', 'finger', 'hand', 'pointable', 'tool'
 * @param {function} callback The method which will be run inside the pipeline loop.  Receives one argument, such as a hand.
 * @private
 */
Pipeline.prototype.addWrappedStep = function (type, callback) {
  var controller = this.controller,
      step = function (frame) {
    var dependencies, i, len;
    dependencies = type == 'frame' ? [frame] : frame[type + 's'] || [];

    for (i = 0, len = dependencies.length; i < len; i++) {
      callback.call(controller, dependencies[i]);
    }

    return frame;
  };

  this.addStep(step);
  return step;
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

exports.UI = {
  Region: __webpack_require__(117),
  Cursor: __webpack_require__(116)
};

/***/ }),
/* 116 */
/***/ (function(module, exports) {

var Cursor = module.exports = function () {
  return function (frame) {
    var pointable = frame.pointables.sort(function (a, b) {
      return a.z - b.z;
    })[0];
    if (pointable && pointable.valid) {
      frame.cursorPosition = pointable.tipPosition;
    }
    return frame;
  };
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(3).EventEmitter,
    _ = __webpack_require__(0);

var Region = module.exports = function (start, end) {
  this.start = new Vector(start);
  this.end = new Vector(end);
  this.enteredFrame = null;
};

Region.prototype.hasPointables = function (frame) {
  for (var i = 0; i != frame.pointables.length; i++) {
    var position = frame.pointables[i].tipPosition;
    if (position.x >= this.start.x && position.x <= this.end.x && position.y >= this.start.y && position.y <= this.end.y && position.z >= this.start.z && position.z <= this.end.z) {
      return true;
    }
  }
  return false;
};

Region.prototype.listener = function (opts) {
  var region = this;
  if (opts && opts.nearThreshold) this.setupNearRegion(opts.nearThreshold);
  return function (frame) {
    return region.updatePosition(frame);
  };
};

Region.prototype.clipper = function () {
  var region = this;
  return function (frame) {
    region.updatePosition(frame);
    return region.enteredFrame ? frame : null;
  };
};

Region.prototype.setupNearRegion = function (distance) {
  var nearRegion = this.nearRegion = new Region([this.start.x - distance, this.start.y - distance, this.start.z - distance], [this.end.x + distance, this.end.y + distance, this.end.z + distance]);
  var region = this;
  nearRegion.on("enter", function (frame) {
    region.emit("near", frame);
  });
  nearRegion.on("exit", function (frame) {
    region.emit("far", frame);
  });
  region.on('exit', function (frame) {
    region.emit("near", frame);
  });
};

Region.prototype.updatePosition = function (frame) {
  if (this.nearRegion) this.nearRegion.updatePosition(frame);
  if (this.hasPointables(frame) && this.enteredFrame == null) {
    this.enteredFrame = frame;
    this.emit("enter", this.enteredFrame);
  } else if (!this.hasPointables(frame) && this.enteredFrame != null) {
    this.enteredFrame = null;
    this.emit("exit", this.enteredFrame);
  }
  return frame;
};

Region.prototype.normalize = function (position) {
  return new Vector([(position.x - this.start.x) / (this.end.x - this.start.x), (position.y - this.start.y) / (this.end.y - this.start.y), (position.z - this.start.z) / (this.end.z - this.start.z)]);
};

Region.prototype.mapToXY = function (position, width, height) {
  var normalized = this.normalize(position);
  var x = normalized.x,
      y = normalized.y;
  if (x > 1) x = 1;else if (x < -1) x = -1;
  if (y > 1) y = 1;else if (y < -1) y = -1;
  return [(x + 1) / 2 * width, (1 - y) / 2 * height, normalized.z];
};

_.extend(Region.prototype, EventEmitter.prototype);

/***/ }),
/* 118 */
/***/ (function(module, exports) {

// This file is automatically updated from package.json by grunt.
module.exports = {
  full: '0.6.4',
  major: 0,
  minor: 6,
  dot: 4
};

/***/ }),
/* 119 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/// shim for browser packaging

module.exports = function () {
  return global.WebSocket || global.MozWebSocket;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_three__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_d3___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_d3__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__global_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__input_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ring_js__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__styles_main_less__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__styles_main_less___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__styles_main_less__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__data_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__map_refac_js__ = __webpack_require__(57);











function render() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__global_js__["a" /* update */])();
    __WEBPACK_IMPORTED_MODULE_3__input_js__["a" /* updateInputEase */]();

    __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].clearRect(0, 0, 1080, 1080);
    __WEBPACK_IMPORTED_MODULE_4__ring_js__["a" /* render */]();

    __WEBPACK_IMPORTED_MODULE_3__input_js__["b" /* render_debug */]();
    __WEBPACK_IMPORTED_MODULE_7__map_refac_js__["a" /* render */]();
    requestAnimationFrame(render);
}

render();

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Behaviors */

/**generic particle system */
class ParticleSys {
    constructor(len, modifiers = []) {
        this.Points = [];
        this.Modifers = modifiers;
        for (var i = 0; i < len; i++) {
            this.Points.push({
                x: 0,
                y: 0,
                z: 0,
                vx: 0,
                vy: 0,
                vz: 0,
                ax: 0,
                ay: 0,
                az: 0,
                r: 1,
                g: 1,
                b: 1,
                tr: 1,
                tg: 1,
                tb: 1,
                shuffle: Math.random() * 0.8 + 0.1,
                shuffleSq: (Math.random() * 0.8 + 0.1) * (Math.random() * 0.8 + 0.1),
                life: 1,
                lifeV: 0,
                bag: {}
            });
        }
    }

    update() {

        for (var j = 0; j < this.Modifers.length; j++) {
            if (!this.Modifers[j].disabled) {
                this.Modifers[j][0](this);
            }
            //mod(particle, index, particleArr, particleSys)
        }

        for (var i = 0; i < this.Points.length; i++) {
            var cur = this.Points[i];
            if (cur.life <= 0) {
                continue;
            }
            cur.ax = 0;
            cur.ay = 0;
            cur.az = 0;

            for (var j = 0; j < this.Modifers.length; j++) {
                if (!this.Modifers[j].disabled) {
                    this.Modifers[j][1](cur, i, this.Points, this);
                }
                //mod(particle, index, particleArr, particleSys)
            }

            //built in
            ease(cur, 'tr', 'r');
            ease(cur, 'tg', 'g');
            ease(cur, 'tb', 'b');

            cur.life -= cur.lifeV;
            cur.vx += cur.ax;
            cur.vy += cur.ay;
            cur.vz += cur.az;
            cur.x += cur.vx;
            cur.y += cur.vy;
            cur.z += cur.vz;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ParticleSys;


var Behaviors = {
    Targeting: {
        modifier: () => [null, function (p, index, particleArr, particleSys) {
            p.life = 1; //always alive
            //calculate acc
            p.ax = (p.bag.tx - p.x) * 0.01;
            p.ay = (p.bag.ty - p.y) * 0.01;
            p.az = (p.bag.tz - p.z) * .1 * p.shuffleSq;
            p.vx *= 0.85;
            p.vy *= 0.85;
            p.vz *= 0.45;
        }],
        set: function (psys, arr) {
            for (var i = 0; i < arr.length; i++) {
                psys.Points[i].bag.tx = arr[i].x;
                psys.Points[i].bag.ty = arr[i].y;
                psys.Points[i].bag.tz = arr[i].z;
            }
        }
    },
    Shuffle: {
        set: function (psys, t) {
            psys.shuffleCounter = t;
        },
        modifier: () => [function (psys) {
            if (psys.shuffleCounter > 0) {
                psys.shuffleCounter--;
            }
        },, function (p, index, particleArr, particleSys) {
            if (particleSys.shuffleCounter < 0) return;
            p.ax += (Math.random() - 0.5) * .52;
            p.ay += (Math.random() - 0.5) * .52;
            p.az += (Math.random() - 0.5) * .52;
        }]
    }
};

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_webpack_zepto__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_webpack_zepto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_webpack_zepto__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__styles_stick_less__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__styles_stick_less___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__styles_stick_less__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__global_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__input_js__ = __webpack_require__(8);




const lineDashSegs = [3, 3];

function unitRound(unit) {
    return (/万|亿/.test(unit) ? 100 : /\%/.test(unit) ? 10 : 1
    );
}
//shit code
class stick {
    //a stick
    constructor(stickParent, title, unit, roundTo, baseAngle, hue = 0.56) {
        this.selected = 0;
        this.hue = hue;
        this.selected_e = 0;
        this.angle_e = baseAngle;
        this.angle = baseAngle;
        this.baseAngle = baseAngle;
        this.scale = 1;
        this.title = title;
        this.data = 13392;
        this.data_e = 0;
        this.visibility_e = 0;
        this.roundTo = roundTo;
        this.scale_e = 1;
        this.hitBox = __WEBPACK_IMPORTED_MODULE_0_webpack_zepto___default()(`<div></div>`);
        this.hitBox.css({
            width: '150px',
            height: '50px',
            opacity: 0,
            background: "Red",
            color: "#2fafff",
            position: "absolute",
            "top": '-25px',
            "left": "-75px",
            "text-align": "right",
            "font-size": "15px",
            "transform-origin": "50% 50%"
        });
        this.dataBox = __WEBPACK_IMPORTED_MODULE_0_webpack_zepto___default()(`
        <div class='dataViz'>
            <div class='number'><span class='number-text'>18374</span><span>${unit}</span></div>
            <div class='title' style='background: ${hsl(this.hue, 0.65, 0.5)}'>${title}</div>
        </div>`);
        this.dataTitle = this.dataBox.find(".title");
        this.dataNumber = this.dataBox.find(".number-text");
        this.parent = stickParent;
        this.hitBox.appendTo(stickParent.container);
        this.dataBox.appendTo(stickParent.container);
    }

    setData(d) {
        this.data = d;
    }

    render() {

        var mirror = this.baseAngle >= 180;

        ease(this, 'angle', 'angle_e');
        ease(this, 'scale', 'scale_e');
        if (!this.selected) {
            this.data_e = 0;
        } else {
            ease(this, 'data', 'data_e', 0.4);
        }
        ease(this, 'selected', 'selected_e', 0.4);

        this.hitBox.get(0).style.transform = `rotate(${this.angle_e}deg) translate3d(-${Math.round(500 - this.visibility_e * 100)}px, 0px, 0px) scale(1, ${this.scale_e})`;

        //do canvas stuff
        __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].lineCap = "round";
        __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].lineJoin = "round";
        var deg = this.angle_e / 180 * Math.PI;

        pushMatrix(__WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */], () => {
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].lineWidth = 3;
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].rotate(deg);

            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].beginPath();
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].strokeStyle = hsl(this.hue, 1, this.selected_e + 0.1);
            var arclen = 4 / 180 * Math.PI * this.scale_e;
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].arc(0, 0, 600 - this.visibility_e * 100, -Math.PI - arclen, -Math.PI + arclen);
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].stroke();

            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].beginPath();
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].strokeStyle = hsl(this.hue, 0.8 * (this.visibility_e + 0.2), this.selected_e + 0.4);
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].translate(-500 + this.visibility_e * 100, 0);
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].moveTo(0, 0);
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].lineTo(-50 * (0.1 + 0.9 * this.visibility_e) - this.selected_e * 40, 0);
            __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].stroke();
        });

        if (!this.dataTitle.measured) {
            this.dataTitle.measured = this.dataTitle.width();
        }
        if (this.selected && this.parent.focused && (!__WEBPACK_IMPORTED_MODULE_3__input_js__["c" /* mouse */].flying || __WEBPACK_IMPORTED_MODULE_3__input_js__["c" /* mouse */].highlock)) {
            pushMatrix(__WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */], () => {
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].lineWidth = 2;
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].beginPath();
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].setLineDash(lineDashSegs);
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].globalAlpha = this.selected_e;
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].strokeStyle = hsl(this.hue, 0.8, this.selected_e + 0.4);
                var baseX, baseY;
                baseX = -Math.cos(deg) * 400;
                baseY = -Math.sin(deg) * 400;
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].translate(baseX, baseY);
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].moveTo(mirror ? -5 : 5, 0);
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].lineTo((mirror ? -50 : 50) * this.scale_e * this.scale_e, 0);
                __WEBPACK_IMPORTED_MODULE_2__global_js__["b" /* ctx2d */].stroke();
                this.dataBox.get(0).style.display = "block";
                if (!mirror) {
                    this.dataBox.get(0).style.transform = `translate3d(${baseX - 50 + 50 * this.scale_e + 50}px, ${baseY - 20}px, 0px)`;
                } else {
                    this.dataBox.get(0).style.transform = `translate3d(${-this.dataTitle.measured + baseX - 50 * this.scale_e}px, ${baseY - 20}px, 0px)`;
                }
                if (hoveringElement && (hoveringElement.parentElement == this.dataBox.get(0) || hoveringElement.parentElement && hoveringElement.parentElement.parentElement == this.dataBox.get(0))) {
                    this.dataBox.get(0).style.opacity = 0.3;
                } else {
                    this.dataBox.get(0).style.opacity = 1;
                }
                this.dataNumber.text(Math.round(this.data_e * this.roundTo) / this.roundTo);
            });
        } else {
            this.dataBox.get(0).style.display = "none";
        }
    }
}
/* unused harmony export stick */


var managedSticks = [];

class stickHolder {

    constructor(dataSet, baseAngle = 0, hue = 0.56) {
        managedSticks.push(this);
        this.dataSet = dataSet;
        this.children = [];
        this.selection = -1;
        this.visibility = 1;
        this.focused = false;
        this.baseAngle = baseAngle;
        this.visibility_e = 0;
        this.hue = hue;
        this.container = __WEBPACK_IMPORTED_MODULE_0_webpack_zepto___default()(`
        <div 
            id='stickHolder' 
            style='z-index:9999999; position: absolute; display: block; transform: translate(540px, 540px)'></div>`);
    }

    setup() {
        this.container.appendTo(document.querySelector("body"));
        this.dataSet.forEach(dt => {
            var s = new stick(this, dt.split("|")[0], dt.split("|")[1], unitRound(dt.split("|")[1]), this.baseAngle, this.hue);
            this.children.push(s);
        });
    }

    render() {

        if (!this.focused || __WEBPACK_IMPORTED_MODULE_3__input_js__["c" /* mouse */].flying && !__WEBPACK_IMPORTED_MODULE_3__input_js__["c" /* mouse */].highlock) {
            this.visibility = 0;
        } else {
            this.visibility = 1;
        }

        ease(this, 'visibility', 'visibility_e', 0.06, 0.00001);
        var _found = false;
        for (var i = 0; i < this.children.length; i++) {
            if (global.hoveringElement == this.children[i].hitBox.get(0)) {
                _found = true;
                if (this.selection !== i) {
                    this.selection = i;
                }
            }
        }
        // if (!_found) this.selection = -1;
        if (_found) {
            this.focused = true;
            //force to deselect peers ops
            for (var i = 0; i < managedSticks.length; i++) {
                if (managedSticks[i] != this) {
                    managedSticks[i].focused = false;
                }
            }
        }

        var deg_span = 4;

        var deg = this.children.length / 2 * deg_span + this.baseAngle; //init position
        if (this.selection >= 0) {
            deg += deg_span; //fix :)
        }
        for (var i = 0; i < this.children.length; i++) {
            var stick = this.children[i];
            stick.visibility_e = this.visibility_e;
            stick.selected = this.selection == i ? 1 : 0;
            deg -= stick.selected || i - 1 == this.selection && this.selection >= 0 ? deg_span * 2 : deg_span;
            stick.angle = deg;
            stick.scale = stick.selected ? 1 : 0.5;
            this.children[i].render();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = stickHolder;

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(12)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)(undefined);
// imports


// module
exports.push([module.i, "body,\nhtml {\n  margin: 0;\n  padding: 0;\n  background: #333;\n  font-family: \"PingFang SC\";\n  overflow: hidden;\n}\n.maskelem {\n  display: block;\n  z-index: 9999999;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 1080px;\n  height: 1080px;\n  background: url(\"/images/mask.png\");\n  background-size: cover;\n}\n* {\n  user-select: none;\n}\n.labelContainer {\n  height: 1080px;\n  width: 1080px;\n  border-radius: 888888em;\n  overflow: hidden;\n}\ncanvas,\nsvg {\n  height: 1080px;\n  width: 1080px;\n  position: absolute;\n}\n.bg {\n  display: block;\n  position: absolute;\n  height: 1080px;\n  width: 1080px;\n  border-radius: 9999em;\n  background: black;\n}\n", ""]);

// exports


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)(undefined);
// imports


// module
exports.push([module.i, "svg {\n  display: block;\n  position: absolute;\n}\nsvg * {\n  stroke: transparent;\n  fill: transparent;\n}\n.label {\n  color: white;\n  padding: 10px 10px;\n  font-size: 20px;\n  font-family: \"PingFang SC\";\n  font-weight: 800;\n}\n.label-tiny {\n  color: white;\n  padding: 10px 10px;\n  font-size: 15px;\n  font-family: \"PingFang SC\";\n  font-weight: 800;\n}\n.selection_title {\n  background: #ffffff;\n  color: black;\n  font-size: 30px;\n  font-family: \"PingFang SC\";\n  position: absolute;\n  font-weight: 700;\n  z-index: 1399999;\n  padding: 10px 25px;\n  top: 70px;\n  right: 380px;\n}\n", ""]);

// exports


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)(undefined);
// imports


// module
exports.push([module.i, ".dataViz {\n  opacity: 1;\n  position: absolute;\n  transform-origin: 50% 50%;\n  z-index: 999999;\n  font-size: 20px;\n}\n.dataViz .title {\n  white-space: nowrap;\n  color: white;\n  padding: 8px 15px;\n  position: absolute;\n}\n.dataViz .number {\n  height: 0;\n  position: absolute;\n  bottom: -40px;\n  font-size: 80px;\n  left: 2px;\n  white-space: nowrap;\n  color: white;\n  vertical-align: text-top;\n  text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;\n  font-family: 'Not So Stout Deco';\n}\n.dataViz .number span:nth-child(2) {\n  font-family: 'PingFang SC';\n  font-size: 20px;\n  position: absolute;\n  top: 20px;\n  opacity: 0.8;\n}\n", ""]);

// exports


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(125);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(27)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/index.js!./map.less", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/index.js!./map.less");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(126);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(27)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/index.js!./stick.less", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/less-loader/dist/index.js!./stick.less");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);